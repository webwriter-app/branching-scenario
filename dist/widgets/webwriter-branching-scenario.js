var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self2, value) => {
  for (var i5 = 0, fns = array[flags >> 1], n7 = fns && fns.length; i5 < n7; i5++) flags & 1 ? fns[i5].call(self2) : value = fns[i5].call(self2, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k3 = flags & 7, s6 = !!(flags & 8), p3 = !!(flags & 16);
  var j3 = k3 > 3 ? array.length + 1 : k3 ? s6 ? 1 : 2 : 0, key = __decoratorStrings[k3 + 5];
  var initializers = k3 > 3 && (array[j3 - 1] = []), extraInitializers = array[j3] || (array[j3] = []);
  var desc = k3 && (!p3 && !s6 && (target = target.prototype), k3 < 5 && (k3 > 3 || !p3) && __getOwnPropDesc(k3 < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x4) {
    return __privateSet(this, extra, x4);
  } }, name));
  k3 ? p3 && k3 < 4 && __name(extra, (k3 > 2 ? "set " : k3 > 1 ? "get " : "") + name) : __name(target, name);
  for (var i5 = decorators.length - 1; i5 >= 0; i5--) {
    ctx = __decoratorContext(k3, name, done = {}, array[3], extraInitializers);
    if (k3) {
      ctx.static = s6, ctx.private = p3, access = ctx.access = { has: p3 ? (x4) => __privateIn(target, x4) : (x4) => name in x4 };
      if (k3 ^ 3) access.get = p3 ? (x4) => (k3 ^ 1 ? __privateGet : __privateMethod)(x4, target, k3 ^ 4 ? extra : desc.get) : (x4) => x4[name];
      if (k3 > 2) access.set = p3 ? (x4, y3) => __privateSet(x4, target, y3, k3 ^ 4 ? extra : desc.set) : (x4, y3) => x4[name] = y3;
    }
    it = (0, decorators[i5])(k3 ? k3 < 4 ? p3 ? extra : desc[key] : k3 > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k3 ^ 4 || it === void 0) __expectFn(it) && (k3 > 4 ? initializers.unshift(it) : k3 ? p3 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k3 || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p3 ? k3 ^ 4 ? extra : desc : target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// src/node_modules/drawflow/dist/drawflow.min.js
var require_drawflow_min = __commonJS({
  "src/node_modules/drawflow/dist/drawflow.min.js"(exports, module) {
    !function(e10, t8) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t8() : "function" == typeof define && define.amd ? define([], t8) : "object" == typeof exports ? exports.Drawflow = t8() : e10.Drawflow = t8();
    }("undefined" != typeof self ? self : exports, function() {
      return function(e10) {
        var t8 = {};
        function n7(i5) {
          if (t8[i5]) return t8[i5].exports;
          var s6 = t8[i5] = { i: i5, l: false, exports: {} };
          return e10[i5].call(s6.exports, s6, s6.exports, n7), s6.l = true, s6.exports;
        }
        return n7.m = e10, n7.c = t8, n7.d = function(e11, t9, i5) {
          n7.o(e11, t9) || Object.defineProperty(e11, t9, { enumerable: true, get: i5 });
        }, n7.r = function(e11) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e11, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e11, "__esModule", { value: true });
        }, n7.t = function(e11, t9) {
          if (1 & t9 && (e11 = n7(e11)), 8 & t9) return e11;
          if (4 & t9 && "object" == typeof e11 && e11 && e11.__esModule) return e11;
          var i5 = /* @__PURE__ */ Object.create(null);
          if (n7.r(i5), Object.defineProperty(i5, "default", { enumerable: true, value: e11 }), 2 & t9 && "string" != typeof e11) for (var s6 in e11) n7.d(i5, s6, function(t10) {
            return e11[t10];
          }.bind(null, s6));
          return i5;
        }, n7.n = function(e11) {
          var t9 = e11 && e11.__esModule ? function() {
            return e11.default;
          } : function() {
            return e11;
          };
          return n7.d(t9, "a", t9), t9;
        }, n7.o = function(e11, t9) {
          return Object.prototype.hasOwnProperty.call(e11, t9);
        }, n7.p = "", n7(n7.s = 0);
      }([function(e10, t8, n7) {
        "use strict";
        n7.r(t8), n7.d(t8, "default", function() {
          return i5;
        });
        class i5 {
          constructor(e11, t9 = null, n8 = null) {
            this.events = {}, this.container = e11, this.precanvas = null, this.nodeId = 1, this.ele_selected = null, this.node_selected = null, this.drag = false, this.reroute = false, this.reroute_fix_curvature = false, this.curvature = 0.5, this.reroute_curvature_start_end = 0.5, this.reroute_curvature = 0.5, this.reroute_width = 6, this.drag_point = false, this.editor_selected = false, this.connection = false, this.connection_ele = null, this.connection_selected = null, this.canvas_x = 0, this.canvas_y = 0, this.pos_x = 0, this.pos_x_start = 0, this.pos_y = 0, this.pos_y_start = 0, this.mouse_x = 0, this.mouse_y = 0, this.line_path = 5, this.first_click = null, this.force_first_input = false, this.draggable_inputs = true, this.useuuid = false, this.parent = n8, this.noderegister = {}, this.render = t9, this.drawflow = { drawflow: { Home: { data: {} } } }, this.module = "Home", this.editor_mode = "edit", this.zoom = 1, this.zoom_max = 1.6, this.zoom_min = 0.5, this.zoom_value = 0.1, this.zoom_last_value = 1, this.evCache = new Array(), this.prevDiff = -1;
          }
          start() {
            this.container.classList.add("parent-drawflow"), this.container.tabIndex = 0, this.precanvas = document.createElement("div"), this.precanvas.classList.add("drawflow"), this.container.appendChild(this.precanvas), this.container.addEventListener("mouseup", this.dragEnd.bind(this)), this.container.addEventListener("mousemove", this.position.bind(this)), this.container.addEventListener("mousedown", this.click.bind(this)), this.container.addEventListener("touchend", this.dragEnd.bind(this)), this.container.addEventListener("touchmove", this.position.bind(this)), this.container.addEventListener("touchstart", this.click.bind(this)), this.container.addEventListener("contextmenu", this.contextmenu.bind(this)), this.container.addEventListener("keydown", this.key.bind(this)), this.container.addEventListener("wheel", this.zoom_enter.bind(this)), this.container.addEventListener("input", this.updateNodeValue.bind(this)), this.container.addEventListener("dblclick", this.dblclick.bind(this)), this.container.onpointerdown = this.pointerdown_handler.bind(this), this.container.onpointermove = this.pointermove_handler.bind(this), this.container.onpointerup = this.pointerup_handler.bind(this), this.container.onpointercancel = this.pointerup_handler.bind(this), this.container.onpointerout = this.pointerup_handler.bind(this), this.container.onpointerleave = this.pointerup_handler.bind(this), this.load();
          }
          pointerdown_handler(e11) {
            this.evCache.push(e11);
          }
          pointermove_handler(e11) {
            for (var t9 = 0; t9 < this.evCache.length; t9++) if (e11.pointerId == this.evCache[t9].pointerId) {
              this.evCache[t9] = e11;
              break;
            }
            if (2 == this.evCache.length) {
              var n8 = Math.abs(this.evCache[0].clientX - this.evCache[1].clientX);
              this.prevDiff > 100 && (n8 > this.prevDiff && this.zoom_in(), n8 < this.prevDiff && this.zoom_out()), this.prevDiff = n8;
            }
          }
          pointerup_handler(e11) {
            this.remove_event(e11), this.evCache.length < 2 && (this.prevDiff = -1);
          }
          remove_event(e11) {
            for (var t9 = 0; t9 < this.evCache.length; t9++) if (this.evCache[t9].pointerId == e11.pointerId) {
              this.evCache.splice(t9, 1);
              break;
            }
          }
          load() {
            for (var e11 in this.drawflow.drawflow[this.module].data) this.addNodeImport(this.drawflow.drawflow[this.module].data[e11], this.precanvas);
            if (this.reroute) for (var e11 in this.drawflow.drawflow[this.module].data) this.addRerouteImport(this.drawflow.drawflow[this.module].data[e11]);
            for (var e11 in this.drawflow.drawflow[this.module].data) this.updateConnectionNodes("node-" + e11);
            const t9 = this.drawflow.drawflow;
            let n8 = 1;
            Object.keys(t9).map(function(e12, i6) {
              Object.keys(t9[e12].data).map(function(e13, t10) {
                parseInt(e13) >= n8 && (n8 = parseInt(e13) + 1);
              });
            }), this.nodeId = n8;
          }
          removeReouteConnectionSelected() {
            this.dispatch("connectionUnselected", true), this.reroute_fix_curvature && this.connection_selected.parentElement.querySelectorAll(".main-path").forEach((e11, t9) => {
              e11.classList.remove("selected");
            });
          }
          click(e11) {
            if (this.dispatch("click", e11), "fixed" === this.editor_mode) {
              if (e11.preventDefault(), "parent-drawflow" !== e11.target.classList[0] && "drawflow" !== e11.target.classList[0]) return false;
              this.ele_selected = e11.target.closest(".parent-drawflow");
            } else "view" === this.editor_mode ? (null != e11.target.closest(".drawflow") || e11.target.matches(".parent-drawflow")) && (this.ele_selected = e11.target.closest(".parent-drawflow"), e11.preventDefault()) : (this.first_click = e11.target, this.ele_selected = e11.target, 0 === e11.button && this.contextmenuDel(), null != e11.target.closest(".drawflow_content_node") && (this.ele_selected = e11.target.closest(".drawflow_content_node").parentElement));
            switch (this.ele_selected.classList[0]) {
              case "drawflow-node":
                null != this.node_selected && (this.node_selected.classList.remove("selected"), this.node_selected != this.ele_selected && this.dispatch("nodeUnselected", true)), null != this.connection_selected && (this.connection_selected.classList.remove("selected"), this.removeReouteConnectionSelected(), this.connection_selected = null), this.node_selected != this.ele_selected && this.dispatch("nodeSelected", this.ele_selected.id.slice(5)), this.node_selected = this.ele_selected, this.node_selected.classList.add("selected"), this.draggable_inputs ? "SELECT" !== e11.target.tagName && (this.drag = true) : "INPUT" !== e11.target.tagName && "TEXTAREA" !== e11.target.tagName && "SELECT" !== e11.target.tagName && true !== e11.target.hasAttribute("contenteditable") && (this.drag = true);
                break;
              case "output":
                this.connection = true, null != this.node_selected && (this.node_selected.classList.remove("selected"), this.node_selected = null, this.dispatch("nodeUnselected", true)), null != this.connection_selected && (this.connection_selected.classList.remove("selected"), this.removeReouteConnectionSelected(), this.connection_selected = null), this.drawConnection(e11.target);
                break;
              case "parent-drawflow":
              case "drawflow":
                null != this.node_selected && (this.node_selected.classList.remove("selected"), this.node_selected = null, this.dispatch("nodeUnselected", true)), null != this.connection_selected && (this.connection_selected.classList.remove("selected"), this.removeReouteConnectionSelected(), this.connection_selected = null), this.editor_selected = true;
                break;
              case "main-path":
                null != this.node_selected && (this.node_selected.classList.remove("selected"), this.node_selected = null, this.dispatch("nodeUnselected", true)), null != this.connection_selected && (this.connection_selected.classList.remove("selected"), this.removeReouteConnectionSelected(), this.connection_selected = null), this.connection_selected = this.ele_selected, this.connection_selected.classList.add("selected");
                const t9 = this.connection_selected.parentElement.classList;
                t9.length > 1 && (this.dispatch("connectionSelected", { output_id: t9[2].slice(14), input_id: t9[1].slice(13), output_class: t9[3], input_class: t9[4] }), this.reroute_fix_curvature && this.connection_selected.parentElement.querySelectorAll(".main-path").forEach((e12, t10) => {
                  e12.classList.add("selected");
                }));
                break;
              case "point":
                this.drag_point = true, this.ele_selected.classList.add("selected");
                break;
              case "drawflow-delete":
                this.node_selected && this.removeNodeId(this.node_selected.id), this.connection_selected && this.removeConnection(), null != this.node_selected && (this.node_selected.classList.remove("selected"), this.node_selected = null, this.dispatch("nodeUnselected", true)), null != this.connection_selected && (this.connection_selected.classList.remove("selected"), this.removeReouteConnectionSelected(), this.connection_selected = null);
            }
            "touchstart" === e11.type ? (this.pos_x = e11.touches[0].clientX, this.pos_x_start = e11.touches[0].clientX, this.pos_y = e11.touches[0].clientY, this.pos_y_start = e11.touches[0].clientY, this.mouse_x = e11.touches[0].clientX, this.mouse_y = e11.touches[0].clientY) : (this.pos_x = e11.clientX, this.pos_x_start = e11.clientX, this.pos_y = e11.clientY, this.pos_y_start = e11.clientY), ["input", "output", "main-path"].includes(this.ele_selected.classList[0]) && e11.preventDefault(), this.dispatch("clickEnd", e11);
          }
          position(e11) {
            if ("touchmove" === e11.type) var t9 = e11.touches[0].clientX, n8 = e11.touches[0].clientY;
            else t9 = e11.clientX, n8 = e11.clientY;
            if (this.connection && this.updateConnection(t9, n8), this.editor_selected && (i6 = this.canvas_x + -(this.pos_x - t9), s6 = this.canvas_y + -(this.pos_y - n8), this.dispatch("translate", { x: i6, y: s6 }), this.precanvas.style.transform = "translate(" + i6 + "px, " + s6 + "px) scale(" + this.zoom + ")"), this.drag) {
              e11.preventDefault();
              var i6 = (this.pos_x - t9) * this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom), s6 = (this.pos_y - n8) * this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom);
              this.pos_x = t9, this.pos_y = n8, this.ele_selected.style.top = this.ele_selected.offsetTop - s6 + "px", this.ele_selected.style.left = this.ele_selected.offsetLeft - i6 + "px", this.drawflow.drawflow[this.module].data[this.ele_selected.id.slice(5)].pos_x = this.ele_selected.offsetLeft - i6, this.drawflow.drawflow[this.module].data[this.ele_selected.id.slice(5)].pos_y = this.ele_selected.offsetTop - s6, this.updateConnectionNodes(this.ele_selected.id);
            }
            if (this.drag_point) {
              i6 = (this.pos_x - t9) * this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom), s6 = (this.pos_y - n8) * this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom);
              this.pos_x = t9, this.pos_y = n8;
              var o7 = this.pos_x * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)) - this.precanvas.getBoundingClientRect().x * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)), l3 = this.pos_y * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)) - this.precanvas.getBoundingClientRect().y * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom));
              this.ele_selected.setAttributeNS(null, "cx", o7), this.ele_selected.setAttributeNS(null, "cy", l3);
              const e12 = this.ele_selected.parentElement.classList[2].slice(9), c6 = this.ele_selected.parentElement.classList[1].slice(13), d3 = this.ele_selected.parentElement.classList[3], a3 = this.ele_selected.parentElement.classList[4];
              let r9 = Array.from(this.ele_selected.parentElement.children).indexOf(this.ele_selected) - 1;
              if (this.reroute_fix_curvature) {
                r9 -= this.ele_selected.parentElement.querySelectorAll(".main-path").length - 1, r9 < 0 && (r9 = 0);
              }
              const h5 = e12.slice(5), u3 = this.drawflow.drawflow[this.module].data[h5].outputs[d3].connections.findIndex(function(e13, t10) {
                return e13.node === c6 && e13.output === a3;
              });
              this.drawflow.drawflow[this.module].data[h5].outputs[d3].connections[u3].points[r9] = { pos_x: o7, pos_y: l3 };
              const p3 = this.ele_selected.parentElement.classList[2].slice(9);
              this.updateConnectionNodes(p3);
            }
            "touchmove" === e11.type && (this.mouse_x = t9, this.mouse_y = n8), this.dispatch("mouseMove", { x: t9, y: n8 });
          }
          dragEnd(e11) {
            if ("touchend" === e11.type) var t9 = this.mouse_x, n8 = this.mouse_y, i6 = document.elementFromPoint(t9, n8);
            else t9 = e11.clientX, n8 = e11.clientY, i6 = e11.target;
            if (this.drag && (this.pos_x_start == t9 && this.pos_y_start == n8 || this.dispatch("nodeMoved", this.ele_selected.id.slice(5))), this.drag_point && (this.ele_selected.classList.remove("selected"), this.pos_x_start == t9 && this.pos_y_start == n8 || this.dispatch("rerouteMoved", this.ele_selected.parentElement.classList[2].slice(14))), this.editor_selected && (this.canvas_x = this.canvas_x + -(this.pos_x - t9), this.canvas_y = this.canvas_y + -(this.pos_y - n8), this.editor_selected = false), true === this.connection) if ("input" === i6.classList[0] || this.force_first_input && (null != i6.closest(".drawflow_content_node") || "drawflow-node" === i6.classList[0])) {
              if (!this.force_first_input || null == i6.closest(".drawflow_content_node") && "drawflow-node" !== i6.classList[0]) s6 = i6.parentElement.parentElement.id, o7 = i6.classList[1];
              else {
                if (null != i6.closest(".drawflow_content_node")) var s6 = i6.closest(".drawflow_content_node").parentElement.id;
                else var s6 = i6.id;
                if (0 === Object.keys(this.getNodeFromId(s6.slice(5)).inputs).length) var o7 = false;
                else var o7 = "input_1";
              }
              var l3 = this.ele_selected.parentElement.parentElement.id, c6 = this.ele_selected.classList[1];
              if (l3 !== s6 && false !== o7) {
                if (0 === this.container.querySelectorAll(".connection.node_in_" + s6 + ".node_out_" + l3 + "." + c6 + "." + o7).length) {
                  this.connection_ele.classList.add("node_in_" + s6), this.connection_ele.classList.add("node_out_" + l3), this.connection_ele.classList.add(c6), this.connection_ele.classList.add(o7);
                  var d3 = s6.slice(5), a3 = l3.slice(5);
                  this.drawflow.drawflow[this.module].data[a3].outputs[c6].connections.push({ node: d3, output: o7 }), this.drawflow.drawflow[this.module].data[d3].inputs[o7].connections.push({ node: a3, input: c6 }), this.updateConnectionNodes("node-" + a3), this.updateConnectionNodes("node-" + d3), this.dispatch("connectionCreated", { output_id: a3, input_id: d3, output_class: c6, input_class: o7 });
                } else this.dispatch("connectionCancel", true), this.connection_ele.remove();
                this.connection_ele = null;
              } else this.dispatch("connectionCancel", true), this.connection_ele.remove(), this.connection_ele = null;
            } else this.dispatch("connectionCancel", true), this.connection_ele.remove(), this.connection_ele = null;
            this.drag = false, this.drag_point = false, this.connection = false, this.ele_selected = null, this.editor_selected = false, this.dispatch("mouseUp", e11);
          }
          contextmenu(e11) {
            if (this.dispatch("contextmenu", e11), e11.preventDefault(), "fixed" === this.editor_mode || "view" === this.editor_mode) return false;
            if (this.precanvas.getElementsByClassName("drawflow-delete").length && this.precanvas.getElementsByClassName("drawflow-delete")[0].remove(), this.node_selected || this.connection_selected) {
              var t9 = document.createElement("div");
              t9.classList.add("drawflow-delete"), t9.innerHTML = "x", this.node_selected && this.node_selected.appendChild(t9), this.connection_selected && this.connection_selected.parentElement.classList.length > 1 && (t9.style.top = e11.clientY * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)) - this.precanvas.getBoundingClientRect().y * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)) + "px", t9.style.left = e11.clientX * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)) - this.precanvas.getBoundingClientRect().x * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)) + "px", this.precanvas.appendChild(t9));
            }
          }
          contextmenuDel() {
            this.precanvas.getElementsByClassName("drawflow-delete").length && this.precanvas.getElementsByClassName("drawflow-delete")[0].remove();
          }
          key(e11) {
            if (this.dispatch("keydown", e11), "fixed" === this.editor_mode || "view" === this.editor_mode) return false;
            ("Delete" === e11.key || "Backspace" === e11.key && e11.metaKey) && (null != this.node_selected && "INPUT" !== this.first_click.tagName && "TEXTAREA" !== this.first_click.tagName && true !== this.first_click.hasAttribute("contenteditable") && this.removeNodeId(this.node_selected.id), null != this.connection_selected && this.removeConnection());
          }
          zoom_enter(e11, t9) {
            e11.ctrlKey && (e11.preventDefault(), e11.deltaY > 0 ? this.zoom_out() : this.zoom_in());
          }
          zoom_refresh() {
            this.dispatch("zoom", this.zoom), this.canvas_x = this.canvas_x / this.zoom_last_value * this.zoom, this.canvas_y = this.canvas_y / this.zoom_last_value * this.zoom, this.zoom_last_value = this.zoom, this.precanvas.style.transform = "translate(" + this.canvas_x + "px, " + this.canvas_y + "px) scale(" + this.zoom + ")";
          }
          zoom_in() {
            this.zoom < this.zoom_max && (this.zoom += this.zoom_value, this.zoom_refresh());
          }
          zoom_out() {
            this.zoom > this.zoom_min && (this.zoom -= this.zoom_value, this.zoom_refresh());
          }
          zoom_reset() {
            1 != this.zoom && (this.zoom = 1, this.zoom_refresh());
          }
          createCurvature(e11, t9, n8, i6, s6, o7) {
            var l3 = e11, c6 = t9, d3 = n8, a3 = i6, r9 = s6;
            switch (o7) {
              case "open":
                if (e11 >= n8) var h5 = l3 + Math.abs(d3 - l3) * r9, u3 = d3 - Math.abs(d3 - l3) * (-1 * r9);
                else h5 = l3 + Math.abs(d3 - l3) * r9, u3 = d3 - Math.abs(d3 - l3) * r9;
                return " M " + l3 + " " + c6 + " C " + h5 + " " + c6 + " " + u3 + " " + a3 + " " + d3 + "  " + a3;
              case "close":
                if (e11 >= n8) h5 = l3 + Math.abs(d3 - l3) * (-1 * r9), u3 = d3 - Math.abs(d3 - l3) * r9;
                else h5 = l3 + Math.abs(d3 - l3) * r9, u3 = d3 - Math.abs(d3 - l3) * r9;
                return " M " + l3 + " " + c6 + " C " + h5 + " " + c6 + " " + u3 + " " + a3 + " " + d3 + "  " + a3;
              case "other":
                if (e11 >= n8) h5 = l3 + Math.abs(d3 - l3) * (-1 * r9), u3 = d3 - Math.abs(d3 - l3) * (-1 * r9);
                else h5 = l3 + Math.abs(d3 - l3) * r9, u3 = d3 - Math.abs(d3 - l3) * r9;
                return " M " + l3 + " " + c6 + " C " + h5 + " " + c6 + " " + u3 + " " + a3 + " " + d3 + "  " + a3;
              default:
                return " M " + l3 + " " + c6 + " C " + (h5 = l3 + Math.abs(d3 - l3) * r9) + " " + c6 + " " + (u3 = d3 - Math.abs(d3 - l3) * r9) + " " + a3 + " " + d3 + "  " + a3;
            }
          }
          drawConnection(e11) {
            var t9 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            this.connection_ele = t9;
            var n8 = document.createElementNS("http://www.w3.org/2000/svg", "path");
            n8.classList.add("main-path"), n8.setAttributeNS(null, "d", ""), t9.classList.add("connection"), t9.appendChild(n8), this.precanvas.appendChild(t9);
            var i6 = e11.parentElement.parentElement.id.slice(5), s6 = e11.classList[1];
            this.dispatch("connectionStart", { output_id: i6, output_class: s6 });
          }
          updateConnection(e11, t9) {
            const n8 = this.precanvas, i6 = this.zoom;
            let s6 = n8.clientWidth / (n8.clientWidth * i6);
            s6 = s6 || 0;
            let o7 = n8.clientHeight / (n8.clientHeight * i6);
            o7 = o7 || 0;
            var l3 = this.connection_ele.children[0], c6 = this.ele_selected.offsetWidth / 2 + (this.ele_selected.getBoundingClientRect().x - n8.getBoundingClientRect().x) * s6, d3 = this.ele_selected.offsetHeight / 2 + (this.ele_selected.getBoundingClientRect().y - n8.getBoundingClientRect().y) * o7, a3 = e11 * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)) - this.precanvas.getBoundingClientRect().x * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)), r9 = t9 * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)) - this.precanvas.getBoundingClientRect().y * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)), h5 = this.curvature, u3 = this.createCurvature(c6, d3, a3, r9, h5, "openclose");
            l3.setAttributeNS(null, "d", u3);
          }
          addConnection(e11, t9, n8, i6) {
            var s6 = this.getModuleFromNodeId(e11);
            if (s6 === this.getModuleFromNodeId(t9)) {
              var o7 = this.getNodeFromId(e11), l3 = false;
              for (var c6 in o7.outputs[n8].connections) {
                var d3 = o7.outputs[n8].connections[c6];
                d3.node == t9 && d3.output == i6 && (l3 = true);
              }
              if (false === l3) {
                if (this.drawflow.drawflow[s6].data[e11].outputs[n8].connections.push({ node: t9.toString(), output: i6 }), this.drawflow.drawflow[s6].data[t9].inputs[i6].connections.push({ node: e11.toString(), input: n8 }), this.module === s6) {
                  var a3 = document.createElementNS("http://www.w3.org/2000/svg", "svg"), r9 = document.createElementNS("http://www.w3.org/2000/svg", "path");
                  r9.classList.add("main-path"), r9.setAttributeNS(null, "d", ""), a3.classList.add("connection"), a3.classList.add("node_in_node-" + t9), a3.classList.add("node_out_node-" + e11), a3.classList.add(n8), a3.classList.add(i6), a3.appendChild(r9), this.precanvas.appendChild(a3), this.updateConnectionNodes("node-" + e11), this.updateConnectionNodes("node-" + t9);
                }
                this.dispatch("connectionCreated", { output_id: e11, input_id: t9, output_class: n8, input_class: i6 });
              }
            }
          }
          updateConnectionNodes(e11) {
            const t9 = "node_in_" + e11, n8 = "node_out_" + e11;
            this.line_path;
            const i6 = this.container, s6 = this.precanvas, o7 = this.curvature, l3 = this.createCurvature, c6 = this.reroute_curvature, d3 = this.reroute_curvature_start_end, a3 = this.reroute_fix_curvature, r9 = this.reroute_width, h5 = this.zoom;
            let u3 = s6.clientWidth / (s6.clientWidth * h5);
            u3 = u3 || 0;
            let p3 = s6.clientHeight / (s6.clientHeight * h5);
            p3 = p3 || 0;
            const f5 = i6.querySelectorAll("." + n8);
            Object.keys(f5).map(function(t10, n9) {
              if (null === f5[t10].querySelector(".point")) {
                var m4 = i6.querySelector("#" + e11), g3 = f5[t10].classList[1].replace("node_in_", ""), _3 = i6.querySelector("#" + g3).querySelectorAll("." + f5[t10].classList[4])[0], w3 = _3.offsetWidth / 2 + (_3.getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3, v3 = _3.offsetHeight / 2 + (_3.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3, y3 = m4.querySelectorAll("." + f5[t10].classList[3])[0], C = y3.offsetWidth / 2 + (y3.getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3, x4 = y3.offsetHeight / 2 + (y3.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3;
                const n10 = l3(C, x4, w3, v3, o7, "openclose");
                f5[t10].children[0].setAttributeNS(null, "d", n10);
              } else {
                const n10 = f5[t10].querySelectorAll(".point");
                let o8 = "";
                const m5 = [];
                n10.forEach((t11, a4) => {
                  if (0 === a4 && n10.length - 1 == 0) {
                    var f6 = i6.querySelector("#" + e11), g4 = ((x5 = t11).getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3 + r9, _4 = (x5.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3 + r9, w4 = (L = f6.querySelectorAll("." + t11.parentElement.classList[3])[0]).offsetWidth / 2 + (L.getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3, v4 = L.offsetHeight / 2 + (L.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3, y4 = l3(w4, v4, g4, _4, d3, "open");
                    o8 += y4, m5.push(y4);
                    f6 = t11;
                    var C2 = t11.parentElement.classList[1].replace("node_in_", ""), x5 = (E3 = i6.querySelector("#" + C2)).querySelectorAll("." + t11.parentElement.classList[4])[0];
                    g4 = (R3 = E3.querySelectorAll("." + t11.parentElement.classList[4])[0]).offsetWidth / 2 + (R3.getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3, _4 = R3.offsetHeight / 2 + (R3.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3, w4 = (f6.getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3 + r9, v4 = (f6.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3 + r9, y4 = l3(w4, v4, g4, _4, d3, "close");
                    o8 += y4, m5.push(y4);
                  } else if (0 === a4) {
                    var L;
                    f6 = i6.querySelector("#" + e11), g4 = ((x5 = t11).getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3 + r9, _4 = (x5.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3 + r9, w4 = (L = f6.querySelectorAll("." + t11.parentElement.classList[3])[0]).offsetWidth / 2 + (L.getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3, v4 = L.offsetHeight / 2 + (L.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3, y4 = l3(w4, v4, g4, _4, d3, "open");
                    o8 += y4, m5.push(y4);
                    f6 = t11, g4 = ((x5 = n10[a4 + 1]).getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3 + r9, _4 = (x5.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3 + r9, w4 = (f6.getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3 + r9, v4 = (f6.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3 + r9, y4 = l3(w4, v4, g4, _4, c6, "other");
                    o8 += y4, m5.push(y4);
                  } else if (a4 === n10.length - 1) {
                    var E3, R3;
                    f6 = t11, C2 = t11.parentElement.classList[1].replace("node_in_", ""), x5 = (E3 = i6.querySelector("#" + C2)).querySelectorAll("." + t11.parentElement.classList[4])[0], g4 = (R3 = E3.querySelectorAll("." + t11.parentElement.classList[4])[0]).offsetWidth / 2 + (R3.getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3, _4 = R3.offsetHeight / 2 + (R3.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3, w4 = (f6.getBoundingClientRect().x - s6.getBoundingClientRect().x) * (s6.clientWidth / (s6.clientWidth * h5)) + r9, v4 = (f6.getBoundingClientRect().y - s6.getBoundingClientRect().y) * (s6.clientHeight / (s6.clientHeight * h5)) + r9, y4 = l3(w4, v4, g4, _4, d3, "close");
                    o8 += y4, m5.push(y4);
                  } else {
                    f6 = t11, g4 = ((x5 = n10[a4 + 1]).getBoundingClientRect().x - s6.getBoundingClientRect().x) * (s6.clientWidth / (s6.clientWidth * h5)) + r9, _4 = (x5.getBoundingClientRect().y - s6.getBoundingClientRect().y) * (s6.clientHeight / (s6.clientHeight * h5)) + r9, w4 = (f6.getBoundingClientRect().x - s6.getBoundingClientRect().x) * (s6.clientWidth / (s6.clientWidth * h5)) + r9, v4 = (f6.getBoundingClientRect().y - s6.getBoundingClientRect().y) * (s6.clientHeight / (s6.clientHeight * h5)) + r9, y4 = l3(w4, v4, g4, _4, c6, "other");
                    o8 += y4, m5.push(y4);
                  }
                }), a3 ? m5.forEach((e12, n11) => {
                  f5[t10].children[n11].setAttributeNS(null, "d", e12);
                }) : f5[t10].children[0].setAttributeNS(null, "d", o8);
              }
            });
            const m3 = i6.querySelectorAll("." + t9);
            Object.keys(m3).map(function(t10, n9) {
              if (null === m3[t10].querySelector(".point")) {
                var h6 = i6.querySelector("#" + e11), f6 = m3[t10].classList[2].replace("node_out_", ""), g3 = i6.querySelector("#" + f6).querySelectorAll("." + m3[t10].classList[3])[0], _3 = g3.offsetWidth / 2 + (g3.getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3, w3 = g3.offsetHeight / 2 + (g3.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3, v3 = (h6 = h6.querySelectorAll("." + m3[t10].classList[4])[0]).offsetWidth / 2 + (h6.getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3, y3 = h6.offsetHeight / 2 + (h6.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3;
                const n10 = l3(_3, w3, v3, y3, o7, "openclose");
                m3[t10].children[0].setAttributeNS(null, "d", n10);
              } else {
                const n10 = m3[t10].querySelectorAll(".point");
                let o8 = "";
                const h7 = [];
                n10.forEach((t11, a4) => {
                  if (0 === a4 && n10.length - 1 == 0) {
                    var f7 = i6.querySelector("#" + e11), m4 = ((C = t11).getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3 + r9, g4 = (C.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3 + r9, _4 = (E3 = f7.querySelectorAll("." + t11.parentElement.classList[4])[0]).offsetWidth / 2 + (E3.getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3, w4 = E3.offsetHeight / 2 + (E3.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3, v4 = l3(m4, g4, _4, w4, d3, "close");
                    o8 += v4, h7.push(v4);
                    f7 = t11;
                    var y4 = t11.parentElement.classList[2].replace("node_out_", ""), C = (L = i6.querySelector("#" + y4)).querySelectorAll("." + t11.parentElement.classList[3])[0];
                    m4 = (x4 = L.querySelectorAll("." + t11.parentElement.classList[3])[0]).offsetWidth / 2 + (x4.getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3, g4 = x4.offsetHeight / 2 + (x4.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3, _4 = (f7.getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3 + r9, w4 = (f7.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3 + r9, v4 = l3(m4, g4, _4, w4, d3, "open");
                    o8 += v4, h7.push(v4);
                  } else if (0 === a4) {
                    var x4;
                    f7 = t11, y4 = t11.parentElement.classList[2].replace("node_out_", ""), C = (L = i6.querySelector("#" + y4)).querySelectorAll("." + t11.parentElement.classList[3])[0], m4 = (x4 = L.querySelectorAll("." + t11.parentElement.classList[3])[0]).offsetWidth / 2 + (x4.getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3, g4 = x4.offsetHeight / 2 + (x4.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3, _4 = (f7.getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3 + r9, w4 = (f7.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3 + r9, v4 = l3(m4, g4, _4, w4, d3, "open");
                    o8 += v4, h7.push(v4);
                    f7 = t11, _4 = ((C = n10[a4 + 1]).getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3 + r9, w4 = (C.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3 + r9, m4 = (f7.getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3 + r9, g4 = (f7.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3 + r9, v4 = l3(m4, g4, _4, w4, c6, "other");
                    o8 += v4, h7.push(v4);
                  } else if (a4 === n10.length - 1) {
                    var L, E3;
                    f7 = t11, y4 = t11.parentElement.classList[1].replace("node_in_", ""), C = (L = i6.querySelector("#" + y4)).querySelectorAll("." + t11.parentElement.classList[4])[0], _4 = (E3 = L.querySelectorAll("." + t11.parentElement.classList[4])[0]).offsetWidth / 2 + (E3.getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3, w4 = E3.offsetHeight / 2 + (E3.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3, m4 = (f7.getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3 + r9, g4 = (f7.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3 + r9, v4 = l3(m4, g4, _4, w4, d3, "close");
                    o8 += v4, h7.push(v4);
                  } else {
                    f7 = t11, _4 = ((C = n10[a4 + 1]).getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3 + r9, w4 = (C.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3 + r9, m4 = (f7.getBoundingClientRect().x - s6.getBoundingClientRect().x) * u3 + r9, g4 = (f7.getBoundingClientRect().y - s6.getBoundingClientRect().y) * p3 + r9, v4 = l3(m4, g4, _4, w4, c6, "other");
                    o8 += v4, h7.push(v4);
                  }
                }), a3 ? h7.forEach((e12, n11) => {
                  m3[t10].children[n11].setAttributeNS(null, "d", e12);
                }) : m3[t10].children[0].setAttributeNS(null, "d", o8);
              }
            });
          }
          dblclick(e11) {
            null != this.connection_selected && this.reroute && this.createReroutePoint(this.connection_selected), "point" === e11.target.classList[0] && this.removeReroutePoint(e11.target);
          }
          createReroutePoint(e11) {
            this.connection_selected.classList.remove("selected");
            const t9 = this.connection_selected.parentElement.classList[2].slice(9), n8 = this.connection_selected.parentElement.classList[1].slice(13), i6 = this.connection_selected.parentElement.classList[3], s6 = this.connection_selected.parentElement.classList[4];
            this.connection_selected = null;
            const o7 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            o7.classList.add("point");
            var l3 = this.pos_x * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)) - this.precanvas.getBoundingClientRect().x * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)), c6 = this.pos_y * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)) - this.precanvas.getBoundingClientRect().y * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom));
            o7.setAttributeNS(null, "cx", l3), o7.setAttributeNS(null, "cy", c6), o7.setAttributeNS(null, "r", this.reroute_width);
            let d3 = 0;
            if (this.reroute_fix_curvature) {
              const t10 = e11.parentElement.querySelectorAll(".main-path").length;
              var a3 = document.createElementNS("http://www.w3.org/2000/svg", "path");
              if (a3.classList.add("main-path"), a3.setAttributeNS(null, "d", ""), e11.parentElement.insertBefore(a3, e11.parentElement.children[t10]), 1 === t10) e11.parentElement.appendChild(o7);
              else {
                const n9 = Array.from(e11.parentElement.children).indexOf(e11);
                d3 = n9, e11.parentElement.insertBefore(o7, e11.parentElement.children[n9 + t10 + 1]);
              }
            } else e11.parentElement.appendChild(o7);
            const r9 = t9.slice(5), h5 = this.drawflow.drawflow[this.module].data[r9].outputs[i6].connections.findIndex(function(e12, t10) {
              return e12.node === n8 && e12.output === s6;
            });
            void 0 === this.drawflow.drawflow[this.module].data[r9].outputs[i6].connections[h5].points && (this.drawflow.drawflow[this.module].data[r9].outputs[i6].connections[h5].points = []), this.reroute_fix_curvature ? (d3 > 0 || this.drawflow.drawflow[this.module].data[r9].outputs[i6].connections[h5].points !== [] ? this.drawflow.drawflow[this.module].data[r9].outputs[i6].connections[h5].points.splice(d3, 0, { pos_x: l3, pos_y: c6 }) : this.drawflow.drawflow[this.module].data[r9].outputs[i6].connections[h5].points.push({ pos_x: l3, pos_y: c6 }), e11.parentElement.querySelectorAll(".main-path").forEach((e12, t10) => {
              e12.classList.remove("selected");
            })) : this.drawflow.drawflow[this.module].data[r9].outputs[i6].connections[h5].points.push({ pos_x: l3, pos_y: c6 }), this.dispatch("addReroute", r9), this.updateConnectionNodes(t9);
          }
          removeReroutePoint(e11) {
            const t9 = e11.parentElement.classList[2].slice(9), n8 = e11.parentElement.classList[1].slice(13), i6 = e11.parentElement.classList[3], s6 = e11.parentElement.classList[4];
            let o7 = Array.from(e11.parentElement.children).indexOf(e11);
            const l3 = t9.slice(5), c6 = this.drawflow.drawflow[this.module].data[l3].outputs[i6].connections.findIndex(function(e12, t10) {
              return e12.node === n8 && e12.output === s6;
            });
            if (this.reroute_fix_curvature) {
              const t10 = e11.parentElement.querySelectorAll(".main-path").length;
              e11.parentElement.children[t10 - 1].remove(), o7 -= t10, o7 < 0 && (o7 = 0);
            } else o7--;
            this.drawflow.drawflow[this.module].data[l3].outputs[i6].connections[c6].points.splice(o7, 1), e11.remove(), this.dispatch("removeReroute", l3), this.updateConnectionNodes(t9);
          }
          registerNode(e11, t9, n8 = null, i6 = null) {
            this.noderegister[e11] = { html: t9, props: n8, options: i6 };
          }
          getNodeFromId(e11) {
            var t9 = this.getModuleFromNodeId(e11);
            return JSON.parse(JSON.stringify(this.drawflow.drawflow[t9].data[e11]));
          }
          getNodesFromName(e11) {
            var t9 = [];
            const n8 = this.drawflow.drawflow;
            return Object.keys(n8).map(function(i6, s6) {
              for (var o7 in n8[i6].data) n8[i6].data[o7].name == e11 && t9.push(n8[i6].data[o7].id);
            }), t9;
          }
          addNode(e11, t9, n8, i6, s6, o7, l3, c6, d3 = false) {
            if (this.useuuid) var a3 = this.getUuid();
            else a3 = this.nodeId;
            const r9 = document.createElement("div");
            r9.classList.add("parent-node");
            const h5 = document.createElement("div");
            h5.innerHTML = "", h5.setAttribute("id", "node-" + a3), h5.classList.add("drawflow-node"), "" != o7 && h5.classList.add(...o7.split(" "));
            const u3 = document.createElement("div");
            u3.classList.add("inputs");
            const p3 = document.createElement("div");
            p3.classList.add("outputs");
            const f5 = {};
            for (var m3 = 0; m3 < t9; m3++) {
              const e12 = document.createElement("div");
              e12.classList.add("input"), e12.classList.add("input_" + (m3 + 1)), f5["input_" + (m3 + 1)] = { connections: [] }, u3.appendChild(e12);
            }
            const g3 = {};
            for (m3 = 0; m3 < n8; m3++) {
              const e12 = document.createElement("div");
              e12.classList.add("output"), e12.classList.add("output_" + (m3 + 1)), g3["output_" + (m3 + 1)] = { connections: [] }, p3.appendChild(e12);
            }
            const _3 = document.createElement("div");
            if (_3.classList.add("drawflow_content_node"), false === d3) _3.innerHTML = c6;
            else if (true === d3) _3.appendChild(this.noderegister[c6].html.cloneNode(true));
            else if (3 === parseInt(this.render.version)) {
              let e12 = this.render.h(this.noderegister[c6].html, this.noderegister[c6].props, this.noderegister[c6].options);
              e12.appContext = this.parent, this.render.render(e12, _3);
            } else {
              let e12 = new this.render({ parent: this.parent, render: (e13) => e13(this.noderegister[c6].html, { props: this.noderegister[c6].props }), ...this.noderegister[c6].options }).$mount();
              _3.appendChild(e12.$el);
            }
            Object.entries(l3).forEach(function(e12, t10) {
              if ("object" == typeof e12[1]) !function e13(t11, n10, i8) {
                if (null === t11) t11 = l3[n10];
                else t11 = t11[n10];
                null !== t11 && Object.entries(t11).forEach(function(n11, s7) {
                  if ("object" == typeof n11[1]) e13(t11, n11[0], i8 + "-" + n11[0]);
                  else for (var o8 = _3.querySelectorAll("[df-" + i8 + "-" + n11[0] + "]"), l4 = 0; l4 < o8.length; l4++) o8[l4].value = n11[1], o8[l4].isContentEditable && (o8[l4].innerText = n11[1]);
                });
              }(null, e12[0], e12[0]);
              else for (var n9 = _3.querySelectorAll("[df-" + e12[0] + "]"), i7 = 0; i7 < n9.length; i7++) n9[i7].value = e12[1], n9[i7].isContentEditable && (n9[i7].innerText = e12[1]);
            }), h5.appendChild(u3), h5.appendChild(_3), h5.appendChild(p3), h5.style.top = s6 + "px", h5.style.left = i6 + "px", r9.appendChild(h5), this.precanvas.appendChild(r9);
            var w3 = { id: a3, name: e11, data: l3, class: o7, html: c6, typenode: d3, inputs: f5, outputs: g3, pos_x: i6, pos_y: s6 };
            return this.drawflow.drawflow[this.module].data[a3] = w3, this.dispatch("nodeCreated", a3), this.useuuid || this.nodeId++, a3;
          }
          addNodeImport(e11, t9) {
            const n8 = document.createElement("div");
            n8.classList.add("parent-node");
            const i6 = document.createElement("div");
            i6.innerHTML = "", i6.setAttribute("id", "node-" + e11.id), i6.classList.add("drawflow-node"), "" != e11.class && i6.classList.add(...e11.class.split(" "));
            const s6 = document.createElement("div");
            s6.classList.add("inputs");
            const o7 = document.createElement("div");
            o7.classList.add("outputs"), Object.keys(e11.inputs).map(function(n9, i7) {
              const o8 = document.createElement("div");
              o8.classList.add("input"), o8.classList.add(n9), s6.appendChild(o8), Object.keys(e11.inputs[n9].connections).map(function(i8, s7) {
                var o9 = document.createElementNS("http://www.w3.org/2000/svg", "svg"), l4 = document.createElementNS("http://www.w3.org/2000/svg", "path");
                l4.classList.add("main-path"), l4.setAttributeNS(null, "d", ""), o9.classList.add("connection"), o9.classList.add("node_in_node-" + e11.id), o9.classList.add("node_out_node-" + e11.inputs[n9].connections[i8].node), o9.classList.add(e11.inputs[n9].connections[i8].input), o9.classList.add(n9), o9.appendChild(l4), t9.appendChild(o9);
              });
            });
            for (var l3 = 0; l3 < Object.keys(e11.outputs).length; l3++) {
              const e12 = document.createElement("div");
              e12.classList.add("output"), e12.classList.add("output_" + (l3 + 1)), o7.appendChild(e12);
            }
            const c6 = document.createElement("div");
            if (c6.classList.add("drawflow_content_node"), false === e11.typenode) c6.innerHTML = e11.html;
            else if (true === e11.typenode) c6.appendChild(this.noderegister[e11.html].html.cloneNode(true));
            else if (3 === parseInt(this.render.version)) {
              let t10 = this.render.h(this.noderegister[e11.html].html, this.noderegister[e11.html].props, this.noderegister[e11.html].options);
              t10.appContext = this.parent, this.render.render(t10, c6);
            } else {
              let t10 = new this.render({ parent: this.parent, render: (t11) => t11(this.noderegister[e11.html].html, { props: this.noderegister[e11.html].props }), ...this.noderegister[e11.html].options }).$mount();
              c6.appendChild(t10.$el);
            }
            Object.entries(e11.data).forEach(function(t10, n9) {
              if ("object" == typeof t10[1]) !function t11(n10, i8, s8) {
                if (null === n10) n10 = e11.data[i8];
                else n10 = n10[i8];
                null !== n10 && Object.entries(n10).forEach(function(e12, i9) {
                  if ("object" == typeof e12[1]) t11(n10, e12[0], s8 + "-" + e12[0]);
                  else for (var o8 = c6.querySelectorAll("[df-" + s8 + "-" + e12[0] + "]"), l4 = 0; l4 < o8.length; l4++) o8[l4].value = e12[1], o8[l4].isContentEditable && (o8[l4].innerText = e12[1]);
                });
              }(null, t10[0], t10[0]);
              else for (var i7 = c6.querySelectorAll("[df-" + t10[0] + "]"), s7 = 0; s7 < i7.length; s7++) i7[s7].value = t10[1], i7[s7].isContentEditable && (i7[s7].innerText = t10[1]);
            }), i6.appendChild(s6), i6.appendChild(c6), i6.appendChild(o7), i6.style.top = e11.pos_y + "px", i6.style.left = e11.pos_x + "px", n8.appendChild(i6), this.precanvas.appendChild(n8);
          }
          addRerouteImport(e11) {
            const t9 = this.reroute_width, n8 = this.reroute_fix_curvature, i6 = this.container;
            Object.keys(e11.outputs).map(function(s6, o7) {
              Object.keys(e11.outputs[s6].connections).map(function(o8, l3) {
                const c6 = e11.outputs[s6].connections[o8].points;
                void 0 !== c6 && c6.forEach((l4, d3) => {
                  const a3 = e11.outputs[s6].connections[o8].node, r9 = e11.outputs[s6].connections[o8].output, h5 = i6.querySelector(".connection.node_in_node-" + a3 + ".node_out_node-" + e11.id + "." + s6 + "." + r9);
                  if (n8 && 0 === d3) for (var u3 = 0; u3 < c6.length; u3++) {
                    var p3 = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    p3.classList.add("main-path"), p3.setAttributeNS(null, "d", ""), h5.appendChild(p3);
                  }
                  const f5 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                  f5.classList.add("point");
                  var m3 = l4.pos_x, g3 = l4.pos_y;
                  f5.setAttributeNS(null, "cx", m3), f5.setAttributeNS(null, "cy", g3), f5.setAttributeNS(null, "r", t9), h5.appendChild(f5);
                });
              });
            });
          }
          updateNodeValue(e11) {
            for (var t9 = e11.target.attributes, n8 = 0; n8 < t9.length; n8++) if (t9[n8].nodeName.startsWith("df-")) {
              for (var i6 = t9[n8].nodeName.slice(3).split("-"), s6 = this.drawflow.drawflow[this.module].data[e11.target.closest(".drawflow_content_node").parentElement.id.slice(5)].data, o7 = 0; o7 < i6.length - 1; o7 += 1) null == s6[i6[o7]] && (s6[i6[o7]] = {}), s6 = s6[i6[o7]];
              s6[i6[i6.length - 1]] = e11.target.value, e11.target.isContentEditable && (s6[i6[i6.length - 1]] = e11.target.innerText), this.dispatch("nodeDataChanged", e11.target.closest(".drawflow_content_node").parentElement.id.slice(5));
            }
          }
          updateNodeDataFromId(e11, t9) {
            var n8 = this.getModuleFromNodeId(e11);
            if (this.drawflow.drawflow[n8].data[e11].data = t9, this.module === n8) {
              const n9 = this.container.querySelector("#node-" + e11);
              Object.entries(t9).forEach(function(e12, i6) {
                if ("object" == typeof e12[1]) !function e13(i7, s7, o8) {
                  if (null === i7) i7 = t9[s7];
                  else i7 = i7[s7];
                  null !== i7 && Object.entries(i7).forEach(function(t10, s8) {
                    if ("object" == typeof t10[1]) e13(i7, t10[0], o8 + "-" + t10[0]);
                    else for (var l3 = n9.querySelectorAll("[df-" + o8 + "-" + t10[0] + "]"), c6 = 0; c6 < l3.length; c6++) l3[c6].value = t10[1], l3[c6].isContentEditable && (l3[c6].innerText = t10[1]);
                  });
                }(null, e12[0], e12[0]);
                else for (var s6 = n9.querySelectorAll("[df-" + e12[0] + "]"), o7 = 0; o7 < s6.length; o7++) s6[o7].value = e12[1], s6[o7].isContentEditable && (s6[o7].innerText = e12[1]);
              });
            }
          }
          addNodeInput(e11) {
            var t9 = this.getModuleFromNodeId(e11);
            const n8 = this.getNodeFromId(e11), i6 = Object.keys(n8.inputs).length;
            if (this.module === t9) {
              const t10 = document.createElement("div");
              t10.classList.add("input"), t10.classList.add("input_" + (i6 + 1)), this.container.querySelector("#node-" + e11 + " .inputs").appendChild(t10), this.updateConnectionNodes("node-" + e11);
            }
            this.drawflow.drawflow[t9].data[e11].inputs["input_" + (i6 + 1)] = { connections: [] };
          }
          addNodeOutput(e11) {
            var t9 = this.getModuleFromNodeId(e11);
            const n8 = this.getNodeFromId(e11), i6 = Object.keys(n8.outputs).length;
            if (this.module === t9) {
              const t10 = document.createElement("div");
              t10.classList.add("output"), t10.classList.add("output_" + (i6 + 1)), this.container.querySelector("#node-" + e11 + " .outputs").appendChild(t10), this.updateConnectionNodes("node-" + e11);
            }
            this.drawflow.drawflow[t9].data[e11].outputs["output_" + (i6 + 1)] = { connections: [] };
          }
          removeNodeInput(e11, t9) {
            var n8 = this.getModuleFromNodeId(e11);
            const i6 = this.getNodeFromId(e11);
            this.module === n8 && this.container.querySelector("#node-" + e11 + " .inputs .input." + t9).remove();
            const s6 = [];
            Object.keys(i6.inputs[t9].connections).map(function(n9, o8) {
              const l4 = i6.inputs[t9].connections[o8].node, c7 = i6.inputs[t9].connections[o8].input;
              s6.push({ id_output: l4, id: e11, output_class: c7, input_class: t9 });
            }), s6.forEach((e12, t10) => {
              this.removeSingleConnection(e12.id_output, e12.id, e12.output_class, e12.input_class);
            }), delete this.drawflow.drawflow[n8].data[e11].inputs[t9];
            const o7 = [], l3 = this.drawflow.drawflow[n8].data[e11].inputs;
            Object.keys(l3).map(function(e12, t10) {
              o7.push(l3[e12]);
            }), this.drawflow.drawflow[n8].data[e11].inputs = {};
            const c6 = t9.slice(6);
            let d3 = [];
            if (o7.forEach((t10, i7) => {
              t10.connections.forEach((e12, t11) => {
                d3.push(e12);
              }), this.drawflow.drawflow[n8].data[e11].inputs["input_" + (i7 + 1)] = t10;
            }), d3 = new Set(d3.map((e12) => JSON.stringify(e12))), d3 = Array.from(d3).map((e12) => JSON.parse(e12)), this.module === n8) {
              this.container.querySelectorAll("#node-" + e11 + " .inputs .input").forEach((e12, t10) => {
                const n9 = e12.classList[1].slice(6);
                parseInt(c6) < parseInt(n9) && (e12.classList.remove("input_" + n9), e12.classList.add("input_" + (n9 - 1)));
              });
            }
            d3.forEach((t10, i7) => {
              this.drawflow.drawflow[n8].data[t10.node].outputs[t10.input].connections.forEach((i8, s7) => {
                if (i8.node == e11) {
                  const o8 = i8.output.slice(6);
                  if (parseInt(c6) < parseInt(o8)) {
                    if (this.module === n8) {
                      const n9 = this.container.querySelector(".connection.node_in_node-" + e11 + ".node_out_node-" + t10.node + "." + t10.input + ".input_" + o8);
                      n9.classList.remove("input_" + o8), n9.classList.add("input_" + (o8 - 1));
                    }
                    i8.points ? this.drawflow.drawflow[n8].data[t10.node].outputs[t10.input].connections[s7] = { node: i8.node, output: "input_" + (o8 - 1), points: i8.points } : this.drawflow.drawflow[n8].data[t10.node].outputs[t10.input].connections[s7] = { node: i8.node, output: "input_" + (o8 - 1) };
                  }
                }
              });
            }), this.updateConnectionNodes("node-" + e11);
          }
          removeNodeOutput(e11, t9) {
            var n8 = this.getModuleFromNodeId(e11);
            const i6 = this.getNodeFromId(e11);
            this.module === n8 && this.container.querySelector("#node-" + e11 + " .outputs .output." + t9).remove();
            const s6 = [];
            Object.keys(i6.outputs[t9].connections).map(function(n9, o8) {
              const l4 = i6.outputs[t9].connections[o8].node, c7 = i6.outputs[t9].connections[o8].output;
              s6.push({ id: e11, id_input: l4, output_class: t9, input_class: c7 });
            }), s6.forEach((e12, t10) => {
              this.removeSingleConnection(e12.id, e12.id_input, e12.output_class, e12.input_class);
            }), delete this.drawflow.drawflow[n8].data[e11].outputs[t9];
            const o7 = [], l3 = this.drawflow.drawflow[n8].data[e11].outputs;
            Object.keys(l3).map(function(e12, t10) {
              o7.push(l3[e12]);
            }), this.drawflow.drawflow[n8].data[e11].outputs = {};
            const c6 = t9.slice(7);
            let d3 = [];
            if (o7.forEach((t10, i7) => {
              t10.connections.forEach((e12, t11) => {
                d3.push({ node: e12.node, output: e12.output });
              }), this.drawflow.drawflow[n8].data[e11].outputs["output_" + (i7 + 1)] = t10;
            }), d3 = new Set(d3.map((e12) => JSON.stringify(e12))), d3 = Array.from(d3).map((e12) => JSON.parse(e12)), this.module === n8) {
              this.container.querySelectorAll("#node-" + e11 + " .outputs .output").forEach((e12, t10) => {
                const n9 = e12.classList[1].slice(7);
                parseInt(c6) < parseInt(n9) && (e12.classList.remove("output_" + n9), e12.classList.add("output_" + (n9 - 1)));
              });
            }
            d3.forEach((t10, i7) => {
              this.drawflow.drawflow[n8].data[t10.node].inputs[t10.output].connections.forEach((i8, s7) => {
                if (i8.node == e11) {
                  const o8 = i8.input.slice(7);
                  if (parseInt(c6) < parseInt(o8)) {
                    if (this.module === n8) {
                      const n9 = this.container.querySelector(".connection.node_in_node-" + t10.node + ".node_out_node-" + e11 + ".output_" + o8 + "." + t10.output);
                      n9.classList.remove("output_" + o8), n9.classList.remove(t10.output), n9.classList.add("output_" + (o8 - 1)), n9.classList.add(t10.output);
                    }
                    i8.points ? this.drawflow.drawflow[n8].data[t10.node].inputs[t10.output].connections[s7] = { node: i8.node, input: "output_" + (o8 - 1), points: i8.points } : this.drawflow.drawflow[n8].data[t10.node].inputs[t10.output].connections[s7] = { node: i8.node, input: "output_" + (o8 - 1) };
                  }
                }
              });
            }), this.updateConnectionNodes("node-" + e11);
          }
          removeNodeId(e11) {
            this.removeConnectionNodeId(e11);
            var t9 = this.getModuleFromNodeId(e11.slice(5));
            this.module === t9 && this.container.querySelector("#" + e11).remove(), delete this.drawflow.drawflow[t9].data[e11.slice(5)], this.dispatch("nodeRemoved", e11.slice(5));
          }
          removeConnection() {
            if (null != this.connection_selected) {
              var e11 = this.connection_selected.parentElement.classList;
              this.connection_selected.parentElement.remove();
              var t9 = this.drawflow.drawflow[this.module].data[e11[2].slice(14)].outputs[e11[3]].connections.findIndex(function(t10, n9) {
                return t10.node === e11[1].slice(13) && t10.output === e11[4];
              });
              this.drawflow.drawflow[this.module].data[e11[2].slice(14)].outputs[e11[3]].connections.splice(t9, 1);
              var n8 = this.drawflow.drawflow[this.module].data[e11[1].slice(13)].inputs[e11[4]].connections.findIndex(function(t10, n9) {
                return t10.node === e11[2].slice(14) && t10.input === e11[3];
              });
              this.drawflow.drawflow[this.module].data[e11[1].slice(13)].inputs[e11[4]].connections.splice(n8, 1), this.dispatch("connectionRemoved", { output_id: e11[2].slice(14), input_id: e11[1].slice(13), output_class: e11[3], input_class: e11[4] }), this.connection_selected = null;
            }
          }
          removeSingleConnection(e11, t9, n8, i6) {
            var s6 = this.getModuleFromNodeId(e11);
            if (s6 === this.getModuleFromNodeId(t9)) {
              if (this.drawflow.drawflow[s6].data[e11].outputs[n8].connections.findIndex(function(e12, n9) {
                return e12.node == t9 && e12.output === i6;
              }) > -1) {
                this.module === s6 && this.container.querySelector(".connection.node_in_node-" + t9 + ".node_out_node-" + e11 + "." + n8 + "." + i6).remove();
                var o7 = this.drawflow.drawflow[s6].data[e11].outputs[n8].connections.findIndex(function(e12, n9) {
                  return e12.node == t9 && e12.output === i6;
                });
                this.drawflow.drawflow[s6].data[e11].outputs[n8].connections.splice(o7, 1);
                var l3 = this.drawflow.drawflow[s6].data[t9].inputs[i6].connections.findIndex(function(t10, i7) {
                  return t10.node == e11 && t10.input === n8;
                });
                return this.drawflow.drawflow[s6].data[t9].inputs[i6].connections.splice(l3, 1), this.dispatch("connectionRemoved", { output_id: e11, input_id: t9, output_class: n8, input_class: i6 }), true;
              }
              return false;
            }
            return false;
          }
          removeConnectionNodeId(e11) {
            const t9 = "node_in_" + e11, n8 = "node_out_" + e11, i6 = this.container.querySelectorAll("." + n8);
            for (var s6 = i6.length - 1; s6 >= 0; s6--) {
              var o7 = i6[s6].classList, l3 = this.drawflow.drawflow[this.module].data[o7[1].slice(13)].inputs[o7[4]].connections.findIndex(function(e12, t10) {
                return e12.node === o7[2].slice(14) && e12.input === o7[3];
              });
              this.drawflow.drawflow[this.module].data[o7[1].slice(13)].inputs[o7[4]].connections.splice(l3, 1);
              var c6 = this.drawflow.drawflow[this.module].data[o7[2].slice(14)].outputs[o7[3]].connections.findIndex(function(e12, t10) {
                return e12.node === o7[1].slice(13) && e12.output === o7[4];
              });
              this.drawflow.drawflow[this.module].data[o7[2].slice(14)].outputs[o7[3]].connections.splice(c6, 1), i6[s6].remove(), this.dispatch("connectionRemoved", { output_id: o7[2].slice(14), input_id: o7[1].slice(13), output_class: o7[3], input_class: o7[4] });
            }
            const d3 = this.container.querySelectorAll("." + t9);
            for (s6 = d3.length - 1; s6 >= 0; s6--) {
              o7 = d3[s6].classList, c6 = this.drawflow.drawflow[this.module].data[o7[2].slice(14)].outputs[o7[3]].connections.findIndex(function(e12, t10) {
                return e12.node === o7[1].slice(13) && e12.output === o7[4];
              });
              this.drawflow.drawflow[this.module].data[o7[2].slice(14)].outputs[o7[3]].connections.splice(c6, 1);
              l3 = this.drawflow.drawflow[this.module].data[o7[1].slice(13)].inputs[o7[4]].connections.findIndex(function(e12, t10) {
                return e12.node === o7[2].slice(14) && e12.input === o7[3];
              });
              this.drawflow.drawflow[this.module].data[o7[1].slice(13)].inputs[o7[4]].connections.splice(l3, 1), d3[s6].remove(), this.dispatch("connectionRemoved", { output_id: o7[2].slice(14), input_id: o7[1].slice(13), output_class: o7[3], input_class: o7[4] });
            }
          }
          getModuleFromNodeId(e11) {
            var t9;
            const n8 = this.drawflow.drawflow;
            return Object.keys(n8).map(function(i6, s6) {
              Object.keys(n8[i6].data).map(function(n9, s7) {
                n9 == e11 && (t9 = i6);
              });
            }), t9;
          }
          addModule(e11) {
            this.drawflow.drawflow[e11] = { data: {} }, this.dispatch("moduleCreated", e11);
          }
          changeModule(e11) {
            this.dispatch("moduleChanged", e11), this.module = e11, this.precanvas.innerHTML = "", this.canvas_x = 0, this.canvas_y = 0, this.pos_x = 0, this.pos_y = 0, this.mouse_x = 0, this.mouse_y = 0, this.zoom = 1, this.zoom_last_value = 1, this.precanvas.style.transform = "", this.import(this.drawflow, false);
          }
          removeModule(e11) {
            this.module === e11 && this.changeModule("Home"), delete this.drawflow.drawflow[e11], this.dispatch("moduleRemoved", e11);
          }
          clearModuleSelected() {
            this.precanvas.innerHTML = "", this.drawflow.drawflow[this.module] = { data: {} };
          }
          clear() {
            this.precanvas.innerHTML = "", this.drawflow = { drawflow: { Home: { data: {} } } };
          }
          export() {
            const e11 = JSON.parse(JSON.stringify(this.drawflow));
            return this.dispatch("export", e11), e11;
          }
          import(e11, t9 = true) {
            this.clear(), this.drawflow = JSON.parse(JSON.stringify(e11)), this.load(), t9 && this.dispatch("import", "import");
          }
          on(e11, t9) {
            return "function" != typeof t9 ? (console.error("The listener callback must be a function, the given type is " + typeof t9), false) : "string" != typeof e11 ? (console.error("The event name must be a string, the given type is " + typeof e11), false) : (void 0 === this.events[e11] && (this.events[e11] = { listeners: [] }), void this.events[e11].listeners.push(t9));
          }
          removeListener(e11, t9) {
            if (!this.events[e11]) return false;
            const n8 = this.events[e11].listeners, i6 = n8.indexOf(t9);
            i6 > -1 && n8.splice(i6, 1);
          }
          dispatch(e11, t9) {
            if (void 0 === this.events[e11]) return false;
            this.events[e11].listeners.forEach((e12) => {
              e12(t9);
            });
          }
          getUuid() {
            for (var e11 = [], t9 = 0; t9 < 36; t9++) e11[t9] = "0123456789abcdef".substr(Math.floor(16 * Math.random()), 1);
            return e11[14] = "4", e11[19] = "0123456789abcdef".substr(3 & e11[19] | 8, 1), e11[8] = e11[13] = e11[18] = e11[23] = "-", e11.join("");
          }
        }
      }]).default;
    });
  }
});

// src/node_modules/@lit/reactive-element/css-tag.js
var t = globalThis;
var e = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s = Symbol();
var o = /* @__PURE__ */ new WeakMap();
var n = class {
  constructor(t8, e10, o7) {
    if (this._$cssResult$ = true, o7 !== s) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t8, this.t = e10;
  }
  get styleSheet() {
    let t8 = this.o;
    const s6 = this.t;
    if (e && void 0 === t8) {
      const e10 = void 0 !== s6 && 1 === s6.length;
      e10 && (t8 = o.get(s6)), void 0 === t8 && ((this.o = t8 = new CSSStyleSheet()).replaceSync(this.cssText), e10 && o.set(s6, t8));
    }
    return t8;
  }
  toString() {
    return this.cssText;
  }
};
var r = (t8) => new n("string" == typeof t8 ? t8 : t8 + "", void 0, s);
var i = (t8, ...e10) => {
  const o7 = 1 === t8.length ? t8[0] : e10.reduce((e11, s6, o8) => e11 + ((t9) => {
    if (true === t9._$cssResult$) return t9.cssText;
    if ("number" == typeof t9) return t9;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t9 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s6) + t8[o8 + 1], t8[0]);
  return new n(o7, t8, s);
};
var S = (s6, o7) => {
  if (e) s6.adoptedStyleSheets = o7.map((t8) => t8 instanceof CSSStyleSheet ? t8 : t8.styleSheet);
  else for (const e10 of o7) {
    const o8 = document.createElement("style"), n7 = t.litNonce;
    void 0 !== n7 && o8.setAttribute("nonce", n7), o8.textContent = e10.cssText, s6.appendChild(o8);
  }
};
var c = e ? (t8) => t8 : (t8) => t8 instanceof CSSStyleSheet ? ((t9) => {
  let e10 = "";
  for (const s6 of t9.cssRules) e10 += s6.cssText;
  return r(e10);
})(t8) : t8;

// src/node_modules/@lit/reactive-element/reactive-element.js
var { is: i2, defineProperty: e2, getOwnPropertyDescriptor: r2, getOwnPropertyNames: h, getOwnPropertySymbols: o2, getPrototypeOf: n2 } = Object;
var a = globalThis;
var c2 = a.trustedTypes;
var l = c2 ? c2.emptyScript : "";
var p = a.reactiveElementPolyfillSupport;
var d = (t8, s6) => t8;
var u = { toAttribute(t8, s6) {
  switch (s6) {
    case Boolean:
      t8 = t8 ? l : null;
      break;
    case Object:
    case Array:
      t8 = null == t8 ? t8 : JSON.stringify(t8);
  }
  return t8;
}, fromAttribute(t8, s6) {
  let i5 = t8;
  switch (s6) {
    case Boolean:
      i5 = null !== t8;
      break;
    case Number:
      i5 = null === t8 ? null : Number(t8);
      break;
    case Object:
    case Array:
      try {
        i5 = JSON.parse(t8);
      } catch (t9) {
        i5 = null;
      }
  }
  return i5;
} };
var f = (t8, s6) => !i2(t8, s6);
var y = { attribute: true, type: String, converter: u, reflect: false, hasChanged: f };
Symbol.metadata ??= Symbol("metadata"), a.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var b = class extends HTMLElement {
  static addInitializer(t8) {
    this._$Ei(), (this.l ??= []).push(t8);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t8, s6 = y) {
    if (s6.state && (s6.attribute = false), this._$Ei(), this.elementProperties.set(t8, s6), !s6.noAccessor) {
      const i5 = Symbol(), r9 = this.getPropertyDescriptor(t8, i5, s6);
      void 0 !== r9 && e2(this.prototype, t8, r9);
    }
  }
  static getPropertyDescriptor(t8, s6, i5) {
    const { get: e10, set: h5 } = r2(this.prototype, t8) ?? { get() {
      return this[s6];
    }, set(t9) {
      this[s6] = t9;
    } };
    return { get() {
      return e10?.call(this);
    }, set(s7) {
      const r9 = e10?.call(this);
      h5.call(this, s7), this.requestUpdate(t8, r9, i5);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t8) {
    return this.elementProperties.get(t8) ?? y;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d("elementProperties"))) return;
    const t8 = n2(this);
    t8.finalize(), void 0 !== t8.l && (this.l = [...t8.l]), this.elementProperties = new Map(t8.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d("properties"))) {
      const t9 = this.properties, s6 = [...h(t9), ...o2(t9)];
      for (const i5 of s6) this.createProperty(i5, t9[i5]);
    }
    const t8 = this[Symbol.metadata];
    if (null !== t8) {
      const s6 = litPropertyMetadata.get(t8);
      if (void 0 !== s6) for (const [t9, i5] of s6) this.elementProperties.set(t9, i5);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t9, s6] of this.elementProperties) {
      const i5 = this._$Eu(t9, s6);
      void 0 !== i5 && this._$Eh.set(i5, t9);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s6) {
    const i5 = [];
    if (Array.isArray(s6)) {
      const e10 = new Set(s6.flat(1 / 0).reverse());
      for (const s7 of e10) i5.unshift(c(s7));
    } else void 0 !== s6 && i5.push(c(s6));
    return i5;
  }
  static _$Eu(t8, s6) {
    const i5 = s6.attribute;
    return false === i5 ? void 0 : "string" == typeof i5 ? i5 : "string" == typeof t8 ? t8.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t8) => this.enableUpdating = t8), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t8) => t8(this));
  }
  addController(t8) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t8), void 0 !== this.renderRoot && this.isConnected && t8.hostConnected?.();
  }
  removeController(t8) {
    this._$EO?.delete(t8);
  }
  _$E_() {
    const t8 = /* @__PURE__ */ new Map(), s6 = this.constructor.elementProperties;
    for (const i5 of s6.keys()) this.hasOwnProperty(i5) && (t8.set(i5, this[i5]), delete this[i5]);
    t8.size > 0 && (this._$Ep = t8);
  }
  createRenderRoot() {
    const t8 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S(t8, this.constructor.elementStyles), t8;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t8) => t8.hostConnected?.());
  }
  enableUpdating(t8) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t8) => t8.hostDisconnected?.());
  }
  attributeChangedCallback(t8, s6, i5) {
    this._$AK(t8, i5);
  }
  _$EC(t8, s6) {
    const i5 = this.constructor.elementProperties.get(t8), e10 = this.constructor._$Eu(t8, i5);
    if (void 0 !== e10 && true === i5.reflect) {
      const r9 = (void 0 !== i5.converter?.toAttribute ? i5.converter : u).toAttribute(s6, i5.type);
      this._$Em = t8, null == r9 ? this.removeAttribute(e10) : this.setAttribute(e10, r9), this._$Em = null;
    }
  }
  _$AK(t8, s6) {
    const i5 = this.constructor, e10 = i5._$Eh.get(t8);
    if (void 0 !== e10 && this._$Em !== e10) {
      const t9 = i5.getPropertyOptions(e10), r9 = "function" == typeof t9.converter ? { fromAttribute: t9.converter } : void 0 !== t9.converter?.fromAttribute ? t9.converter : u;
      this._$Em = e10, this[e10] = r9.fromAttribute(s6, t9.type), this._$Em = null;
    }
  }
  requestUpdate(t8, s6, i5) {
    if (void 0 !== t8) {
      if (i5 ??= this.constructor.getPropertyOptions(t8), !(i5.hasChanged ?? f)(this[t8], s6)) return;
      this.P(t8, s6, i5);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t8, s6, i5) {
    this._$AL.has(t8) || this._$AL.set(t8, s6), true === i5.reflect && this._$Em !== t8 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t8);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t9) {
      Promise.reject(t9);
    }
    const t8 = this.scheduleUpdate();
    return null != t8 && await t8, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t10, s7] of this._$Ep) this[t10] = s7;
        this._$Ep = void 0;
      }
      const t9 = this.constructor.elementProperties;
      if (t9.size > 0) for (const [s7, i5] of t9) true !== i5.wrapped || this._$AL.has(s7) || void 0 === this[s7] || this.P(s7, this[s7], i5);
    }
    let t8 = false;
    const s6 = this._$AL;
    try {
      t8 = this.shouldUpdate(s6), t8 ? (this.willUpdate(s6), this._$EO?.forEach((t9) => t9.hostUpdate?.()), this.update(s6)) : this._$EU();
    } catch (s7) {
      throw t8 = false, this._$EU(), s7;
    }
    t8 && this._$AE(s6);
  }
  willUpdate(t8) {
  }
  _$AE(t8) {
    this._$EO?.forEach((t9) => t9.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t8)), this.updated(t8);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t8) {
    return true;
  }
  update(t8) {
    this._$Ej &&= this._$Ej.forEach((t9) => this._$EC(t9, this[t9])), this._$EU();
  }
  updated(t8) {
  }
  firstUpdated(t8) {
  }
};
b.elementStyles = [], b.shadowRootOptions = { mode: "open" }, b[d("elementProperties")] = /* @__PURE__ */ new Map(), b[d("finalized")] = /* @__PURE__ */ new Map(), p?.({ ReactiveElement: b }), (a.reactiveElementVersions ??= []).push("2.0.4");

// src/node_modules/lit-html/lit-html.js
var n3 = globalThis;
var c3 = n3.trustedTypes;
var h2 = c3 ? c3.createPolicy("lit-html", { createHTML: (t8) => t8 }) : void 0;
var f2 = "$lit$";
var v = `lit$${Math.random().toFixed(9).slice(2)}$`;
var m = "?" + v;
var _ = `<${m}>`;
var w = document;
var lt = () => w.createComment("");
var st = (t8) => null === t8 || "object" != typeof t8 && "function" != typeof t8;
var g = Array.isArray;
var $ = (t8) => g(t8) || "function" == typeof t8?.[Symbol.iterator];
var x = "[ 	\n\f\r]";
var T = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var E = /-->/g;
var k = />/g;
var O = RegExp(`>|${x}(?:([^\\s"'>=/]+)(${x}*=${x}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var S2 = /'/g;
var j = /"/g;
var M = /^(?:script|style|textarea|title)$/i;
var P = (t8) => (i5, ...s6) => ({ _$litType$: t8, strings: i5, values: s6 });
var ke = P(1);
var Oe = P(2);
var Se = P(3);
var R = Symbol.for("lit-noChange");
var D = Symbol.for("lit-nothing");
var V = /* @__PURE__ */ new WeakMap();
var I = w.createTreeWalker(w, 129);
function N(t8, i5) {
  if (!g(t8) || !t8.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== h2 ? h2.createHTML(i5) : i5;
}
var U = (t8, i5) => {
  const s6 = t8.length - 1, e10 = [];
  let h5, o7 = 2 === i5 ? "<svg>" : 3 === i5 ? "<math>" : "", n7 = T;
  for (let i6 = 0; i6 < s6; i6++) {
    const s7 = t8[i6];
    let r9, l3, c6 = -1, a3 = 0;
    for (; a3 < s7.length && (n7.lastIndex = a3, l3 = n7.exec(s7), null !== l3); ) a3 = n7.lastIndex, n7 === T ? "!--" === l3[1] ? n7 = E : void 0 !== l3[1] ? n7 = k : void 0 !== l3[2] ? (M.test(l3[2]) && (h5 = RegExp("</" + l3[2], "g")), n7 = O) : void 0 !== l3[3] && (n7 = O) : n7 === O ? ">" === l3[0] ? (n7 = h5 ?? T, c6 = -1) : void 0 === l3[1] ? c6 = -2 : (c6 = n7.lastIndex - l3[2].length, r9 = l3[1], n7 = void 0 === l3[3] ? O : '"' === l3[3] ? j : S2) : n7 === j || n7 === S2 ? n7 = O : n7 === E || n7 === k ? n7 = T : (n7 = O, h5 = void 0);
    const u3 = n7 === O && t8[i6 + 1].startsWith("/>") ? " " : "";
    o7 += n7 === T ? s7 + _ : c6 >= 0 ? (e10.push(r9), s7.slice(0, c6) + f2 + s7.slice(c6) + v + u3) : s7 + v + (-2 === c6 ? i6 : u3);
  }
  return [N(t8, o7 + (t8[s6] || "<?>") + (2 === i5 ? "</svg>" : 3 === i5 ? "</math>" : "")), e10];
};
var B = class _B2 {
  constructor({ strings: t8, _$litType$: i5 }, s6) {
    let e10;
    this.parts = [];
    let h5 = 0, o7 = 0;
    const n7 = t8.length - 1, r9 = this.parts, [l3, a3] = U(t8, i5);
    if (this.el = _B2.createElement(l3, s6), I.currentNode = this.el.content, 2 === i5 || 3 === i5) {
      const t9 = this.el.content.firstChild;
      t9.replaceWith(...t9.childNodes);
    }
    for (; null !== (e10 = I.nextNode()) && r9.length < n7; ) {
      if (1 === e10.nodeType) {
        if (e10.hasAttributes()) for (const t9 of e10.getAttributeNames()) if (t9.endsWith(f2)) {
          const i6 = a3[o7++], s7 = e10.getAttribute(t9).split(v), n8 = /([.?@])?(.*)/.exec(i6);
          r9.push({ type: 1, index: h5, name: n8[2], strings: s7, ctor: "." === n8[1] ? Y : "?" === n8[1] ? Z : "@" === n8[1] ? q : G }), e10.removeAttribute(t9);
        } else t9.startsWith(v) && (r9.push({ type: 6, index: h5 }), e10.removeAttribute(t9));
        if (M.test(e10.tagName)) {
          const t9 = e10.textContent.split(v), i6 = t9.length - 1;
          if (i6 > 0) {
            e10.textContent = c3 ? c3.emptyScript : "";
            for (let s7 = 0; s7 < i6; s7++) e10.append(t9[s7], lt()), I.nextNode(), r9.push({ type: 2, index: ++h5 });
            e10.append(t9[i6], lt());
          }
        }
      } else if (8 === e10.nodeType) if (e10.data === m) r9.push({ type: 2, index: h5 });
      else {
        let t9 = -1;
        for (; -1 !== (t9 = e10.data.indexOf(v, t9 + 1)); ) r9.push({ type: 7, index: h5 }), t9 += v.length - 1;
      }
      h5++;
    }
  }
  static createElement(t8, i5) {
    const s6 = w.createElement("template");
    return s6.innerHTML = t8, s6;
  }
};
function z(t8, i5, s6 = t8, e10) {
  if (i5 === R) return i5;
  let h5 = void 0 !== e10 ? s6.o?.[e10] : s6.l;
  const o7 = st(i5) ? void 0 : i5._$litDirective$;
  return h5?.constructor !== o7 && (h5?._$AO?.(false), void 0 === o7 ? h5 = void 0 : (h5 = new o7(t8), h5._$AT(t8, s6, e10)), void 0 !== e10 ? (s6.o ??= [])[e10] = h5 : s6.l = h5), void 0 !== h5 && (i5 = z(t8, h5._$AS(t8, i5.values), h5, e10)), i5;
}
var F = class {
  constructor(t8, i5) {
    this._$AV = [], this._$AN = void 0, this._$AD = t8, this._$AM = i5;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t8) {
    const { el: { content: i5 }, parts: s6 } = this._$AD, e10 = (t8?.creationScope ?? w).importNode(i5, true);
    I.currentNode = e10;
    let h5 = I.nextNode(), o7 = 0, n7 = 0, r9 = s6[0];
    for (; void 0 !== r9; ) {
      if (o7 === r9.index) {
        let i6;
        2 === r9.type ? i6 = new et(h5, h5.nextSibling, this, t8) : 1 === r9.type ? i6 = new r9.ctor(h5, r9.name, r9.strings, this, t8) : 6 === r9.type && (i6 = new K(h5, this, t8)), this._$AV.push(i6), r9 = s6[++n7];
      }
      o7 !== r9?.index && (h5 = I.nextNode(), o7++);
    }
    return I.currentNode = w, e10;
  }
  p(t8) {
    let i5 = 0;
    for (const s6 of this._$AV) void 0 !== s6 && (void 0 !== s6.strings ? (s6._$AI(t8, s6, i5), i5 += s6.strings.length - 2) : s6._$AI(t8[i5])), i5++;
  }
};
var et = class _et2 {
  get _$AU() {
    return this._$AM?._$AU ?? this.v;
  }
  constructor(t8, i5, s6, e10) {
    this.type = 2, this._$AH = D, this._$AN = void 0, this._$AA = t8, this._$AB = i5, this._$AM = s6, this.options = e10, this.v = e10?.isConnected ?? true;
  }
  get parentNode() {
    let t8 = this._$AA.parentNode;
    const i5 = this._$AM;
    return void 0 !== i5 && 11 === t8?.nodeType && (t8 = i5.parentNode), t8;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t8, i5 = this) {
    t8 = z(this, t8, i5), st(t8) ? t8 === D || null == t8 || "" === t8 ? (this._$AH !== D && this._$AR(), this._$AH = D) : t8 !== this._$AH && t8 !== R && this._(t8) : void 0 !== t8._$litType$ ? this.$(t8) : void 0 !== t8.nodeType ? this.T(t8) : $(t8) ? this.k(t8) : this._(t8);
  }
  O(t8) {
    return this._$AA.parentNode.insertBefore(t8, this._$AB);
  }
  T(t8) {
    this._$AH !== t8 && (this._$AR(), this._$AH = this.O(t8));
  }
  _(t8) {
    this._$AH !== D && st(this._$AH) ? this._$AA.nextSibling.data = t8 : this.T(w.createTextNode(t8)), this._$AH = t8;
  }
  $(t8) {
    const { values: i5, _$litType$: s6 } = t8, e10 = "number" == typeof s6 ? this._$AC(t8) : (void 0 === s6.el && (s6.el = B.createElement(N(s6.h, s6.h[0]), this.options)), s6);
    if (this._$AH?._$AD === e10) this._$AH.p(i5);
    else {
      const t9 = new F(e10, this), s7 = t9.u(this.options);
      t9.p(i5), this.T(s7), this._$AH = t9;
    }
  }
  _$AC(t8) {
    let i5 = V.get(t8.strings);
    return void 0 === i5 && V.set(t8.strings, i5 = new B(t8)), i5;
  }
  k(t8) {
    g(this._$AH) || (this._$AH = [], this._$AR());
    const i5 = this._$AH;
    let s6, e10 = 0;
    for (const h5 of t8) e10 === i5.length ? i5.push(s6 = new _et2(this.O(lt()), this.O(lt()), this, this.options)) : s6 = i5[e10], s6._$AI(h5), e10++;
    e10 < i5.length && (this._$AR(s6 && s6._$AB.nextSibling, e10), i5.length = e10);
  }
  _$AR(t8 = this._$AA.nextSibling, i5) {
    for (this._$AP?.(false, true, i5); t8 && t8 !== this._$AB; ) {
      const i6 = t8.nextSibling;
      t8.remove(), t8 = i6;
    }
  }
  setConnected(t8) {
    void 0 === this._$AM && (this.v = t8, this._$AP?.(t8));
  }
};
var G = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t8, i5, s6, e10, h5) {
    this.type = 1, this._$AH = D, this._$AN = void 0, this.element = t8, this.name = i5, this._$AM = e10, this.options = h5, s6.length > 2 || "" !== s6[0] || "" !== s6[1] ? (this._$AH = Array(s6.length - 1).fill(new String()), this.strings = s6) : this._$AH = D;
  }
  _$AI(t8, i5 = this, s6, e10) {
    const h5 = this.strings;
    let o7 = false;
    if (void 0 === h5) t8 = z(this, t8, i5, 0), o7 = !st(t8) || t8 !== this._$AH && t8 !== R, o7 && (this._$AH = t8);
    else {
      const e11 = t8;
      let n7, r9;
      for (t8 = h5[0], n7 = 0; n7 < h5.length - 1; n7++) r9 = z(this, e11[s6 + n7], i5, n7), r9 === R && (r9 = this._$AH[n7]), o7 ||= !st(r9) || r9 !== this._$AH[n7], r9 === D ? t8 = D : t8 !== D && (t8 += (r9 ?? "") + h5[n7 + 1]), this._$AH[n7] = r9;
    }
    o7 && !e10 && this.j(t8);
  }
  j(t8) {
    t8 === D ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t8 ?? "");
  }
};
var Y = class extends G {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t8) {
    this.element[this.name] = t8 === D ? void 0 : t8;
  }
};
var Z = class extends G {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t8) {
    this.element.toggleAttribute(this.name, !!t8 && t8 !== D);
  }
};
var q = class extends G {
  constructor(t8, i5, s6, e10, h5) {
    super(t8, i5, s6, e10, h5), this.type = 5;
  }
  _$AI(t8, i5 = this) {
    if ((t8 = z(this, t8, i5, 0) ?? D) === R) return;
    const s6 = this._$AH, e10 = t8 === D && s6 !== D || t8.capture !== s6.capture || t8.once !== s6.once || t8.passive !== s6.passive, h5 = t8 !== D && (s6 === D || e10);
    e10 && this.element.removeEventListener(this.name, this, s6), h5 && this.element.addEventListener(this.name, this, t8), this._$AH = t8;
  }
  handleEvent(t8) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t8) : this._$AH.handleEvent(t8);
  }
};
var K = class {
  constructor(t8, i5, s6) {
    this.element = t8, this.type = 6, this._$AN = void 0, this._$AM = i5, this.options = s6;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t8) {
    z(this, t8);
  }
};
var si = { M: f2, P: v, A: m, C: 1, L: U, R: F, D: $, V: z, I: et, H: G, N: Z, U: q, B: Y, F: K };
var Re = n3.litHtmlPolyfillSupport;
Re?.(B, et), (n3.litHtmlVersions ??= []).push("3.2.0");
var Q = (t8, i5, s6) => {
  const e10 = s6?.renderBefore ?? i5;
  let h5 = e10._$litPart$;
  if (void 0 === h5) {
    const t9 = s6?.renderBefore ?? null;
    e10._$litPart$ = h5 = new et(i5.insertBefore(lt(), t9), t9, void 0, s6 ?? {});
  }
  return h5._$AI(t8), h5;
};

// src/node_modules/lit-element/lit-element.js
var h3 = class extends b {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    const t8 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t8.firstChild, t8;
  }
  update(t8) {
    const e10 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t8), this.o = Q(e10, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this.o?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.o?.setConnected(false);
  }
  render() {
    return R;
  }
};
h3._$litElement$ = true, h3["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h3 });
var f3 = globalThis.litElementPolyfillSupport;
f3?.({ LitElement: h3 });
(globalThis.litElementVersions ??= []).push("4.1.0");

// node_modules/@lit/context/lib/context-request-event.js
var s2 = class extends Event {
  constructor(s6, t8, e10) {
    super("context-request", { bubbles: true, composed: true }), this.context = s6, this.callback = t8, this.subscribe = e10 ?? false;
  }
};

// node_modules/@lit/context/lib/create-context.js
function n4(n7) {
  return n7;
}

// node_modules/@lit/context/lib/controllers/context-consumer.js
var s3 = class {
  constructor(t8, s6, i5, h5) {
    if (this.subscribe = false, this.provided = false, this.value = void 0, this.t = (t9, s7) => {
      this.unsubscribe && (this.unsubscribe !== s7 && (this.provided = false, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = t9, this.host.requestUpdate(), this.provided && !this.subscribe || (this.provided = true, this.callback && this.callback(t9, s7)), this.unsubscribe = s7;
    }, this.host = t8, void 0 !== s6.context) {
      const t9 = s6;
      this.context = t9.context, this.callback = t9.callback, this.subscribe = t9.subscribe ?? false;
    } else this.context = s6, this.callback = i5, this.subscribe = h5 ?? false;
    this.host.addController(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.host.dispatchEvent(new s2(this.context, this.t, this.subscribe));
  }
};

// node_modules/@lit/context/lib/value-notifier.js
var s4 = class {
  get value() {
    return this.o;
  }
  set value(s6) {
    this.setValue(s6);
  }
  setValue(s6, t8 = false) {
    const i5 = t8 || !Object.is(s6, this.o);
    this.o = s6, i5 && this.updateObservers();
  }
  constructor(s6) {
    this.subscriptions = /* @__PURE__ */ new Map(), this.updateObservers = () => {
      for (const [s7, { disposer: t8 }] of this.subscriptions) s7(this.o, t8);
    }, void 0 !== s6 && (this.value = s6);
  }
  addCallback(s6, t8, i5) {
    if (!i5) return void s6(this.value);
    this.subscriptions.has(s6) || this.subscriptions.set(s6, { disposer: () => {
      this.subscriptions.delete(s6);
    }, consumerHost: t8 });
    const { disposer: h5 } = this.subscriptions.get(s6);
    s6(this.value, h5);
  }
  clearCallbacks() {
    this.subscriptions.clear();
  }
};

// node_modules/@lit/context/lib/controllers/context-provider.js
var e3 = class extends Event {
  constructor(t8) {
    super("context-provider", { bubbles: true, composed: true }), this.context = t8;
  }
};
var i3 = class extends s4 {
  constructor(s6, e10, i5) {
    super(void 0 !== e10.context ? e10.initialValue : i5), this.onContextRequest = (t8) => {
      const s7 = t8.composedPath()[0];
      t8.context === this.context && s7 !== this.host && (t8.stopPropagation(), this.addCallback(t8.callback, s7, t8.subscribe));
    }, this.onProviderRequest = (s7) => {
      const e11 = s7.composedPath()[0];
      if (s7.context !== this.context || e11 === this.host) return;
      const i6 = /* @__PURE__ */ new Set();
      for (const [s8, { consumerHost: e12 }] of this.subscriptions) i6.has(s8) || (i6.add(s8), e12.dispatchEvent(new s2(this.context, s8, true)));
      s7.stopPropagation();
    }, this.host = s6, void 0 !== e10.context ? this.context = e10.context : this.context = e10, this.attachListeners(), this.host.addController?.(this);
  }
  attachListeners() {
    this.host.addEventListener("context-request", this.onContextRequest), this.host.addEventListener("context-provider", this.onProviderRequest);
  }
  hostConnected() {
    this.host.dispatchEvent(new e3(this.context));
  }
};

// node_modules/@lit/context/lib/decorators/provide.js
function e4({ context: e10 }) {
  return (n7, r9) => {
    const i5 = /* @__PURE__ */ new WeakMap();
    if ("object" == typeof r9) return r9.addInitializer(function() {
      i5.set(this, new i3(this, { context: e10 }));
    }), { get() {
      return n7.get.call(this);
    }, set(t8) {
      return i5.get(this)?.setValue(t8), n7.set.call(this, t8);
    }, init(t8) {
      return i5.get(this)?.setValue(t8), t8;
    } };
    {
      n7.constructor.addInitializer((n8) => {
        i5.set(n8, new i3(n8, { context: e10 }));
      });
      const o7 = Object.getOwnPropertyDescriptor(n7, r9);
      let s6;
      if (void 0 === o7) {
        const t8 = /* @__PURE__ */ new WeakMap();
        s6 = { get() {
          return t8.get(this);
        }, set(e11) {
          i5.get(this).setValue(e11), t8.set(this, e11);
        }, configurable: true, enumerable: true };
      } else {
        const t8 = o7.set;
        s6 = { ...o7, set(e11) {
          i5.get(this).setValue(e11), t8?.call(this, e11);
        } };
      }
      return void Object.defineProperty(n7, r9, s6);
    }
  };
}

// node_modules/@lit/context/lib/decorators/consume.js
function c4({ context: c6, subscribe: e10 }) {
  return (o7, n7) => {
    "object" == typeof n7 ? n7.addInitializer(function() {
      new s3(this, { context: c6, callback: (t8) => {
        o7.set.call(this, t8);
      }, subscribe: e10 });
    }) : o7.constructor.addInitializer((o8) => {
      new s3(o8, { context: c6, callback: (t8) => {
        o8[n7] = t8;
      }, subscribe: e10 });
    });
  };
}

// src/node_modules/@webwriter/lit/index.js
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __knownSymbol2 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError2 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name2 = (target, value) => __defProp2(target, "name", { value, configurable: true });
var __decoratorStart2 = (base) => [, , , __create2(base?.[__knownSymbol2("metadata")] ?? null)];
var __decoratorStrings2 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn2 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError2("Function expected") : fn;
var __decoratorContext2 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings2[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError2("Already initialized") : fns.push(__expectFn2(fn || null)) });
var __decoratorMetadata2 = (array, target) => __defNormalProp2(target, __knownSymbol2("metadata"), array[3]);
var __runInitializers2 = (array, flags, self2, value) => {
  for (var i32 = 0, fns = array[flags >> 1], n52 = fns && fns.length; i32 < n52; i32++) flags & 1 ? fns[i32].call(self2) : value = fns[i32].call(self2, value);
  return value;
};
var __decorateElement2 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k22 = flags & 7, s22 = !!(flags & 8), p22 = !!(flags & 16);
  var j22 = k22 > 3 ? array.length + 1 : k22 ? s22 ? 1 : 2 : 0, key = __decoratorStrings2[k22 + 5];
  var initializers = k22 > 3 && (array[j22 - 1] = []), extraInitializers = array[j22] || (array[j22] = []);
  var desc = k22 && (!p22 && !s22 && (target = target.prototype), k22 < 5 && (k22 > 3 || !p22) && __getOwnPropDesc2(k22 < 4 ? target : { get [name]() {
    return __privateGet2(this, extra);
  }, set [name](x22) {
    return __privateSet2(this, extra, x22);
  } }, name));
  k22 ? p22 && k22 < 4 && __name2(extra, (k22 > 2 ? "set " : k22 > 1 ? "get " : "") + name) : __name2(target, name);
  for (var i32 = decorators.length - 1; i32 >= 0; i32--) {
    ctx = __decoratorContext2(k22, name, done = {}, array[3], extraInitializers);
    if (k22) {
      ctx.static = s22, ctx.private = p22, access = ctx.access = { has: p22 ? (x22) => __privateIn2(target, x22) : (x22) => name in x22 };
      if (k22 ^ 3) access.get = p22 ? (x22) => (k22 ^ 1 ? __privateGet2 : __privateMethod2)(x22, target, k22 ^ 4 ? extra : desc.get) : (x22) => x22[name];
      if (k22 > 2) access.set = p22 ? (x22, y22) => __privateSet2(x22, target, y22, k22 ^ 4 ? extra : desc.set) : (x22, y22) => x22[name] = y22;
    }
    it = (0, decorators[i32])(k22 ? k22 < 4 ? p22 ? extra : desc[key] : k22 > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k22 ^ 4 || it === void 0) __expectFn2(it) && (k22 > 4 ? initializers.unshift(it) : k22 ? p22 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError2("Object expected");
    else __expectFn2(fn = it.get) && (desc.get = fn), __expectFn2(fn = it.set) && (desc.set = fn), __expectFn2(fn = it.init) && initializers.unshift(fn);
  }
  return k22 || __decoratorMetadata2(array, target), desc && __defProp2(target, name, desc), p22 ? k22 ^ 4 ? extra : desc : target;
};
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck2 = (obj, member, msg) => member.has(obj) || __typeError2("Cannot " + msg);
var __privateIn2 = (member, obj) => Object(obj) !== obj ? __typeError2('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet2 = (obj, member, getter) => (__accessCheck2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd2 = (obj, member, value) => member.has(obj) ? __typeError2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet2 = (obj, member, value, setter) => (__accessCheck2(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod2 = (obj, member, method) => (__accessCheck2(obj, member, "access private method"), method);
var t3 = globalThis;
var e5 = t3.ShadowRoot && (void 0 === t3.ShadyCSS || t3.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s5 = Symbol();
var o3 = /* @__PURE__ */ new WeakMap();
var n5 = class {
  constructor(t22, e42, o42) {
    if (this._$cssResult$ = true, o42 !== s5) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t22, this.t = e42;
  }
  get styleSheet() {
    let t22 = this.o;
    const s22 = this.t;
    if (e5 && void 0 === t22) {
      const e42 = void 0 !== s22 && 1 === s22.length;
      e42 && (t22 = o3.get(s22)), void 0 === t22 && ((this.o = t22 = new CSSStyleSheet()).replaceSync(this.cssText), e42 && o3.set(s22, t22));
    }
    return t22;
  }
  toString() {
    return this.cssText;
  }
};
var r3 = (t22) => new n5("string" == typeof t22 ? t22 : t22 + "", void 0, s5);
var S3 = (s22, o42) => {
  if (e5) s22.adoptedStyleSheets = o42.map((t22) => t22 instanceof CSSStyleSheet ? t22 : t22.styleSheet);
  else for (const e42 of o42) {
    const o52 = document.createElement("style"), n52 = t3.litNonce;
    void 0 !== n52 && o52.setAttribute("nonce", n52), o52.textContent = e42.cssText, s22.appendChild(o52);
  }
};
var c5 = e5 ? (t22) => t22 : (t22) => t22 instanceof CSSStyleSheet ? ((t32) => {
  let e42 = "";
  for (const s22 of t32.cssRules) e42 += s22.cssText;
  return r3(e42);
})(t22) : t22;
var { is: i22, defineProperty: e22, getOwnPropertyDescriptor: r22, getOwnPropertyNames: h4, getOwnPropertySymbols: o22, getPrototypeOf: n22 } = Object;
var a2 = globalThis;
var c22 = a2.trustedTypes;
var l2 = c22 ? c22.emptyScript : "";
var p2 = a2.reactiveElementPolyfillSupport;
var d2 = (t22, s22) => t22;
var u2 = { toAttribute(t22, s22) {
  switch (s22) {
    case Boolean:
      t22 = t22 ? l2 : null;
      break;
    case Object:
    case Array:
      t22 = null == t22 ? t22 : JSON.stringify(t22);
  }
  return t22;
}, fromAttribute(t22, s22) {
  let i32 = t22;
  switch (s22) {
    case Boolean:
      i32 = null !== t22;
      break;
    case Number:
      i32 = null === t22 ? null : Number(t22);
      break;
    case Object:
    case Array:
      try {
        i32 = JSON.parse(t22);
      } catch (t32) {
        i32 = null;
      }
  }
  return i32;
} };
var f4 = (t22, s22) => !i22(t22, s22);
var y2 = { attribute: true, type: String, converter: u2, reflect: false, hasChanged: f4 };
Symbol.metadata ??= Symbol("metadata"), a2.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var b2 = class extends HTMLElement {
  static addInitializer(t22) {
    this._$Ei(), (this.l ??= []).push(t22);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t22, s22 = y2) {
    if (s22.state && (s22.attribute = false), this._$Ei(), this.elementProperties.set(t22, s22), !s22.noAccessor) {
      const i32 = Symbol(), r42 = this.getPropertyDescriptor(t22, i32, s22);
      void 0 !== r42 && e22(this.prototype, t22, r42);
    }
  }
  static getPropertyDescriptor(t22, s22, i32) {
    const { get: e42, set: h42 } = r22(this.prototype, t22) ?? { get() {
      return this[s22];
    }, set(t32) {
      this[s22] = t32;
    } };
    return { get() {
      return e42?.call(this);
    }, set(s32) {
      const r42 = e42?.call(this);
      h42.call(this, s32), this.requestUpdate(t22, r42, i32);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t22) {
    return this.elementProperties.get(t22) ?? y2;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d2("elementProperties"))) return;
    const t22 = n22(this);
    t22.finalize(), void 0 !== t22.l && (this.l = [...t22.l]), this.elementProperties = new Map(t22.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d2("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d2("properties"))) {
      const t32 = this.properties, s22 = [...h4(t32), ...o22(t32)];
      for (const i32 of s22) this.createProperty(i32, t32[i32]);
    }
    const t22 = this[Symbol.metadata];
    if (null !== t22) {
      const s22 = litPropertyMetadata.get(t22);
      if (void 0 !== s22) for (const [t32, i32] of s22) this.elementProperties.set(t32, i32);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t32, s22] of this.elementProperties) {
      const i32 = this._$Eu(t32, s22);
      void 0 !== i32 && this._$Eh.set(i32, t32);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s22) {
    const i32 = [];
    if (Array.isArray(s22)) {
      const e42 = new Set(s22.flat(1 / 0).reverse());
      for (const s32 of e42) i32.unshift(c5(s32));
    } else void 0 !== s22 && i32.push(c5(s22));
    return i32;
  }
  static _$Eu(t22, s22) {
    const i32 = s22.attribute;
    return false === i32 ? void 0 : "string" == typeof i32 ? i32 : "string" == typeof t22 ? t22.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t22) => this.enableUpdating = t22), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t22) => t22(this));
  }
  addController(t22) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t22), void 0 !== this.renderRoot && this.isConnected && t22.hostConnected?.();
  }
  removeController(t22) {
    this._$EO?.delete(t22);
  }
  _$E_() {
    const t22 = /* @__PURE__ */ new Map(), s22 = this.constructor.elementProperties;
    for (const i32 of s22.keys()) this.hasOwnProperty(i32) && (t22.set(i32, this[i32]), delete this[i32]);
    t22.size > 0 && (this._$Ep = t22);
  }
  createRenderRoot() {
    const t22 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S3(t22, this.constructor.elementStyles), t22;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t22) => t22.hostConnected?.());
  }
  enableUpdating(t22) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t22) => t22.hostDisconnected?.());
  }
  attributeChangedCallback(t22, s22, i32) {
    this._$AK(t22, i32);
  }
  _$EC(t22, s22) {
    const i32 = this.constructor.elementProperties.get(t22), e42 = this.constructor._$Eu(t22, i32);
    if (void 0 !== e42 && true === i32.reflect) {
      const r42 = (void 0 !== i32.converter?.toAttribute ? i32.converter : u2).toAttribute(s22, i32.type);
      this._$Em = t22, null == r42 ? this.removeAttribute(e42) : this.setAttribute(e42, r42), this._$Em = null;
    }
  }
  _$AK(t22, s22) {
    const i32 = this.constructor, e42 = i32._$Eh.get(t22);
    if (void 0 !== e42 && this._$Em !== e42) {
      const t32 = i32.getPropertyOptions(e42), r42 = "function" == typeof t32.converter ? { fromAttribute: t32.converter } : void 0 !== t32.converter?.fromAttribute ? t32.converter : u2;
      this._$Em = e42, this[e42] = r42.fromAttribute(s22, t32.type), this._$Em = null;
    }
  }
  requestUpdate(t22, s22, i32) {
    if (void 0 !== t22) {
      if (i32 ??= this.constructor.getPropertyOptions(t22), !(i32.hasChanged ?? f4)(this[t22], s22)) return;
      this.P(t22, s22, i32);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t22, s22, i32) {
    this._$AL.has(t22) || this._$AL.set(t22, s22), true === i32.reflect && this._$Em !== t22 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t22);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t32) {
      Promise.reject(t32);
    }
    const t22 = this.scheduleUpdate();
    return null != t22 && await t22, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t42, s32] of this._$Ep) this[t42] = s32;
        this._$Ep = void 0;
      }
      const t32 = this.constructor.elementProperties;
      if (t32.size > 0) for (const [s32, i32] of t32) true !== i32.wrapped || this._$AL.has(s32) || void 0 === this[s32] || this.P(s32, this[s32], i32);
    }
    let t22 = false;
    const s22 = this._$AL;
    try {
      t22 = this.shouldUpdate(s22), t22 ? (this.willUpdate(s22), this._$EO?.forEach((t32) => t32.hostUpdate?.()), this.update(s22)) : this._$EU();
    } catch (s32) {
      throw t22 = false, this._$EU(), s32;
    }
    t22 && this._$AE(s22);
  }
  willUpdate(t22) {
  }
  _$AE(t22) {
    this._$EO?.forEach((t32) => t32.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t22)), this.updated(t22);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t22) {
    return true;
  }
  update(t22) {
    this._$Ej &&= this._$Ej.forEach((t32) => this._$EC(t32, this[t32])), this._$EU();
  }
  updated(t22) {
  }
  firstUpdated(t22) {
  }
};
b2.elementStyles = [], b2.shadowRootOptions = { mode: "open" }, b2[d2("elementProperties")] = /* @__PURE__ */ new Map(), b2[d2("finalized")] = /* @__PURE__ */ new Map(), p2?.({ ReactiveElement: b2 }), (a2.reactiveElementVersions ??= []).push("2.0.4");
var n32 = globalThis;
var c32 = n32.trustedTypes;
var h22 = c32 ? c32.createPolicy("lit-html", { createHTML: (t22) => t22 }) : void 0;
var f22 = "$lit$";
var v2 = `lit$${Math.random().toFixed(9).slice(2)}$`;
var m2 = "?" + v2;
var _2 = `<${m2}>`;
var w2 = document;
var lt2 = () => w2.createComment("");
var st2 = (t22) => null === t22 || "object" != typeof t22 && "function" != typeof t22;
var g2 = Array.isArray;
var $2 = (t22) => g2(t22) || "function" == typeof t22?.[Symbol.iterator];
var x2 = "[ 	\n\f\r]";
var T2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var E2 = /-->/g;
var k2 = />/g;
var O2 = RegExp(`>|${x2}(?:([^\\s"'>=/]+)(${x2}*=${x2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var S22 = /'/g;
var j2 = /"/g;
var M2 = /^(?:script|style|textarea|title)$/i;
var P2 = (t22) => (i32, ...s22) => ({ _$litType$: t22, strings: i32, values: s22 });
var ke2 = P2(1);
var Oe2 = P2(2);
var Se2 = P2(3);
var R2 = Symbol.for("lit-noChange");
var D2 = Symbol.for("lit-nothing");
var V2 = /* @__PURE__ */ new WeakMap();
var I2 = w2.createTreeWalker(w2, 129);
function N2(t22, i32) {
  if (!g2(t22) || !t22.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== h22 ? h22.createHTML(i32) : i32;
}
var U2 = (t22, i32) => {
  const s22 = t22.length - 1, e42 = [];
  let h42, o42 = 2 === i32 ? "<svg>" : 3 === i32 ? "<math>" : "", n52 = T2;
  for (let i42 = 0; i42 < s22; i42++) {
    const s32 = t22[i42];
    let r42, l22, c42 = -1, a22 = 0;
    for (; a22 < s32.length && (n52.lastIndex = a22, l22 = n52.exec(s32), null !== l22); ) a22 = n52.lastIndex, n52 === T2 ? "!--" === l22[1] ? n52 = E2 : void 0 !== l22[1] ? n52 = k2 : void 0 !== l22[2] ? (M2.test(l22[2]) && (h42 = RegExp("</" + l22[2], "g")), n52 = O2) : void 0 !== l22[3] && (n52 = O2) : n52 === O2 ? ">" === l22[0] ? (n52 = h42 ?? T2, c42 = -1) : void 0 === l22[1] ? c42 = -2 : (c42 = n52.lastIndex - l22[2].length, r42 = l22[1], n52 = void 0 === l22[3] ? O2 : '"' === l22[3] ? j2 : S22) : n52 === j2 || n52 === S22 ? n52 = O2 : n52 === E2 || n52 === k2 ? n52 = T2 : (n52 = O2, h42 = void 0);
    const u22 = n52 === O2 && t22[i42 + 1].startsWith("/>") ? " " : "";
    o42 += n52 === T2 ? s32 + _2 : c42 >= 0 ? (e42.push(r42), s32.slice(0, c42) + f22 + s32.slice(c42) + v2 + u22) : s32 + v2 + (-2 === c42 ? i42 : u22);
  }
  return [N2(t22, o42 + (t22[s22] || "<?>") + (2 === i32 ? "</svg>" : 3 === i32 ? "</math>" : "")), e42];
};
var B2 = class _B {
  constructor({ strings: t22, _$litType$: i32 }, s22) {
    let e42;
    this.parts = [];
    let h42 = 0, o42 = 0;
    const n52 = t22.length - 1, r42 = this.parts, [l22, a22] = U2(t22, i32);
    if (this.el = _B.createElement(l22, s22), I2.currentNode = this.el.content, 2 === i32 || 3 === i32) {
      const t32 = this.el.content.firstChild;
      t32.replaceWith(...t32.childNodes);
    }
    for (; null !== (e42 = I2.nextNode()) && r42.length < n52; ) {
      if (1 === e42.nodeType) {
        if (e42.hasAttributes()) for (const t32 of e42.getAttributeNames()) if (t32.endsWith(f22)) {
          const i42 = a22[o42++], s32 = e42.getAttribute(t32).split(v2), n62 = /([.?@])?(.*)/.exec(i42);
          r42.push({ type: 1, index: h42, name: n62[2], strings: s32, ctor: "." === n62[1] ? Y2 : "?" === n62[1] ? Z2 : "@" === n62[1] ? q2 : G2 }), e42.removeAttribute(t32);
        } else t32.startsWith(v2) && (r42.push({ type: 6, index: h42 }), e42.removeAttribute(t32));
        if (M2.test(e42.tagName)) {
          const t32 = e42.textContent.split(v2), i42 = t32.length - 1;
          if (i42 > 0) {
            e42.textContent = c32 ? c32.emptyScript : "";
            for (let s32 = 0; s32 < i42; s32++) e42.append(t32[s32], lt2()), I2.nextNode(), r42.push({ type: 2, index: ++h42 });
            e42.append(t32[i42], lt2());
          }
        }
      } else if (8 === e42.nodeType) if (e42.data === m2) r42.push({ type: 2, index: h42 });
      else {
        let t32 = -1;
        for (; -1 !== (t32 = e42.data.indexOf(v2, t32 + 1)); ) r42.push({ type: 7, index: h42 }), t32 += v2.length - 1;
      }
      h42++;
    }
  }
  static createElement(t22, i32) {
    const s22 = w2.createElement("template");
    return s22.innerHTML = t22, s22;
  }
};
function z2(t22, i32, s22 = t22, e42) {
  if (i32 === R2) return i32;
  let h42 = void 0 !== e42 ? s22.o?.[e42] : s22.l;
  const o42 = st2(i32) ? void 0 : i32._$litDirective$;
  return h42?.constructor !== o42 && (h42?._$AO?.(false), void 0 === o42 ? h42 = void 0 : (h42 = new o42(t22), h42._$AT(t22, s22, e42)), void 0 !== e42 ? (s22.o ??= [])[e42] = h42 : s22.l = h42), void 0 !== h42 && (i32 = z2(t22, h42._$AS(t22, i32.values), h42, e42)), i32;
}
var F2 = class {
  constructor(t22, i32) {
    this._$AV = [], this._$AN = void 0, this._$AD = t22, this._$AM = i32;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t22) {
    const { el: { content: i32 }, parts: s22 } = this._$AD, e42 = (t22?.creationScope ?? w2).importNode(i32, true);
    I2.currentNode = e42;
    let h42 = I2.nextNode(), o42 = 0, n52 = 0, r42 = s22[0];
    for (; void 0 !== r42; ) {
      if (o42 === r42.index) {
        let i42;
        2 === r42.type ? i42 = new et2(h42, h42.nextSibling, this, t22) : 1 === r42.type ? i42 = new r42.ctor(h42, r42.name, r42.strings, this, t22) : 6 === r42.type && (i42 = new K2(h42, this, t22)), this._$AV.push(i42), r42 = s22[++n52];
      }
      o42 !== r42?.index && (h42 = I2.nextNode(), o42++);
    }
    return I2.currentNode = w2, e42;
  }
  p(t22) {
    let i32 = 0;
    for (const s22 of this._$AV) void 0 !== s22 && (void 0 !== s22.strings ? (s22._$AI(t22, s22, i32), i32 += s22.strings.length - 2) : s22._$AI(t22[i32])), i32++;
  }
};
var et2 = class _et {
  get _$AU() {
    return this._$AM?._$AU ?? this.v;
  }
  constructor(t22, i32, s22, e42) {
    this.type = 2, this._$AH = D2, this._$AN = void 0, this._$AA = t22, this._$AB = i32, this._$AM = s22, this.options = e42, this.v = e42?.isConnected ?? true;
  }
  get parentNode() {
    let t22 = this._$AA.parentNode;
    const i32 = this._$AM;
    return void 0 !== i32 && 11 === t22?.nodeType && (t22 = i32.parentNode), t22;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t22, i32 = this) {
    t22 = z2(this, t22, i32), st2(t22) ? t22 === D2 || null == t22 || "" === t22 ? (this._$AH !== D2 && this._$AR(), this._$AH = D2) : t22 !== this._$AH && t22 !== R2 && this._(t22) : void 0 !== t22._$litType$ ? this.$(t22) : void 0 !== t22.nodeType ? this.T(t22) : $2(t22) ? this.k(t22) : this._(t22);
  }
  O(t22) {
    return this._$AA.parentNode.insertBefore(t22, this._$AB);
  }
  T(t22) {
    this._$AH !== t22 && (this._$AR(), this._$AH = this.O(t22));
  }
  _(t22) {
    this._$AH !== D2 && st2(this._$AH) ? this._$AA.nextSibling.data = t22 : this.T(w2.createTextNode(t22)), this._$AH = t22;
  }
  $(t22) {
    const { values: i32, _$litType$: s22 } = t22, e42 = "number" == typeof s22 ? this._$AC(t22) : (void 0 === s22.el && (s22.el = B2.createElement(N2(s22.h, s22.h[0]), this.options)), s22);
    if (this._$AH?._$AD === e42) this._$AH.p(i32);
    else {
      const t32 = new F2(e42, this), s32 = t32.u(this.options);
      t32.p(i32), this.T(s32), this._$AH = t32;
    }
  }
  _$AC(t22) {
    let i32 = V2.get(t22.strings);
    return void 0 === i32 && V2.set(t22.strings, i32 = new B2(t22)), i32;
  }
  k(t22) {
    g2(this._$AH) || (this._$AH = [], this._$AR());
    const i32 = this._$AH;
    let s22, e42 = 0;
    for (const h42 of t22) e42 === i32.length ? i32.push(s22 = new _et(this.O(lt2()), this.O(lt2()), this, this.options)) : s22 = i32[e42], s22._$AI(h42), e42++;
    e42 < i32.length && (this._$AR(s22 && s22._$AB.nextSibling, e42), i32.length = e42);
  }
  _$AR(t22 = this._$AA.nextSibling, i32) {
    for (this._$AP?.(false, true, i32); t22 && t22 !== this._$AB; ) {
      const i42 = t22.nextSibling;
      t22.remove(), t22 = i42;
    }
  }
  setConnected(t22) {
    void 0 === this._$AM && (this.v = t22, this._$AP?.(t22));
  }
};
var G2 = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t22, i32, s22, e42, h42) {
    this.type = 1, this._$AH = D2, this._$AN = void 0, this.element = t22, this.name = i32, this._$AM = e42, this.options = h42, s22.length > 2 || "" !== s22[0] || "" !== s22[1] ? (this._$AH = Array(s22.length - 1).fill(new String()), this.strings = s22) : this._$AH = D2;
  }
  _$AI(t22, i32 = this, s22, e42) {
    const h42 = this.strings;
    let o42 = false;
    if (void 0 === h42) t22 = z2(this, t22, i32, 0), o42 = !st2(t22) || t22 !== this._$AH && t22 !== R2, o42 && (this._$AH = t22);
    else {
      const e52 = t22;
      let n52, r42;
      for (t22 = h42[0], n52 = 0; n52 < h42.length - 1; n52++) r42 = z2(this, e52[s22 + n52], i32, n52), r42 === R2 && (r42 = this._$AH[n52]), o42 ||= !st2(r42) || r42 !== this._$AH[n52], r42 === D2 ? t22 = D2 : t22 !== D2 && (t22 += (r42 ?? "") + h42[n52 + 1]), this._$AH[n52] = r42;
    }
    o42 && !e42 && this.j(t22);
  }
  j(t22) {
    t22 === D2 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t22 ?? "");
  }
};
var Y2 = class extends G2 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t22) {
    this.element[this.name] = t22 === D2 ? void 0 : t22;
  }
};
var Z2 = class extends G2 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t22) {
    this.element.toggleAttribute(this.name, !!t22 && t22 !== D2);
  }
};
var q2 = class extends G2 {
  constructor(t22, i32, s22, e42, h42) {
    super(t22, i32, s22, e42, h42), this.type = 5;
  }
  _$AI(t22, i32 = this) {
    if ((t22 = z2(this, t22, i32, 0) ?? D2) === R2) return;
    const s22 = this._$AH, e42 = t22 === D2 && s22 !== D2 || t22.capture !== s22.capture || t22.once !== s22.once || t22.passive !== s22.passive, h42 = t22 !== D2 && (s22 === D2 || e42);
    e42 && this.element.removeEventListener(this.name, this, s22), h42 && this.element.addEventListener(this.name, this, t22), this._$AH = t22;
  }
  handleEvent(t22) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t22) : this._$AH.handleEvent(t22);
  }
};
var K2 = class {
  constructor(t22, i32, s22) {
    this.element = t22, this.type = 6, this._$AN = void 0, this._$AM = i32, this.options = s22;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t22) {
    z2(this, t22);
  }
};
var Re2 = n32.litHtmlPolyfillSupport;
Re2?.(B2, et2), (n32.litHtmlVersions ??= []).push("3.2.0");
var Q2 = (t22, i32, s22) => {
  const e42 = s22?.renderBefore ?? i32;
  let h42 = e42._$litPart$;
  if (void 0 === h42) {
    const t32 = s22?.renderBefore ?? null;
    e42._$litPart$ = h42 = new et2(i32.insertBefore(lt2(), t32), t32, void 0, s22 ?? {});
  }
  return h42._$AI(t22), h42;
};
var h32 = class extends b2 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    const t22 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t22.firstChild, t22;
  }
  update(t22) {
    const e42 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t22), this.o = Q2(e42, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this.o?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.o?.setConnected(false);
  }
  render() {
    return R2;
  }
};
h32._$litElement$ = true, h32["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h32 });
var f32 = globalThis.litElementPolyfillSupport;
f32?.({ LitElement: h32 });
(globalThis.litElementVersions ??= []).push("4.1.0");
var o32 = { attribute: true, type: String, converter: u2, reflect: false, hasChanged: f4 };
var r32 = (t22 = o32, e42, r42) => {
  const { kind: n52, metadata: i32 } = r42;
  let s22 = globalThis.litPropertyMetadata.get(i32);
  if (void 0 === s22 && globalThis.litPropertyMetadata.set(i32, s22 = /* @__PURE__ */ new Map()), s22.set(r42.name, t22), "accessor" === n52) {
    const { name: o42 } = r42;
    return { set(r52) {
      const n62 = e42.get.call(this);
      e42.set.call(this, r52), this.requestUpdate(o42, n62, t22);
    }, init(e52) {
      return void 0 !== e52 && this.P(o42, void 0, t22), e52;
    } };
  }
  if ("setter" === n52) {
    const { name: o42 } = r42;
    return function(r52) {
      const n62 = this[o42];
      e42.call(this, r52), this.requestUpdate(o42, n62, t22);
    };
  }
  throw Error("Unsupported decorator location: " + n52);
};
function n42(t22) {
  return (e42, o42) => "object" == typeof o42 ? r32(t22, e42, o42) : ((t32, e52, o52) => {
    const r42 = e52.hasOwnProperty(o52);
    return e52.constructor.createProperty(o52, r42 ? { ...t32, wrapped: true } : t32), r42 ? Object.getOwnPropertyDescriptor(e52, o52) : void 0;
  })(t22, e42, o42);
}
var appliedClassMixins = /* @__PURE__ */ new WeakMap();
function wasMixinPreviouslyApplied(mixin, superClass) {
  let klass = superClass;
  while (klass) {
    if (appliedClassMixins.get(klass) === mixin) {
      return true;
    }
    klass = Object.getPrototypeOf(klass);
  }
  return false;
}
function dedupeMixin(mixin) {
  return (superClass) => {
    if (wasMixinPreviouslyApplied(mixin, superClass)) {
      return superClass;
    }
    const mixedClass = mixin(superClass);
    appliedClassMixins.set(mixedClass, mixin);
    return mixedClass;
  };
}
var version = "3.0.0";
var versions = window.scopedElementsVersions || (window.scopedElementsVersions = []);
if (!versions.includes(version)) {
  versions.push(version);
}
var ScopedElementsMixinImplementation = (superclass) => (
  /** @type {ScopedElementsHost} */
  class ScopedElementsHost extends superclass {
    /**
     * Obtains the scoped elements definitions map if specified.
     *
     * @type {ScopedElementsMap=}
     */
    static scopedElements;
    static get scopedElementsVersion() {
      return version;
    }
    /** @type {CustomElementRegistry=} */
    static __registry;
    /**
     * Obtains the CustomElementRegistry associated to the ShadowRoot.
     *
     * @returns {CustomElementRegistry=}
     */
    get registry() {
      return (
        /** @type {typeof ScopedElementsHost} */
        this.constructor.__registry
      );
    }
    /**
     * Set the CustomElementRegistry associated to the ShadowRoot
     *
     * @param {CustomElementRegistry} registry
     */
    set registry(registry2) {
      this.constructor.__registry = registry2;
    }
    /**
     * @param {ShadowRootInit} options
     * @returns {ShadowRoot}
     */
    attachShadow(options) {
      const { scopedElements } = (
        /** @type {typeof ScopedElementsHost} */
        this.constructor
      );
      const shouldCreateRegistry = !this.registry || // @ts-ignore
      this.registry === this.constructor.__registry && !Object.prototype.hasOwnProperty.call(this.constructor, "__registry");
      if (shouldCreateRegistry) {
        this.registry = new CustomElementRegistry();
        for (const [tagName, klass] of Object.entries(scopedElements ?? {})) {
          this.registry.define(tagName, klass);
        }
      }
      return super.attachShadow({
        ...options,
        // The polyfill currently expects the registry to be passed as `customElements`
        customElements: this.registry,
        // But the proposal has moved forward, and renamed it to `registry`
        // For backwards compatibility, we pass it as both
        registry: this.registry
      });
    }
  }
);
var ScopedElementsMixin = dedupeMixin(ScopedElementsMixinImplementation);
var ScopedElementsMixinImplementation2 = (superclass) => (
  /** @type {ScopedElementsHost} */
  class ScopedElementsHost extends ScopedElementsMixin(superclass) {
    createRenderRoot() {
      const { shadowRootOptions, elementStyles } = (
        /** @type {TypeofLitElement} */
        this.constructor
      );
      const shadowRoot = this.attachShadow(shadowRootOptions);
      this.renderOptions.creationScope = shadowRoot;
      S3(shadowRoot, elementStyles);
      this.renderOptions.renderBefore ??= shadowRoot.firstChild;
      return shadowRoot;
    }
  }
);
var ScopedElementsMixin2 = dedupeMixin(ScopedElementsMixinImplementation2);
var _lang_dec;
var _contentEditable_dec;
var _a;
var _init;
var _contentEditable;
var _lang;
var LitElementWw = class extends (_a = ScopedElementsMixin2(h32), _contentEditable_dec = [n42({ type: String, attribute: true, reflect: true })], _lang_dec = [n42({ type: String, attribute: true, reflect: true })], _a) {
  constructor() {
    super(...arguments);
    __publicField2(this, "options");
    __publicField2(this, "actions", {});
    __privateAdd2(this, _contentEditable, __runInitializers2(_init, 8, this)), __runInitializers2(_init, 11, this);
    __privateAdd2(this, _lang, __runInitializers2(_init, 12, this)), __runInitializers2(_init, 15, this);
    __publicField2(this, "_inTransaction", false);
  }
  connectedCallback() {
    super.connectedCallback();
    this.getAttributeNames().forEach((k22) => this.setAttribute(k22, this.getAttribute(k22)));
  }
};
_init = __decoratorStart2(_a);
_contentEditable = /* @__PURE__ */ new WeakMap();
_lang = /* @__PURE__ */ new WeakMap();
__decorateElement2(_init, 4, "contentEditable", _contentEditable_dec, LitElementWw, _contentEditable);
__decorateElement2(_init, 4, "lang", _lang_dec, LitElementWw, _lang);
__decoratorMetadata2(_init, LitElementWw);
__publicField2(LitElementWw, "shadowRootOptions", { ...h32.shadowRootOptions });
__publicField2(LitElementWw, "options", {});
__publicField2(LitElementWw, "actions", {});

// src/node_modules/@lit/reactive-element/decorators/custom-element.js
var t4 = (t8) => (e10, o7) => {
  void 0 !== o7 ? o7.addInitializer(() => {
    customElements.define(t8, e10);
  }) : customElements.define(t8, e10);
};

// src/node_modules/@lit/reactive-element/decorators/property.js
var o4 = { attribute: true, type: String, converter: u, reflect: false, hasChanged: f };
var r4 = (t8 = o4, e10, r9) => {
  const { kind: n7, metadata: i5 } = r9;
  let s6 = globalThis.litPropertyMetadata.get(i5);
  if (void 0 === s6 && globalThis.litPropertyMetadata.set(i5, s6 = /* @__PURE__ */ new Map()), s6.set(r9.name, t8), "accessor" === n7) {
    const { name: o7 } = r9;
    return { set(r10) {
      const n8 = e10.get.call(this);
      e10.set.call(this, r10), this.requestUpdate(o7, n8, t8);
    }, init(e11) {
      return void 0 !== e11 && this.P(o7, void 0, t8), e11;
    } };
  }
  if ("setter" === n7) {
    const { name: o7 } = r9;
    return function(r10) {
      const n8 = this[o7];
      e10.call(this, r10), this.requestUpdate(o7, n8, t8);
    };
  }
  throw Error("Unsupported decorator location: " + n7);
};
function n6(t8) {
  return (e10, o7) => "object" == typeof o7 ? r4(t8, e10, o7) : ((t9, e11, o8) => {
    const r9 = e11.hasOwnProperty(o8);
    return e11.constructor.createProperty(o8, r9 ? { ...t9, wrapped: true } : t9), r9 ? Object.getOwnPropertyDescriptor(e11, o8) : void 0;
  })(t8, e10, o7);
}

// src/node_modules/@lit/reactive-element/decorators/state.js
function r5(r9) {
  return n6({ ...r9, state: true, attribute: false });
}

// src/node_modules/@lit/reactive-element/decorators/event-options.js
function t5(t8) {
  return (n7, o7) => {
    const c6 = "function" == typeof n7 ? n7 : n7[o7];
    Object.assign(c6, t8);
  };
}

// src/node_modules/@lit/reactive-element/decorators/base.js
var e6 = (e10, t8, c6) => (c6.configurable = true, c6.enumerable = true, Reflect.decorate && "object" != typeof t8 && Object.defineProperty(e10, t8, c6), c6);

// src/node_modules/@lit/reactive-element/decorators/query.js
function e7(e10, r9) {
  return (n7, s6, i5) => {
    const o7 = (t8) => t8.renderRoot?.querySelector(e10) ?? null;
    if (r9) {
      const { get: e11, set: r10 } = "object" == typeof s6 ? n7 : i5 ?? (() => {
        const t8 = Symbol();
        return { get() {
          return this[t8];
        }, set(e12) {
          this[t8] = e12;
        } };
      })();
      return e6(n7, s6, { get() {
        let t8 = e11.call(this);
        return void 0 === t8 && (t8 = o7(this), (null !== t8 || this.hasUpdated) && r10.call(this, t8)), t8;
      } });
    }
    return e6(n7, s6, { get() {
      return o7(this);
    } });
  };
}

// src/node_modules/@lit/reactive-element/decorators/query-all.js
var e8;
function r6(r9) {
  return (n7, o7) => e6(n7, o7, { get() {
    return (this.renderRoot ?? (e8 ??= document.createDocumentFragment())).querySelectorAll(r9);
  } });
}

// src/node_modules/@lit/reactive-element/decorators/query-async.js
function r7(r9) {
  return (n7, e10) => e6(n7, e10, { async get() {
    return await this.updateComplete, this.renderRoot?.querySelector(r9) ?? null;
  } });
}

// src/node_modules/@lit/reactive-element/decorators/query-assigned-elements.js
function o5(o7) {
  return (e10, n7) => {
    const { slot: r9, selector: s6 } = o7 ?? {}, c6 = "slot" + (r9 ? `[name=${r9}]` : ":not([name])");
    return e6(e10, n7, { get() {
      const t8 = this.renderRoot?.querySelector(c6), e11 = t8?.assignedElements(o7) ?? [];
      return void 0 === s6 ? e11 : e11.filter((t9) => t9.matches(s6));
    } });
  };
}

// src/components/node-detail-view/page-node-detail-view/page-node-detail-view.styles.ts
var page_node_detail_view_styles_default = i`
  :host {
    /* height: 100%; */
  }

  :host * {
    box-sizing: border-box;
  }

  .page-node-detail-view {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;

    background-color: #fbfbfb;
    padding: 10px;
  }

  .preview {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;

    width: 100%;
    height: 100%;

    background: #fbfbfb;

    box-sizing: border-box;
  }

  .page {
    background-color: white;
    box-sizing: border-box;
    border: 1px solid #d4d4d8;
    width: 100%;

    height: auto;
    min-height: 400px;
    color: black;

    /* box-shadow: 0 2px 20px 2px #d0d0d0; */
  }

  .gamebookTitle {
    font-weight: 600;
    background-color: #f7f7f7;
    box-sizing: border-box;

    padding-top: 10px;
    padding-left: 10px;
    padding-bottom: 10px;

    height: auto;

    display: flex;
    align-items: center; /* Vertically center */
    justify-content: flex-start; /* Horizontally align at the start */

    width: 100%;
  }

  .pageTitle {
    font-size: 14px;

    background-color: #f7f7f7;

    height: auto;
    display: flex;
    align-items: center; /* Vertically center */
    justify-content: flex-start; /* Horizontally align at the start */
    box-sizing: border-box;

    width: 100%; /* Adjust width to account for padding */
    padding-left: 10px;
    padding-bottom: 10px;
  }

  .title-bar {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    justify-items: center;
    gap: 15px;

    width: 100%;
    height: 150px;
    padding: 20px;

    background-color: white;

    box-sizing: border-box;
  }

  .div-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    height: 65px; /* Remove the fixed height */
    aspect-ratio: 1;
    background-color: #3077ba;
  }

  .div-icon sl-icon {
    width: 42px;
    height: 42px;
    color: white;
  }

  .div-title {
    display: flex;
    flex-direction: column;
    gap: 5px;
  }

  .title {
    font-size: 16px;
    font-weight: bold;
    color: #3077ba;
    margin: 0px;
  }

  .subtitle {
    font-size: 12px;
    color: gray;
    margin: 0px;
    padding: 0px;
  }

  .number {
    font-size: 14px;
    color: black;
    margin: 0px;
  }

  .last-item {
    display: flex;
    flex-direction: row;
    align-items: center;
    margin-left: auto;
  }

  .control-node {
    display: flex;
    flex-direction: column;
    height: 120px;
    justify-content: left;
    align-items: left;
  }

  .horizontal {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 10px;
    border-bottom: 1px solid #d4d4d8;
  }

  .icon-button {
    margin: 0;
  }

  .horizontalStack {
    display: flex;
    flex-direction: column;
    height: 80px;
    width: 150px;
    overflow-y: auto;
    padding-right: 10px;
  }

  .horizontalStack::-webkit-scrollbar {
    width: 6px; /* Width of the vertical scrollbar */
  }

  .horizontalStack::-webkit-scrollbar-thumb {
    background-color: darkgrey; /* Color of the scrollbar thumb */
    border-radius: 10px; /* Roundness of the scrollbar thumb */
  }

  .horizontalStack::-webkit-scrollbar-track {
    background: none; /* Color of the scrollbar track */
  }

  .horizontalStack p {
    padding: 0px;
    margin: 0px;
    font-size: 12px;
  }

  .title-bar {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    justify-items: center;

    box-sizing: border-box;
    width: 100%;
    height: 150px;

    gap: 15px;
    padding: 15px;

    background-color: white;
    border-bottom: 1px solid #d4d4d8;
    /* 
    border-top-left-radius: 8px;
    border-top-right-radius: 8px; */
  }

  .inputOutputControls {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    justify-items: center;
  }

  node-connection-list {
    height: 100%; /* Adjust as needed */
    flex: 1; /* This makes the node-connection-list elements take up remaining space evenly */
  }

  .div-title {
    display: flex;
    flex-direction: column;
  }

  .subtitle {
    font-size: 12px;
    color: gray;
    margin: 0px;
    padding: 0px;
  }

  .div-icon-popup {
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    height: 65px; /* Remove the fixed height */
    aspect-ratio: 1;
    background-color: #9762b4;
  }

  .div-icon-page {
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    height: 65px; /* Remove the fixed height */
    aspect-ratio: 1;
    background-color: #3077ba;
  }

  .div-icon-branch {
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    height: 65px; /* Remove the fixed height */
    aspect-ratio: 1;
    background-color: #05ae9e;
  }

  .div-icon-popup sl-icon,
  .div-icon-page sl-icon,
  .div-icon-branch sl-icon {
    width: 42px;
    height: 42px;
    color: white;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.IFDWM6P4.js
var __defProp3 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol3 = (name, symbol) => {
  return (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
};
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a3, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp2.call(b3, prop))
      __defNormalProp3(a3, prop, b3[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b3)) {
      if (__propIsEnum.call(b3, prop))
        __defNormalProp3(a3, prop, b3[prop]);
    }
  return a3;
};
var __spreadProps = (a3, b3) => __defProps(a3, __getOwnPropDescs(b3));
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc3(target, key) : target;
  for (var i5 = decorators.length - 1, decorator; i5 >= 0; i5--)
    if (decorator = decorators[i5])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp3(target, key, result);
  return result;
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol3("asyncIterator")];
  var isAwait = false;
  var method;
  var it = {};
  if (obj == null) {
    obj = value[__knownSymbol3("iterator")]();
    method = (k3) => it[k3] = (x4) => obj[k3](x4);
  } else {
    obj = obj.call(value);
    method = (k3) => it[k3] = (v3) => {
      if (isAwait) {
        isAwait = false;
        if (k3 === "throw")
          throw v3;
        return v3;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x4 = obj[k3](v3);
          if (!(x4 instanceof Object))
            throw TypeError("Object expected");
          resolve(x4);
        }), 1)
      };
    };
  }
  return it[__knownSymbol3("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x4) => {
    throw x4;
  }, "return" in obj && method("return"), it;
};

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.KWPBDQ6I.js
var formCollections = /* @__PURE__ */ new WeakMap();
var reportValidityOverloads = /* @__PURE__ */ new WeakMap();
var checkValidityOverloads = /* @__PURE__ */ new WeakMap();
var userInteractedControls = /* @__PURE__ */ new WeakSet();
var interactions = /* @__PURE__ */ new WeakMap();
var FormControlController = class {
  constructor(host, options) {
    this.handleFormData = (event) => {
      const disabled = this.options.disabled(this.host);
      const name = this.options.name(this.host);
      const value = this.options.value(this.host);
      const isButton = this.host.tagName.toLowerCase() === "sl-button";
      if (this.host.isConnected && !disabled && !isButton && typeof name === "string" && name.length > 0 && typeof value !== "undefined") {
        if (Array.isArray(value)) {
          value.forEach((val) => {
            event.formData.append(name, val.toString());
          });
        } else {
          event.formData.append(name, value.toString());
        }
      }
    };
    this.handleFormSubmit = (event) => {
      var _a24;
      const disabled = this.options.disabled(this.host);
      const reportValidity = this.options.reportValidity;
      if (this.form && !this.form.noValidate) {
        (_a24 = formCollections.get(this.form)) == null ? void 0 : _a24.forEach((control) => {
          this.setUserInteracted(control, true);
        });
      }
      if (this.form && !this.form.noValidate && !disabled && !reportValidity(this.host)) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
    this.handleFormReset = () => {
      this.options.setValue(this.host, this.options.defaultValue(this.host));
      this.setUserInteracted(this.host, false);
      interactions.set(this.host, []);
    };
    this.handleInteraction = (event) => {
      const emittedEvents = interactions.get(this.host);
      if (!emittedEvents.includes(event.type)) {
        emittedEvents.push(event.type);
      }
      if (emittedEvents.length === this.options.assumeInteractionOn.length) {
        this.setUserInteracted(this.host, true);
      }
    };
    this.checkFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.checkValidity === "function") {
            if (!element.checkValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    this.reportFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.reportValidity === "function") {
            if (!element.reportValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    (this.host = host).addController(this);
    this.options = __spreadValues({
      form: (input) => {
        const formId = input.form;
        if (formId) {
          const root = input.getRootNode();
          const form = root.querySelector(`#${formId}`);
          if (form) {
            return form;
          }
        }
        return input.closest("form");
      },
      name: (input) => input.name,
      value: (input) => input.value,
      defaultValue: (input) => input.defaultValue,
      disabled: (input) => {
        var _a24;
        return (_a24 = input.disabled) != null ? _a24 : false;
      },
      reportValidity: (input) => typeof input.reportValidity === "function" ? input.reportValidity() : true,
      checkValidity: (input) => typeof input.checkValidity === "function" ? input.checkValidity() : true,
      setValue: (input, value) => input.value = value,
      assumeInteractionOn: ["sl-input"]
    }, options);
  }
  hostConnected() {
    const form = this.options.form(this.host);
    if (form) {
      this.attachForm(form);
    }
    interactions.set(this.host, []);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.addEventListener(event, this.handleInteraction);
    });
  }
  hostDisconnected() {
    this.detachForm();
    interactions.delete(this.host);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.removeEventListener(event, this.handleInteraction);
    });
  }
  hostUpdated() {
    const form = this.options.form(this.host);
    if (!form) {
      this.detachForm();
    }
    if (form && this.form !== form) {
      this.detachForm();
      this.attachForm(form);
    }
    if (this.host.hasUpdated) {
      this.setValidity(this.host.validity.valid);
    }
  }
  attachForm(form) {
    if (form) {
      this.form = form;
      if (formCollections.has(this.form)) {
        formCollections.get(this.form).add(this.host);
      } else {
        formCollections.set(this.form, /* @__PURE__ */ new Set([this.host]));
      }
      this.form.addEventListener("formdata", this.handleFormData);
      this.form.addEventListener("submit", this.handleFormSubmit);
      this.form.addEventListener("reset", this.handleFormReset);
      if (!reportValidityOverloads.has(this.form)) {
        reportValidityOverloads.set(this.form, this.form.reportValidity);
        this.form.reportValidity = () => this.reportFormValidity();
      }
      if (!checkValidityOverloads.has(this.form)) {
        checkValidityOverloads.set(this.form, this.form.checkValidity);
        this.form.checkValidity = () => this.checkFormValidity();
      }
    } else {
      this.form = void 0;
    }
  }
  detachForm() {
    if (!this.form)
      return;
    const formCollection = formCollections.get(this.form);
    if (!formCollection) {
      return;
    }
    formCollection.delete(this.host);
    if (formCollection.size <= 0) {
      this.form.removeEventListener("formdata", this.handleFormData);
      this.form.removeEventListener("submit", this.handleFormSubmit);
      this.form.removeEventListener("reset", this.handleFormReset);
      if (reportValidityOverloads.has(this.form)) {
        this.form.reportValidity = reportValidityOverloads.get(this.form);
        reportValidityOverloads.delete(this.form);
      }
      if (checkValidityOverloads.has(this.form)) {
        this.form.checkValidity = checkValidityOverloads.get(this.form);
        checkValidityOverloads.delete(this.form);
      }
      this.form = void 0;
    }
  }
  setUserInteracted(el, hasInteracted) {
    if (hasInteracted) {
      userInteractedControls.add(el);
    } else {
      userInteractedControls.delete(el);
    }
    el.requestUpdate();
  }
  doAction(type, submitter) {
    if (this.form) {
      const button = document.createElement("button");
      button.type = type;
      button.style.position = "absolute";
      button.style.width = "0";
      button.style.height = "0";
      button.style.clipPath = "inset(50%)";
      button.style.overflow = "hidden";
      button.style.whiteSpace = "nowrap";
      if (submitter) {
        button.name = submitter.name;
        button.value = submitter.value;
        ["formaction", "formenctype", "formmethod", "formnovalidate", "formtarget"].forEach((attr) => {
          if (submitter.hasAttribute(attr)) {
            button.setAttribute(attr, submitter.getAttribute(attr));
          }
        });
      }
      this.form.append(button);
      button.click();
      button.remove();
    }
  }
  /** Returns the associated `<form>` element, if one exists. */
  getForm() {
    var _a24;
    return (_a24 = this.form) != null ? _a24 : null;
  }
  /** Resets the form, restoring all the control to their default value */
  reset(submitter) {
    this.doAction("reset", submitter);
  }
  /** Submits the form, triggering validation and form data injection. */
  submit(submitter) {
    this.doAction("submit", submitter);
  }
  /**
   * Synchronously sets the form control's validity. Call this when you know the future validity but need to update
   * the host element immediately, i.e. before Lit updates the component in the next update.
   */
  setValidity(isValid) {
    const host = this.host;
    const hasInteracted = Boolean(userInteractedControls.has(host));
    const required = Boolean(host.required);
    host.toggleAttribute("data-required", required);
    host.toggleAttribute("data-optional", !required);
    host.toggleAttribute("data-invalid", !isValid);
    host.toggleAttribute("data-valid", isValid);
    host.toggleAttribute("data-user-invalid", !isValid && hasInteracted);
    host.toggleAttribute("data-user-valid", isValid && hasInteracted);
  }
  /**
   * Updates the form control's validity based on the current value of `host.validity.valid`. Call this when anything
   * that affects constraint validation changes so the component receives the correct validity states.
   */
  updateValidity() {
    const host = this.host;
    this.setValidity(host.validity.valid);
  }
  /**
   * Dispatches a non-bubbling, cancelable custom event of type `sl-invalid`.
   * If the `sl-invalid` event will be cancelled then the original `invalid`
   * event (which may have been passed as argument) will also be cancelled.
   * If no original `invalid` event has been passed then the `sl-invalid`
   * event will be cancelled before being dispatched.
   */
  emitInvalidEvent(originalInvalidEvent) {
    const slInvalidEvent = new CustomEvent("sl-invalid", {
      bubbles: false,
      composed: false,
      cancelable: true,
      detail: {}
    });
    if (!originalInvalidEvent) {
      slInvalidEvent.preventDefault();
    }
    if (!this.host.dispatchEvent(slInvalidEvent)) {
      originalInvalidEvent == null ? void 0 : originalInvalidEvent.preventDefault();
    }
  }
};
var validValidityState = Object.freeze({
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valid: true,
  valueMissing: false
});
var valueMissingValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
  valid: false,
  valueMissing: true
}));
var customErrorValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
  valid: false,
  customError: true
}));

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.YKKSQ2FG.js
var visually_hidden_styles_default = i`
  :host(:not(:focus-within)) {
    position: absolute !important;
    width: 1px !important;
    height: 1px !important;
    clip: rect(0 0 0 0) !important;
    clip-path: inset(50%) !important;
    border: none !important;
    overflow: hidden !important;
    white-space: nowrap !important;
    padding: 0 !important;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TUVJKY7S.js
var component_styles_default = i`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SFSTXCXC.js
var ShoelaceElement = class extends h3 {
  constructor() {
    super();
    Object.entries(this.constructor.dependencies).forEach(([name, component]) => {
      this.constructor.define(name, component);
    });
  }
  emit(name, options) {
    const event = new CustomEvent(name, __spreadValues({
      bubbles: true,
      cancelable: false,
      composed: true,
      detail: {}
    }, options));
    this.dispatchEvent(event);
    return event;
  }
  /* eslint-enable */
  static define(name, elementConstructor = this, options = {}) {
    const currentlyRegisteredConstructor = customElements.get(name);
    if (!currentlyRegisteredConstructor) {
      customElements.define(name, class extends elementConstructor {
      }, options);
      return;
    }
    let newVersion = " (unknown version)";
    let existingVersion = newVersion;
    if ("version" in elementConstructor && elementConstructor.version) {
      newVersion = " v" + elementConstructor.version;
    }
    if ("version" in currentlyRegisteredConstructor && currentlyRegisteredConstructor.version) {
      existingVersion = " v" + currentlyRegisteredConstructor.version;
    }
    if (newVersion && existingVersion && newVersion === existingVersion) {
      return;
    }
    console.warn(
      `Attempted to register <${name}>${newVersion}, but <${name}>${existingVersion} has already been registered.`
    );
  }
};
ShoelaceElement.version = "2.15.0";
ShoelaceElement.dependencies = {};
__decorateClass([
  n6()
], ShoelaceElement.prototype, "dir", 2);
__decorateClass([
  n6()
], ShoelaceElement.prototype, "lang", 2);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.I5QLEZCX.js
var SlVisuallyHidden = class extends ShoelaceElement {
  render() {
    return ke` <slot></slot> `;
  }
};
SlVisuallyHidden.styles = [component_styles_default, visually_hidden_styles_default];

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LEWWON6R.js
SlVisuallyHidden.define("sl-visually-hidden");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.BCNEWSXW.js
var tooltip_styles_default = i`
  :host {
    --max-width: 20rem;
    --hide-delay: 0ms;
    --show-delay: 150ms;

    display: contents;
  }

  .tooltip {
    --arrow-size: var(--sl-tooltip-arrow-size);
    --arrow-color: var(--sl-tooltip-background-color);
  }

  .tooltip::part(popup) {
    z-index: var(--sl-z-index-tooltip);
  }

  .tooltip[placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .tooltip[placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .tooltip[placement^='left']::part(popup) {
    transform-origin: right;
  }

  .tooltip[placement^='right']::part(popup) {
    transform-origin: left;
  }

  .tooltip__body {
    display: block;
    width: max-content;
    max-width: var(--max-width);
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    color: var(--sl-tooltip-color);
    padding: var(--sl-tooltip-padding);
    pointer-events: none;
    user-select: none;
    -webkit-user-select: none;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3KSWVBQ5.js
var popup_styles_default = i`
  :host {
    --arrow-color: var(--sl-color-neutral-1000);
    --arrow-size: 6px;

    /*
     * These properties are computed to account for the arrow's dimensions after being rotated 45º. The constant
     * 0.7071 is derived from sin(45), which is the diagonal size of the arrow's container after rotating.
     */
    --arrow-size-diagonal: calc(var(--arrow-size) * 0.7071);
    --arrow-padding-offset: calc(var(--arrow-size-diagonal) - var(--arrow-size));

    display: contents;
  }

  .popup {
    position: absolute;
    isolation: isolate;
    max-width: var(--auto-size-available-width, none);
    max-height: var(--auto-size-available-height, none);
  }

  .popup--fixed {
    position: fixed;
  }

  .popup:not(.popup--active) {
    display: none;
  }

  .popup__arrow {
    position: absolute;
    width: calc(var(--arrow-size-diagonal) * 2);
    height: calc(var(--arrow-size-diagonal) * 2);
    rotate: 45deg;
    background: var(--arrow-color);
    z-index: -1;
  }

  /* Hover bridge */
  .popup-hover-bridge:not(.popup-hover-bridge--visible) {
    display: none;
  }

  .popup-hover-bridge {
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--hover-bridge-top-left-x, 0) var(--hover-bridge-top-left-y, 0),
      var(--hover-bridge-top-right-x, 0) var(--hover-bridge-top-right-y, 0),
      var(--hover-bridge-bottom-right-x, 0) var(--hover-bridge-bottom-right-y, 0),
      var(--hover-bridge-bottom-left-x, 0) var(--hover-bridge-bottom-left-y, 0)
    );
  }
`;

// src/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v3) => ({
  x: v3,
  y: v3
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt2 = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt2;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x4,
    y: y3,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y3,
    left: x4,
    right: x4 + width,
    bottom: y3 + height,
    x: x4,
    y: y3
  };
}

// src/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x4,
    y: y3
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i5 = 0; i5 < validMiddleware.length; i5++) {
    const {
      name,
      fn
    } = validMiddleware[i5];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x4,
      y: y3,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x4 = nextX != null ? nextX : x4;
    y3 = nextY != null ? nextY : y3;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x4,
          y: y3
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i5 = -1;
    }
  }
  return {
    x: x4,
    y: y3,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state6, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x4,
    y: y3,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state6;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state6);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x4,
    y: y3,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state6) {
    const {
      x: x4,
      y: y3,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state6;
    const {
      element,
      padding = 0
    } = evaluate(options, state6) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x4,
      y: y3
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset3 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset3,
        centerOffset: center - offset3 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state6) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state6;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state6);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state6, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d3) => d3.overflows[0] <= 0).sort((a3, b3) => a3.overflows[1] - b3.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d3) => [d3.placement, d3.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a3, b3) => a3[1] - b3[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state6, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state6;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state6);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state6) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x4,
        y: y3,
        placement,
        middlewareData
      } = state6;
      const diffCoords = await convertValueToCoords(state6, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x4 + diffCoords.x,
        y: y3 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state6) {
      const {
        x: x4,
        y: y3,
        placement
      } = state6;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x5,
              y: y4
            } = _ref;
            return {
              x: x5,
              y: y4
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state6);
      const coords = {
        x: x4,
        y: y3
      };
      const overflow = await detectOverflow(state6, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state6,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x4,
          y: limitedCoords.y - y3
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state6) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state6;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state6);
      const overflow = await detectOverflow(state6, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state6.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state6,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// src/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css9 = getComputedStyle2(element);
  return css9.transform !== "none" || css9.perspective !== "none" || (css9.containerType ? css9.containerType !== "normal" : false) || !webkit && (css9.backdropFilter ? css9.backdropFilter !== "none" : false) || !webkit && (css9.filter ? css9.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css9.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css9.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

// src/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css9 = getComputedStyle2(element);
  let width = parseFloat(css9.width) || 0;
  let height = parseFloat(css9.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $3
  } = getCssDimensions(domElement);
  let x4 = ($3 ? round(rect.width) : rect.width) / width;
  let y3 = ($3 ? round(rect.height) : rect.height) / height;
  if (!x4 || !Number.isFinite(x4)) {
    x4 = 1;
  }
  if (!y3 || !Number.isFinite(y3)) {
    y3 = 1;
  }
  return {
    x: x4,
    y: y3
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x4 = (clientRect.left + visualOffsets.x) / scale.x;
  let y3 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = currentWin.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css9 = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css9.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css9.paddingTop)) * iframeScale.y;
      x4 *= iframeScale.x;
      y3 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x4 += left;
      y3 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x4,
    y: y3
  });
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (e10) {
      return false;
    }
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x4 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y3 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x4 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x4,
    y: y3
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x4 = 0;
  let y3 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x4 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x4,
    y: y3
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x4 = left * scale.x;
  const y3 = top * scale.y;
  return {
    width,
    height,
    x: x4,
    y: y3
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x4 = rect.left + scroll.scrollLeft - offsets.x;
  const y3 = rect.top + scroll.scrollTop - offsets.y;
  return {
    x: x4,
    y: y3,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e10) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update2, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update2, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update2();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update2();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var arrow2 = arrow;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// src/node_modules/lit-html/directive.js
var t6 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var e9 = (t8) => (...e10) => ({ _$litDirective$: t8, values: e10 });
var i4 = class {
  constructor(t8) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t8, e10, i5) {
    this.t = t8, this._$AM = e10, this.i = i5;
  }
  _$AS(t8, e10) {
    return this.update(t8, e10);
  }
  update(t8, e10) {
    return this.render(...e10);
  }
};

// src/node_modules/lit-html/directives/class-map.js
var Rt = e9(class extends i4 {
  constructor(s6) {
    if (super(s6), s6.type !== t6.ATTRIBUTE || "class" !== s6.name || s6.strings?.length > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t8) {
    return " " + Object.keys(t8).filter((s6) => t8[s6]).join(" ") + " ";
  }
  update(t8, [s6]) {
    if (void 0 === this.st) {
      this.st = /* @__PURE__ */ new Set(), void 0 !== t8.strings && (this.nt = new Set(t8.strings.join(" ").split(/\s/).filter((t9) => "" !== t9)));
      for (const t9 in s6) s6[t9] && !this.nt?.has(t9) && this.st.add(t9);
      return this.render(s6);
    }
    const i5 = t8.element.classList;
    for (const t9 of this.st) t9 in s6 || (i5.remove(t9), this.st.delete(t9));
    for (const t9 in s6) {
      const r9 = !!s6[t9];
      r9 === this.st.has(t9) || this.nt?.has(t9) || (r9 ? (i5.add(t9), this.st.add(t9)) : (i5.remove(t9), this.st.delete(t9)));
    }
    return R;
  }
});

// src/node_modules/composed-offset-position/dist/composed-offset-position.browser.min.mjs
function t7(t8) {
  return r8(t8);
}
function o6(t8) {
  return t8.assignedSlot ? t8.assignedSlot : t8.parentNode instanceof ShadowRoot ? t8.parentNode.host : t8.parentNode;
}
function r8(t8) {
  for (let e10 = t8; e10; e10 = o6(e10)) if (e10 instanceof Element && "none" === getComputedStyle(e10).display) return null;
  for (let e10 = o6(t8); e10; e10 = o6(e10)) {
    if (!(e10 instanceof Element)) continue;
    const t9 = getComputedStyle(e10);
    if ("contents" !== t9.display) {
      if ("static" !== t9.position || "none" !== t9.filter) return e10;
      if ("BODY" === e10.tagName) return e10;
    }
  }
  return null;
}

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SUWKRDXP.js
function isVirtualElement(e10) {
  return e10 !== null && typeof e10 === "object" && "getBoundingClientRect" in e10 && ("contextElement" in e10 ? e10 instanceof Element : true);
}
var SlPopup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.active = false;
    this.placement = "top";
    this.strategy = "absolute";
    this.distance = 0;
    this.skidding = 0;
    this.arrow = false;
    this.arrowPlacement = "anchor";
    this.arrowPadding = 10;
    this.flip = false;
    this.flipFallbackPlacements = "";
    this.flipFallbackStrategy = "best-fit";
    this.flipPadding = 0;
    this.shift = false;
    this.shiftPadding = 0;
    this.autoSizePadding = 0;
    this.hoverBridge = false;
    this.updateHoverBridge = () => {
      if (this.hoverBridge && this.anchorEl) {
        const anchorRect = this.anchorEl.getBoundingClientRect();
        const popupRect = this.popup.getBoundingClientRect();
        const isVertical = this.placement.includes("top") || this.placement.includes("bottom");
        let topLeftX = 0;
        let topLeftY = 0;
        let topRightX = 0;
        let topRightY = 0;
        let bottomLeftX = 0;
        let bottomLeftY = 0;
        let bottomRightX = 0;
        let bottomRightY = 0;
        if (isVertical) {
          if (anchorRect.top < popupRect.top) {
            topLeftX = anchorRect.left;
            topLeftY = anchorRect.bottom;
            topRightX = anchorRect.right;
            topRightY = anchorRect.bottom;
            bottomLeftX = popupRect.left;
            bottomLeftY = popupRect.top;
            bottomRightX = popupRect.right;
            bottomRightY = popupRect.top;
          } else {
            topLeftX = popupRect.left;
            topLeftY = popupRect.bottom;
            topRightX = popupRect.right;
            topRightY = popupRect.bottom;
            bottomLeftX = anchorRect.left;
            bottomLeftY = anchorRect.top;
            bottomRightX = anchorRect.right;
            bottomRightY = anchorRect.top;
          }
        } else {
          if (anchorRect.left < popupRect.left) {
            topLeftX = anchorRect.right;
            topLeftY = anchorRect.top;
            topRightX = popupRect.left;
            topRightY = popupRect.top;
            bottomLeftX = anchorRect.right;
            bottomLeftY = anchorRect.bottom;
            bottomRightX = popupRect.left;
            bottomRightY = popupRect.bottom;
          } else {
            topLeftX = popupRect.right;
            topLeftY = popupRect.top;
            topRightX = anchorRect.left;
            topRightY = anchorRect.top;
            bottomLeftX = popupRect.right;
            bottomLeftY = popupRect.bottom;
            bottomRightX = anchorRect.left;
            bottomRightY = anchorRect.bottom;
          }
        }
        this.style.setProperty("--hover-bridge-top-left-x", `${topLeftX}px`);
        this.style.setProperty("--hover-bridge-top-left-y", `${topLeftY}px`);
        this.style.setProperty("--hover-bridge-top-right-x", `${topRightX}px`);
        this.style.setProperty("--hover-bridge-top-right-y", `${topRightY}px`);
        this.style.setProperty("--hover-bridge-bottom-left-x", `${bottomLeftX}px`);
        this.style.setProperty("--hover-bridge-bottom-left-y", `${bottomLeftY}px`);
        this.style.setProperty("--hover-bridge-bottom-right-x", `${bottomRightX}px`);
        this.style.setProperty("--hover-bridge-bottom-right-y", `${bottomRightY}px`);
      }
    };
  }
  async connectedCallback() {
    super.connectedCallback();
    await this.updateComplete;
    this.start();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stop();
  }
  async updated(changedProps) {
    super.updated(changedProps);
    if (changedProps.has("active")) {
      if (this.active) {
        this.start();
      } else {
        this.stop();
      }
    }
    if (changedProps.has("anchor")) {
      this.handleAnchorChange();
    }
    if (this.active) {
      await this.updateComplete;
      this.reposition();
    }
  }
  async handleAnchorChange() {
    await this.stop();
    if (this.anchor && typeof this.anchor === "string") {
      const root = this.getRootNode();
      this.anchorEl = root.getElementById(this.anchor);
    } else if (this.anchor instanceof Element || isVirtualElement(this.anchor)) {
      this.anchorEl = this.anchor;
    } else {
      this.anchorEl = this.querySelector('[slot="anchor"]');
    }
    if (this.anchorEl instanceof HTMLSlotElement) {
      this.anchorEl = this.anchorEl.assignedElements({ flatten: true })[0];
    }
    if (this.anchorEl) {
      this.start();
    }
  }
  start() {
    if (!this.anchorEl) {
      return;
    }
    this.cleanup = autoUpdate(this.anchorEl, this.popup, () => {
      this.reposition();
    });
  }
  async stop() {
    return new Promise((resolve) => {
      if (this.cleanup) {
        this.cleanup();
        this.cleanup = void 0;
        this.removeAttribute("data-current-placement");
        this.style.removeProperty("--auto-size-available-width");
        this.style.removeProperty("--auto-size-available-height");
        requestAnimationFrame(() => resolve());
      } else {
        resolve();
      }
    });
  }
  /** Forces the popup to recalculate and reposition itself. */
  reposition() {
    if (!this.active || !this.anchorEl) {
      return;
    }
    const middleware = [
      // The offset middleware goes first
      offset2({ mainAxis: this.distance, crossAxis: this.skidding })
    ];
    if (this.sync) {
      middleware.push(
        size2({
          apply: ({ rects }) => {
            const syncWidth = this.sync === "width" || this.sync === "both";
            const syncHeight = this.sync === "height" || this.sync === "both";
            this.popup.style.width = syncWidth ? `${rects.reference.width}px` : "";
            this.popup.style.height = syncHeight ? `${rects.reference.height}px` : "";
          }
        })
      );
    } else {
      this.popup.style.width = "";
      this.popup.style.height = "";
    }
    if (this.flip) {
      middleware.push(
        flip2({
          boundary: this.flipBoundary,
          // @ts-expect-error - We're converting a string attribute to an array here
          fallbackPlacements: this.flipFallbackPlacements,
          fallbackStrategy: this.flipFallbackStrategy === "best-fit" ? "bestFit" : "initialPlacement",
          padding: this.flipPadding
        })
      );
    }
    if (this.shift) {
      middleware.push(
        shift2({
          boundary: this.shiftBoundary,
          padding: this.shiftPadding
        })
      );
    }
    if (this.autoSize) {
      middleware.push(
        size2({
          boundary: this.autoSizeBoundary,
          padding: this.autoSizePadding,
          apply: ({ availableWidth, availableHeight }) => {
            if (this.autoSize === "vertical" || this.autoSize === "both") {
              this.style.setProperty("--auto-size-available-height", `${availableHeight}px`);
            } else {
              this.style.removeProperty("--auto-size-available-height");
            }
            if (this.autoSize === "horizontal" || this.autoSize === "both") {
              this.style.setProperty("--auto-size-available-width", `${availableWidth}px`);
            } else {
              this.style.removeProperty("--auto-size-available-width");
            }
          }
        })
      );
    } else {
      this.style.removeProperty("--auto-size-available-width");
      this.style.removeProperty("--auto-size-available-height");
    }
    if (this.arrow) {
      middleware.push(
        arrow2({
          element: this.arrowEl,
          padding: this.arrowPadding
        })
      );
    }
    const getOffsetParent2 = this.strategy === "absolute" ? (element) => platform.getOffsetParent(element, t7) : platform.getOffsetParent;
    computePosition2(this.anchorEl, this.popup, {
      placement: this.placement,
      middleware,
      strategy: this.strategy,
      platform: __spreadProps(__spreadValues({}, platform), {
        getOffsetParent: getOffsetParent2
      })
    }).then(({ x: x4, y: y3, middlewareData, placement }) => {
      const isRtl = getComputedStyle(this).direction === "rtl";
      const staticSide = { top: "bottom", right: "left", bottom: "top", left: "right" }[placement.split("-")[0]];
      this.setAttribute("data-current-placement", placement);
      Object.assign(this.popup.style, {
        left: `${x4}px`,
        top: `${y3}px`
      });
      if (this.arrow) {
        const arrowX = middlewareData.arrow.x;
        const arrowY = middlewareData.arrow.y;
        let top = "";
        let right = "";
        let bottom = "";
        let left = "";
        if (this.arrowPlacement === "start") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          top = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? value : "";
          left = isRtl ? "" : value;
        } else if (this.arrowPlacement === "end") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? "" : value;
          left = isRtl ? value : "";
          bottom = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
        } else if (this.arrowPlacement === "center") {
          left = typeof arrowX === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
          top = typeof arrowY === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
        } else {
          left = typeof arrowX === "number" ? `${arrowX}px` : "";
          top = typeof arrowY === "number" ? `${arrowY}px` : "";
        }
        Object.assign(this.arrowEl.style, {
          top,
          right,
          bottom,
          left,
          [staticSide]: "calc(var(--arrow-size-diagonal) * -1)"
        });
      }
    });
    requestAnimationFrame(() => this.updateHoverBridge());
    this.emit("sl-reposition");
  }
  render() {
    return ke`
      <slot name="anchor" @slotchange=${this.handleAnchorChange}></slot>

      <span
        part="hover-bridge"
        class=${Rt({
      "popup-hover-bridge": true,
      "popup-hover-bridge--visible": this.hoverBridge && this.active
    })}
      ></span>

      <div
        part="popup"
        class=${Rt({
      popup: true,
      "popup--active": this.active,
      "popup--fixed": this.strategy === "fixed",
      "popup--has-arrow": this.arrow
    })}
      >
        <slot></slot>
        ${this.arrow ? ke`<div part="arrow" class="popup__arrow" role="presentation"></div>` : ""}
      </div>
    `;
  }
};
SlPopup.styles = [component_styles_default, popup_styles_default];
__decorateClass([
  e7(".popup")
], SlPopup.prototype, "popup", 2);
__decorateClass([
  e7(".popup__arrow")
], SlPopup.prototype, "arrowEl", 2);
__decorateClass([
  n6()
], SlPopup.prototype, "anchor", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlPopup.prototype, "active", 2);
__decorateClass([
  n6({ reflect: true })
], SlPopup.prototype, "placement", 2);
__decorateClass([
  n6({ reflect: true })
], SlPopup.prototype, "strategy", 2);
__decorateClass([
  n6({ type: Number })
], SlPopup.prototype, "distance", 2);
__decorateClass([
  n6({ type: Number })
], SlPopup.prototype, "skidding", 2);
__decorateClass([
  n6({ type: Boolean })
], SlPopup.prototype, "arrow", 2);
__decorateClass([
  n6({ attribute: "arrow-placement" })
], SlPopup.prototype, "arrowPlacement", 2);
__decorateClass([
  n6({ attribute: "arrow-padding", type: Number })
], SlPopup.prototype, "arrowPadding", 2);
__decorateClass([
  n6({ type: Boolean })
], SlPopup.prototype, "flip", 2);
__decorateClass([
  n6({
    attribute: "flip-fallback-placements",
    converter: {
      fromAttribute: (value) => {
        return value.split(" ").map((p3) => p3.trim()).filter((p3) => p3 !== "");
      },
      toAttribute: (value) => {
        return value.join(" ");
      }
    }
  })
], SlPopup.prototype, "flipFallbackPlacements", 2);
__decorateClass([
  n6({ attribute: "flip-fallback-strategy" })
], SlPopup.prototype, "flipFallbackStrategy", 2);
__decorateClass([
  n6({ type: Object })
], SlPopup.prototype, "flipBoundary", 2);
__decorateClass([
  n6({ attribute: "flip-padding", type: Number })
], SlPopup.prototype, "flipPadding", 2);
__decorateClass([
  n6({ type: Boolean })
], SlPopup.prototype, "shift", 2);
__decorateClass([
  n6({ type: Object })
], SlPopup.prototype, "shiftBoundary", 2);
__decorateClass([
  n6({ attribute: "shift-padding", type: Number })
], SlPopup.prototype, "shiftPadding", 2);
__decorateClass([
  n6({ attribute: "auto-size" })
], SlPopup.prototype, "autoSize", 2);
__decorateClass([
  n6()
], SlPopup.prototype, "sync", 2);
__decorateClass([
  n6({ type: Object })
], SlPopup.prototype, "autoSizeBoundary", 2);
__decorateClass([
  n6({ attribute: "auto-size-padding", type: Number })
], SlPopup.prototype, "autoSizePadding", 2);
__decorateClass([
  n6({ attribute: "hover-bridge", type: Boolean })
], SlPopup.prototype, "hoverBridge", 2);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.DHU6MIVB.js
var defaultAnimationRegistry = /* @__PURE__ */ new Map();
var customAnimationRegistry = /* @__PURE__ */ new WeakMap();
function ensureAnimation(animation) {
  return animation != null ? animation : { keyframes: [], options: { duration: 0 } };
}
function getLogicalAnimation(animation, dir) {
  if (dir.toLowerCase() === "rtl") {
    return {
      keyframes: animation.rtlKeyframes || animation.keyframes,
      options: animation.options
    };
  }
  return animation;
}
function setDefaultAnimation(animationName, animation) {
  defaultAnimationRegistry.set(animationName, ensureAnimation(animation));
}
function getAnimation(el, animationName, options) {
  const customAnimation = customAnimationRegistry.get(el);
  if (customAnimation == null ? void 0 : customAnimation[animationName]) {
    return getLogicalAnimation(customAnimation[animationName], options.dir);
  }
  const defaultAnimation = defaultAnimationRegistry.get(animationName);
  if (defaultAnimation) {
    return getLogicalAnimation(defaultAnimation, options.dir);
  }
  return {
    keyframes: [],
    options: { duration: 0 }
  };
}

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.B4BZKR24.js
function waitForEvent(el, eventName) {
  return new Promise((resolve) => {
    function done(event) {
      if (event.target === el) {
        el.removeEventListener(eventName, done);
        resolve();
      }
    }
    el.addEventListener(eventName, done);
  });
}

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LHI6QEL2.js
function animateTo(el, keyframes, options) {
  return new Promise((resolve) => {
    if ((options == null ? void 0 : options.duration) === Infinity) {
      throw new Error("Promise-based animations must be finite.");
    }
    const animation = el.animate(keyframes, __spreadProps(__spreadValues({}, options), {
      duration: prefersReducedMotion() ? 0 : options.duration
    }));
    animation.addEventListener("cancel", resolve, { once: true });
    animation.addEventListener("finish", resolve, { once: true });
  });
}
function parseDuration(delay) {
  delay = delay.toString().toLowerCase();
  if (delay.indexOf("ms") > -1) {
    return parseFloat(delay);
  }
  if (delay.indexOf("s") > -1) {
    return parseFloat(delay) * 1e3;
  }
  return parseFloat(delay);
}
function prefersReducedMotion() {
  const query4 = window.matchMedia("(prefers-reduced-motion: reduce)");
  return query4.matches;
}
function stopAnimations(el) {
  return Promise.all(
    el.getAnimations().map((animation) => {
      return new Promise((resolve) => {
        animation.cancel();
        requestAnimationFrame(resolve);
      });
    })
  );
}
function shimKeyframesHeightAuto(keyframes, calculatedHeight) {
  return keyframes.map((keyframe) => __spreadProps(__spreadValues({}, keyframe), {
    height: keyframe.height === "auto" ? `${calculatedHeight}px` : keyframe.height
  }));
}

// src/node_modules/@shoelace-style/localize/dist/index.js
var connectedElements = /* @__PURE__ */ new Set();
var documentElementObserver = new MutationObserver(update);
var translations = /* @__PURE__ */ new Map();
var documentDirection = document.documentElement.dir || "ltr";
var documentLanguage = document.documentElement.lang || navigator.language;
var fallback;
documentElementObserver.observe(document.documentElement, {
  attributes: true,
  attributeFilter: ["dir", "lang"]
});
function registerTranslation(...translation2) {
  translation2.map((t8) => {
    const code = t8.$code.toLowerCase();
    if (translations.has(code)) {
      translations.set(code, Object.assign(Object.assign({}, translations.get(code)), t8));
    } else {
      translations.set(code, t8);
    }
    if (!fallback) {
      fallback = t8;
    }
  });
  update();
}
function update() {
  documentDirection = document.documentElement.dir || "ltr";
  documentLanguage = document.documentElement.lang || navigator.language;
  [...connectedElements.keys()].map((el) => {
    if (typeof el.requestUpdate === "function") {
      el.requestUpdate();
    }
  });
}
var LocalizeController = class {
  constructor(host) {
    this.host = host;
    this.host.addController(this);
  }
  hostConnected() {
    connectedElements.add(this.host);
  }
  hostDisconnected() {
    connectedElements.delete(this.host);
  }
  dir() {
    return `${this.host.dir || documentDirection}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || documentLanguage}`.toLowerCase();
  }
  getTranslationData(lang) {
    var _a24, _b;
    const locale = new Intl.Locale(lang.replace(/_/g, "-"));
    const language = locale === null || locale === void 0 ? void 0 : locale.language.toLowerCase();
    const region = (_b = (_a24 = locale === null || locale === void 0 ? void 0 : locale.region) === null || _a24 === void 0 ? void 0 : _a24.toLowerCase()) !== null && _b !== void 0 ? _b : "";
    const primary = translations.get(`${language}-${region}`);
    const secondary = translations.get(language);
    return { locale, language, region, primary, secondary };
  }
  exists(key, options) {
    var _a24;
    const { primary, secondary } = this.getTranslationData((_a24 = options.lang) !== null && _a24 !== void 0 ? _a24 : this.lang());
    options = Object.assign({ includeFallback: false }, options);
    if (primary && primary[key] || secondary && secondary[key] || options.includeFallback && fallback && fallback[key]) {
      return true;
    }
    return false;
  }
  term(key, ...args) {
    const { primary, secondary } = this.getTranslationData(this.lang());
    let term;
    if (primary && primary[key]) {
      term = primary[key];
    } else if (secondary && secondary[key]) {
      term = secondary[key];
    } else if (fallback && fallback[key]) {
      term = fallback[key];
    } else {
      console.error(`No translation found for: ${String(key)}`);
      return String(key);
    }
    if (typeof term === "function") {
      return term(...args);
    }
    return term;
  }
  date(dateToFormat, options) {
    dateToFormat = new Date(dateToFormat);
    return new Intl.DateTimeFormat(this.lang(), options).format(dateToFormat);
  }
  number(numberToFormat, options) {
    numberToFormat = Number(numberToFormat);
    return isNaN(numberToFormat) ? "" : new Intl.NumberFormat(this.lang(), options).format(numberToFormat);
  }
  relativeTime(value, unit, options) {
    return new Intl.RelativeTimeFormat(this.lang(), options).format(value, unit);
  }
};

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.MAS2SHYD.js
var translation = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (slide, count) => `Go to slide ${slide} of ${count}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextSlide: "Next slide",
  numOptionsSelected: (num) => {
    if (num === 0)
      return "No options selected";
    if (num === 1)
      return "1 option selected";
    return `${num} options selected`;
  },
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: (slide) => `Slide ${slide}`,
  toggleColorFormat: "Toggle color format"
};
registerTranslation(translation);
var en_default = translation;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.WLV3FVBR.js
var LocalizeController2 = class extends LocalizeController {
};
registerTranslation(en_default);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2FB5TK5H.js
function watch(propertyName, options) {
  const resolvedOptions = __spreadValues({
    waitUntilFirstUpdate: false
  }, options);
  return (proto, decoratedFnName) => {
    const { update: update2 } = proto;
    const watchedProperties = Array.isArray(propertyName) ? propertyName : [propertyName];
    proto.update = function(changedProps) {
      watchedProperties.forEach((property2) => {
        const key = property2;
        if (changedProps.has(key)) {
          const oldValue = changedProps.get(key);
          const newValue = this[key];
          if (oldValue !== newValue) {
            if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {
              this[decoratedFnName](oldValue, newValue);
            }
          }
        }
      });
      update2.call(this, changedProps);
    };
  };
}

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.5UHNODB4.js
var SlTooltip = class extends ShoelaceElement {
  constructor() {
    super();
    this.localize = new LocalizeController2(this);
    this.content = "";
    this.placement = "top";
    this.disabled = false;
    this.distance = 8;
    this.open = false;
    this.skidding = 0;
    this.trigger = "hover focus";
    this.hoist = false;
    this.handleBlur = () => {
      if (this.hasTrigger("focus")) {
        this.hide();
      }
    };
    this.handleClick = () => {
      if (this.hasTrigger("click")) {
        if (this.open) {
          this.hide();
        } else {
          this.show();
        }
      }
    };
    this.handleFocus = () => {
      if (this.hasTrigger("focus")) {
        this.show();
      }
    };
    this.handleDocumentKeyDown = (event) => {
      if (event.key === "Escape") {
        event.stopPropagation();
        this.hide();
      }
    };
    this.handleMouseOver = () => {
      if (this.hasTrigger("hover")) {
        const delay = parseDuration(getComputedStyle(this).getPropertyValue("--show-delay"));
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = window.setTimeout(() => this.show(), delay);
      }
    };
    this.handleMouseOut = () => {
      if (this.hasTrigger("hover")) {
        const delay = parseDuration(getComputedStyle(this).getPropertyValue("--hide-delay"));
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = window.setTimeout(() => this.hide(), delay);
      }
    };
    this.addEventListener("blur", this.handleBlur, true);
    this.addEventListener("focus", this.handleFocus, true);
    this.addEventListener("click", this.handleClick);
    this.addEventListener("mouseover", this.handleMouseOver);
    this.addEventListener("mouseout", this.handleMouseOut);
  }
  disconnectedCallback() {
    var _a24;
    (_a24 = this.closeWatcher) == null ? void 0 : _a24.destroy();
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  firstUpdated() {
    this.body.hidden = !this.open;
    if (this.open) {
      this.popup.active = true;
      this.popup.reposition();
    }
  }
  hasTrigger(triggerType) {
    const triggers = this.trigger.split(" ");
    return triggers.includes(triggerType);
  }
  async handleOpenChange() {
    var _a24, _b;
    if (this.open) {
      if (this.disabled) {
        return;
      }
      this.emit("sl-show");
      if ("CloseWatcher" in window) {
        (_a24 = this.closeWatcher) == null ? void 0 : _a24.destroy();
        this.closeWatcher = new CloseWatcher();
        this.closeWatcher.onclose = () => {
          this.hide();
        };
      } else {
        document.addEventListener("keydown", this.handleDocumentKeyDown);
      }
      await stopAnimations(this.body);
      this.body.hidden = false;
      this.popup.active = true;
      const { keyframes, options } = getAnimation(this, "tooltip.show", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      this.popup.reposition();
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      (_b = this.closeWatcher) == null ? void 0 : _b.destroy();
      document.removeEventListener("keydown", this.handleDocumentKeyDown);
      await stopAnimations(this.body);
      const { keyframes, options } = getAnimation(this, "tooltip.hide", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      this.popup.active = false;
      this.body.hidden = true;
      this.emit("sl-after-hide");
    }
  }
  async handleOptionsChange() {
    if (this.hasUpdated) {
      await this.updateComplete;
      this.popup.reposition();
    }
  }
  handleDisabledChange() {
    if (this.disabled && this.open) {
      this.hide();
    }
  }
  /** Shows the tooltip. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the tooltip */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  //
  // NOTE: Tooltip is a bit unique in that we're using aria-live instead of aria-labelledby to trick screen readers into
  // announcing the content. It works really well, but it violates an accessibility rule. We're also adding the
  // aria-describedby attribute to a slot, which is required by <sl-popup> to correctly locate the first assigned
  // element, otherwise positioning is incorrect.
  //
  render() {
    return ke`
      <sl-popup
        part="base"
        exportparts="
          popup:base__popup,
          arrow:base__arrow
        "
        class=${Rt({
      tooltip: true,
      "tooltip--open": this.open
    })}
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        arrow
        hover-bridge
      >
        ${""}
        <slot slot="anchor" aria-describedby="tooltip"></slot>

        ${""}
        <div part="body" id="tooltip" class="tooltip__body" role="tooltip" aria-live=${this.open ? "polite" : "off"}>
          <slot name="content">${this.content}</slot>
        </div>
      </sl-popup>
    `;
  }
};
SlTooltip.styles = [component_styles_default, tooltip_styles_default];
SlTooltip.dependencies = { "sl-popup": SlPopup };
__decorateClass([
  e7("slot:not([name])")
], SlTooltip.prototype, "defaultSlot", 2);
__decorateClass([
  e7(".tooltip__body")
], SlTooltip.prototype, "body", 2);
__decorateClass([
  e7("sl-popup")
], SlTooltip.prototype, "popup", 2);
__decorateClass([
  n6()
], SlTooltip.prototype, "content", 2);
__decorateClass([
  n6()
], SlTooltip.prototype, "placement", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlTooltip.prototype, "disabled", 2);
__decorateClass([
  n6({ type: Number })
], SlTooltip.prototype, "distance", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlTooltip.prototype, "open", 2);
__decorateClass([
  n6({ type: Number })
], SlTooltip.prototype, "skidding", 2);
__decorateClass([
  n6()
], SlTooltip.prototype, "trigger", 2);
__decorateClass([
  n6({ type: Boolean })
], SlTooltip.prototype, "hoist", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: true })
], SlTooltip.prototype, "handleOpenChange", 1);
__decorateClass([
  watch(["content", "distance", "hoist", "placement", "skidding"])
], SlTooltip.prototype, "handleOptionsChange", 1);
__decorateClass([
  watch("disabled")
], SlTooltip.prototype, "handleDisabledChange", 1);
setDefaultAnimation("tooltip.show", {
  keyframes: [
    { opacity: 0, scale: 0.8 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 150, easing: "ease" }
});
setDefaultAnimation("tooltip.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.8 }
  ],
  options: { duration: 150, easing: "ease" }
});

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.VC2C3DLQ.js
SlTooltip.define("sl-tooltip");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.G7B7WU5W.js
var tree_styles_default = i`
  :host {
    /*
     * These are actually used by tree item, but we define them here so they can more easily be set and all tree items
     * stay consistent.
     */
    --indent-guide-color: var(--sl-color-neutral-200);
    --indent-guide-offset: 0;
    --indent-guide-style: solid;
    --indent-guide-width: 0;
    --indent-size: var(--sl-spacing-large);

    display: block;

    /*
     * Tree item indentation uses the "em" unit to increment its width on each level, so setting the font size to zero
     * here removes the indentation for all the nodes on the first level.
     */
    font-size: 0;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.BWVSW6TI.js
var tree_item_styles_default = i`
  :host {
    display: block;
    outline: 0;
    z-index: 0;
  }

  :host(:focus) {
    outline: none;
  }

  slot:not([name])::slotted(sl-icon) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .tree-item {
    position: relative;
    display: flex;
    align-items: stretch;
    flex-direction: column;
    color: var(--sl-color-neutral-700);
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
  }

  .tree-item__checkbox {
    pointer-events: none;
  }

  .tree-item__expand-button,
  .tree-item__checkbox,
  .tree-item__label {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-dense);
    letter-spacing: var(--sl-letter-spacing-normal);
  }

  .tree-item__checkbox::part(base) {
    display: flex;
    align-items: center;
  }

  .tree-item__indentation {
    display: block;
    width: 1em;
    flex-shrink: 0;
  }

  .tree-item__expand-button {
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: content-box;
    color: var(--sl-color-neutral-500);
    padding: var(--sl-spacing-x-small);
    width: 1rem;
    height: 1rem;
    flex-shrink: 0;
    cursor: pointer;
  }

  .tree-item__expand-button {
    transition: var(--sl-transition-medium) rotate ease;
  }

  .tree-item--expanded .tree-item__expand-button {
    rotate: 90deg;
  }

  .tree-item--expanded.tree-item--rtl .tree-item__expand-button {
    rotate: -90deg;
  }

  .tree-item--expanded slot[name='expand-icon'],
  .tree-item:not(.tree-item--expanded) slot[name='collapse-icon'] {
    display: none;
  }

  .tree-item:not(.tree-item--has-expand-button) .tree-item__expand-icon-slot {
    display: none;
  }

  .tree-item__expand-button--visible {
    cursor: pointer;
  }

  .tree-item__item {
    display: flex;
    align-items: center;
    border-inline-start: solid 3px transparent;
  }

  .tree-item--disabled .tree-item__item {
    opacity: 0.5;
    outline: none;
    cursor: not-allowed;
  }

  :host(:focus-visible) .tree-item__item {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
    z-index: 2;
  }

  :host(:not([aria-disabled='true'])) .tree-item--selected .tree-item__item {
    background-color: var(--sl-color-neutral-100);
    border-inline-start-color: var(--sl-color-primary-600);
  }

  :host(:not([aria-disabled='true'])) .tree-item__expand-button {
    color: var(--sl-color-neutral-600);
  }

  .tree-item__label {
    display: flex;
    align-items: center;
    transition: var(--sl-transition-fast) color;
  }

  .tree-item__children {
    display: block;
    font-size: calc(1em + var(--indent-size, var(--sl-spacing-medium)));
  }

  /* Indentation lines */
  .tree-item__children {
    position: relative;
  }

  .tree-item__children::before {
    content: '';
    position: absolute;
    top: var(--indent-guide-offset);
    bottom: var(--indent-guide-offset);
    left: calc(1em - (var(--indent-guide-width) / 2) - 1px);
    border-inline-end: var(--indent-guide-width) var(--indent-guide-style) var(--indent-guide-color);
    z-index: 1;
  }

  .tree-item--rtl .tree-item__children::before {
    left: auto;
    right: 1em;
  }

  @media (forced-colors: active) {
    :host(:not([aria-disabled='true'])) .tree-item--selected .tree-item__item {
      outline: dashed 1px SelectedItem;
    }
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.R3NF57O3.js
var checkbox_styles_default = i`
  :host {
    display: inline-block;
  }

  .checkbox {
    position: relative;
    display: inline-flex;
    align-items: flex-start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .checkbox--small {
    --toggle-size: var(--sl-toggle-size-small);
    font-size: var(--sl-input-font-size-small);
  }

  .checkbox--medium {
    --toggle-size: var(--sl-toggle-size-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .checkbox--large {
    --toggle-size: var(--sl-toggle-size-large);
    font-size: var(--sl-input-font-size-large);
  }

  .checkbox__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--toggle-size);
    height: var(--toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 2px;
    background-color: var(--sl-input-background-color);
    color: var(--sl-color-neutral-0);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
  }

  .checkbox__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  .checkbox__checked-icon,
  .checkbox__indeterminate-icon {
    display: inline-flex;
    width: var(--toggle-size);
    height: var(--toggle-size);
  }

  /* Hover */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Focus */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Checked/indeterminate */
  .checkbox--checked .checkbox__control,
  .checkbox--indeterminate .checkbox__control {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked/indeterminate + hover */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__control:hover,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked/indeterminate + focus */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .checkbox--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .checkbox__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    line-height: var(--toggle-size);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }

  :host([required]) .checkbox__label::after {
    content: var(--sl-input-required-content);
    color: var(--sl-input-required-content-color);
    margin-inline-start: var(--sl-input-required-content-offset);
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GI7VDIWX.js
var defaultValue = (propertyName = "value") => (proto, key) => {
  const ctor = proto.constructor;
  const attributeChangedCallback = ctor.prototype.attributeChangedCallback;
  ctor.prototype.attributeChangedCallback = function(name, old, value) {
    var _a24;
    const options = ctor.getPropertyOptions(propertyName);
    const attributeName = typeof options.attribute === "string" ? options.attribute : propertyName;
    if (name === attributeName) {
      const converter = options.converter || u;
      const fromAttribute = typeof converter === "function" ? converter : (_a24 = converter == null ? void 0 : converter.fromAttribute) != null ? _a24 : u.fromAttribute;
      const newValue = fromAttribute(value, options.type);
      if (this[propertyName] !== newValue) {
        this[key] = newValue;
      }
    }
    attributeChangedCallback.call(this, name, old, value);
  };
};

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SI4ACBFK.js
var form_control_styles_default = i`
  .form-control .form-control__label {
    display: none;
  }

  .form-control .form-control__help-text {
    display: none;
  }

  /* Label */
  .form-control--has-label .form-control__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    margin-bottom: var(--sl-spacing-3x-small);
  }

  .form-control--has-label.form-control--small .form-control__label {
    font-size: var(--sl-input-label-font-size-small);
  }

  .form-control--has-label.form-control--medium .form-control__label {
    font-size: var(--sl-input-label-font-size-medium);
  }

  .form-control--has-label.form-control--large .form-control__label {
    font-size: var(--sl-input-label-font-size-large);
  }

  :host([required]) .form-control--has-label .form-control__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
    color: var(--sl-input-required-content-color);
  }

  /* Help text */
  .form-control--has-help-text .form-control__help-text {
    display: block;
    color: var(--sl-input-help-text-color);
    margin-top: var(--sl-spacing-3x-small);
  }

  .form-control--has-help-text.form-control--small .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-small);
  }

  .form-control--has-help-text.form-control--medium .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-medium);
  }

  .form-control--has-help-text.form-control--large .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-large);
  }

  .form-control--has-help-text.form-control--radio-group .form-control__help-text {
    margin-top: var(--sl-spacing-2x-small);
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.NYIIDP5N.js
var HasSlotController = class {
  constructor(host, ...slotNames) {
    this.slotNames = [];
    this.handleSlotChange = (event) => {
      const slot = event.target;
      if (this.slotNames.includes("[default]") && !slot.name || slot.name && this.slotNames.includes(slot.name)) {
        this.host.requestUpdate();
      }
    };
    (this.host = host).addController(this);
    this.slotNames = slotNames;
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some((node) => {
      if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== "") {
        return true;
      }
      if (node.nodeType === node.ELEMENT_NODE) {
        const el = node;
        const tagName = el.tagName.toLowerCase();
        if (tagName === "sl-visually-hidden") {
          return false;
        }
        if (!el.hasAttribute("slot")) {
          return true;
        }
      }
      return false;
    });
  }
  hasNamedSlot(name) {
    return this.host.querySelector(`:scope > [slot="${name}"]`) !== null;
  }
  test(slotName) {
    return slotName === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(slotName);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
  }
};
function getTextContent(slot) {
  if (!slot) {
    return "";
  }
  const nodes = slot.assignedNodes({ flatten: true });
  let text = "";
  [...nodes].forEach((node) => {
    if (node.nodeType === Node.TEXT_NODE) {
      text += node.textContent;
    }
  });
  return text;
}

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3Y6SB6QS.js
var basePath = "";
function setBasePath(path) {
  basePath = path;
}
function getBasePath(subpath = "") {
  if (!basePath) {
    const scripts = [...document.getElementsByTagName("script")];
    const configScript = scripts.find((script) => script.hasAttribute("data-shoelace"));
    if (configScript) {
      setBasePath(configScript.getAttribute("data-shoelace"));
    } else {
      const fallbackScript = scripts.find((s6) => {
        return /shoelace(\.min)?\.js($|\?)/.test(s6.src) || /shoelace-autoloader(\.min)?\.js($|\?)/.test(s6.src);
      });
      let path = "";
      if (fallbackScript) {
        path = fallbackScript.getAttribute("src");
      }
      setBasePath(path.split("/").slice(0, -1).join("/"));
    }
  }
  return basePath.replace(/\/$/, "") + (subpath ? `/${subpath.replace(/^\//, "")}` : ``);
}

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.P7ZG6EMR.js
var library = {
  name: "default",
  resolver: (name) => getBasePath(`assets/icons/${name}.svg`)
};
var library_default_default = library;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3TFKS637.js
var icons = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-copy" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6ZM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2Z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
};
var systemLibrary = {
  name: "system",
  resolver: (name) => {
    if (name in icons) {
      return `data:image/svg+xml,${encodeURIComponent(icons[name])}`;
    }
    return "";
  }
};
var library_system_default = systemLibrary;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ZL53POKZ.js
var registry = [library_default_default, library_system_default];
var watchedIcons = [];
function watchIcon(icon) {
  watchedIcons.push(icon);
}
function unwatchIcon(icon) {
  watchedIcons = watchedIcons.filter((el) => el !== icon);
}
function getIconLibrary(name) {
  return registry.find((lib) => lib.name === name);
}

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.QLXRCYS4.js
var icon_styles_default = i`
  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;

// src/node_modules/lit-html/directive-helpers.js
var { I: et3 } = si;
var nt = (o7, t8) => void 0 === t8 ? void 0 !== o7?._$litType$ : o7?._$litType$ === t8;
var rt = (o7) => void 0 === o7.strings;
var lt3 = () => document.createComment("");
var at = (o7, t8, i5) => {
  const n7 = o7._$AA.parentNode, e10 = void 0 === t8 ? o7._$AB : t8._$AA;
  if (void 0 === i5) {
    const t9 = n7.insertBefore(lt3(), e10), l3 = n7.insertBefore(lt3(), e10);
    i5 = new et3(t9, l3, o7, o7.options);
  } else {
    const t9 = i5._$AB.nextSibling, l3 = i5._$AM, c6 = l3 !== o7;
    if (c6) {
      let t10;
      i5._$AQ?.(o7), i5._$AM = o7, void 0 !== i5._$AP && (t10 = o7._$AU) !== l3._$AU && i5._$AP(t10);
    }
    if (t9 !== e10 || c6) {
      let o8 = i5._$AA;
      for (; o8 !== t9; ) {
        const t10 = o8.nextSibling;
        n7.insertBefore(o8, e10), o8 = t10;
      }
    }
  }
  return i5;
};
var ct = (o7, t8, i5 = o7) => (o7._$AI(t8, i5), o7);
var ht = {};
var dt = (o7, t8 = ht) => o7._$AH = t8;
var ut = (o7) => o7._$AH;
var pt = (o7) => {
  o7._$AP?.(false, true);
  let t8 = o7._$AA;
  const i5 = o7._$AB.nextSibling;
  for (; t8 !== i5; ) {
    const o8 = t8.nextSibling;
    t8.remove(), t8 = o8;
  }
};

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.H33C3MRM.js
var CACHEABLE_ERROR = Symbol();
var RETRYABLE_ERROR = Symbol();
var parser;
var iconCache = /* @__PURE__ */ new Map();
var SlIcon = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.initialRender = false;
    this.svg = null;
    this.label = "";
    this.library = "default";
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  async resolveIcon(url, library2) {
    var _a24;
    let fileData;
    if (library2 == null ? void 0 : library2.spriteSheet) {
      this.svg = ke`<svg part="svg">
        <use part="use" href="${url}"></use>
      </svg>`;
      await this.updateComplete;
      const svg = this.shadowRoot.querySelector("[part='svg']");
      if (typeof library2.mutator === "function") {
        library2.mutator(svg);
      }
      return this.svg;
    }
    try {
      fileData = await fetch(url, { mode: "cors" });
      if (!fileData.ok)
        return fileData.status === 410 ? CACHEABLE_ERROR : RETRYABLE_ERROR;
    } catch (e10) {
      return RETRYABLE_ERROR;
    }
    try {
      const div = document.createElement("div");
      div.innerHTML = await fileData.text();
      const svg = div.firstElementChild;
      if (((_a24 = svg == null ? void 0 : svg.tagName) == null ? void 0 : _a24.toLowerCase()) !== "svg")
        return CACHEABLE_ERROR;
      if (!parser)
        parser = new DOMParser();
      const doc = parser.parseFromString(svg.outerHTML, "text/html");
      const svgEl = doc.body.querySelector("svg");
      if (!svgEl)
        return CACHEABLE_ERROR;
      svgEl.part.add("svg");
      return document.adoptNode(svgEl);
    } catch (e10) {
      return CACHEABLE_ERROR;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    watchIcon(this);
  }
  firstUpdated() {
    this.initialRender = true;
    this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    unwatchIcon(this);
  }
  getIconSource() {
    const library2 = getIconLibrary(this.library);
    if (this.name && library2) {
      return {
        url: library2.resolver(this.name),
        fromLibrary: true
      };
    }
    return {
      url: this.src,
      fromLibrary: false
    };
  }
  handleLabelChange() {
    const hasLabel = typeof this.label === "string" && this.label.length > 0;
    if (hasLabel) {
      this.setAttribute("role", "img");
      this.setAttribute("aria-label", this.label);
      this.removeAttribute("aria-hidden");
    } else {
      this.removeAttribute("role");
      this.removeAttribute("aria-label");
      this.setAttribute("aria-hidden", "true");
    }
  }
  async setIcon() {
    var _a24;
    const { url, fromLibrary } = this.getIconSource();
    const library2 = fromLibrary ? getIconLibrary(this.library) : void 0;
    if (!url) {
      this.svg = null;
      return;
    }
    let iconResolver = iconCache.get(url);
    if (!iconResolver) {
      iconResolver = this.resolveIcon(url, library2);
      iconCache.set(url, iconResolver);
    }
    if (!this.initialRender) {
      return;
    }
    const svg = await iconResolver;
    if (svg === RETRYABLE_ERROR) {
      iconCache.delete(url);
    }
    if (url !== this.getIconSource().url) {
      return;
    }
    if (nt(svg)) {
      this.svg = svg;
      return;
    }
    switch (svg) {
      case RETRYABLE_ERROR:
      case CACHEABLE_ERROR:
        this.svg = null;
        this.emit("sl-error");
        break;
      default:
        this.svg = svg.cloneNode(true);
        (_a24 = library2 == null ? void 0 : library2.mutator) == null ? void 0 : _a24.call(library2, this.svg);
        this.emit("sl-load");
    }
  }
  render() {
    return this.svg;
  }
};
SlIcon.styles = [component_styles_default, icon_styles_default];
__decorateClass([
  r5()
], SlIcon.prototype, "svg", 2);
__decorateClass([
  n6({ reflect: true })
], SlIcon.prototype, "name", 2);
__decorateClass([
  n6()
], SlIcon.prototype, "src", 2);
__decorateClass([
  n6()
], SlIcon.prototype, "label", 2);
__decorateClass([
  n6({ reflect: true })
], SlIcon.prototype, "library", 2);
__decorateClass([
  watch("label")
], SlIcon.prototype, "handleLabelChange", 1);
__decorateClass([
  watch(["name", "src", "library"])
], SlIcon.prototype, "setIcon", 1);

// src/node_modules/lit-html/directives/if-defined.js
var to = (t8) => t8 ?? D;

// src/node_modules/lit-html/directives/live.js
var Ft = e9(class extends i4 {
  constructor(r9) {
    if (super(r9), r9.type !== t6.PROPERTY && r9.type !== t6.ATTRIBUTE && r9.type !== t6.BOOLEAN_ATTRIBUTE) throw Error("The `live` directive is not allowed on child or event bindings");
    if (!rt(r9)) throw Error("`live` bindings can only contain a single expression");
  }
  render(r9) {
    return r9;
  }
  update(r9, [e10]) {
    if (e10 === R || e10 === D) return e10;
    const i5 = r9.element, n7 = r9.name;
    if (r9.type === t6.PROPERTY) {
      if (e10 === i5[n7]) return R;
    } else if (r9.type === t6.BOOLEAN_ATTRIBUTE) {
      if (!!e10 === i5.hasAttribute(n7)) return R;
    } else if (r9.type === t6.ATTRIBUTE && i5.getAttribute(n7) === e10 + "") return R;
    return dt(r9), e10;
  }
});

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.WFOPYYZB.js
var SlCheckbox = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      value: (control) => control.checked ? control.value || "on" : void 0,
      defaultValue: (control) => control.defaultChecked,
      setValue: (control, checked) => control.checked = checked
    });
    this.hasSlotController = new HasSlotController(this, "help-text");
    this.hasFocus = false;
    this.title = "";
    this.name = "";
    this.size = "medium";
    this.disabled = false;
    this.checked = false;
    this.indeterminate = false;
    this.defaultChecked = false;
    this.form = "";
    this.required = false;
    this.helpText = "";
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleClick() {
    this.checked = !this.checked;
    this.indeterminate = false;
    this.emit("sl-change");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleInput() {
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStateChange() {
    this.input.checked = this.checked;
    this.input.indeterminate = this.indeterminate;
    this.formControlController.updateValidity();
  }
  /** Simulates a click on the checkbox. */
  click() {
    this.input.click();
  }
  /** Sets focus on the checkbox. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the checkbox. */
  blur() {
    this.input.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /**
   * Sets a custom validation message. The value provided will be shown to the user when the form is submitted. To clear
   * the custom validation message, call this method with an empty string.
   */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return ke`
      <div
        class=${Rt({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="base"
          class=${Rt({
      checkbox: true,
      "checkbox--checked": this.checked,
      "checkbox--disabled": this.disabled,
      "checkbox--focused": this.hasFocus,
      "checkbox--indeterminate": this.indeterminate,
      "checkbox--small": this.size === "small",
      "checkbox--medium": this.size === "medium",
      "checkbox--large": this.size === "large"
    })}
        >
          <input
            class="checkbox__input"
            type="checkbox"
            title=${this.title}
            name=${this.name}
            value=${to(this.value)}
            .indeterminate=${Ft(this.indeterminate)}
            .checked=${Ft(this.checked)}
            .disabled=${this.disabled}
            .required=${this.required}
            aria-checked=${this.checked ? "true" : "false"}
            aria-describedby="help-text"
            @click=${this.handleClick}
            @input=${this.handleInput}
            @invalid=${this.handleInvalid}
            @blur=${this.handleBlur}
            @focus=${this.handleFocus}
          />

          <span
            part="control${this.checked ? " control--checked" : ""}${this.indeterminate ? " control--indeterminate" : ""}"
            class="checkbox__control"
          >
            ${this.checked ? ke`
                  <sl-icon part="checked-icon" class="checkbox__checked-icon" library="system" name="check"></sl-icon>
                ` : ""}
            ${!this.checked && this.indeterminate ? ke`
                  <sl-icon
                    part="indeterminate-icon"
                    class="checkbox__indeterminate-icon"
                    library="system"
                    name="indeterminate"
                  ></sl-icon>
                ` : ""}
          </span>

          <div part="label" class="checkbox__label">
            <slot></slot>
          </div>
        </label>

        <div
          aria-hidden=${hasHelpText ? "false" : "true"}
          class="form-control__help-text"
          id="help-text"
          part="form-control-help-text"
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlCheckbox.styles = [component_styles_default, form_control_styles_default, checkbox_styles_default];
SlCheckbox.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e7('input[type="checkbox"]')
], SlCheckbox.prototype, "input", 2);
__decorateClass([
  r5()
], SlCheckbox.prototype, "hasFocus", 2);
__decorateClass([
  n6()
], SlCheckbox.prototype, "title", 2);
__decorateClass([
  n6()
], SlCheckbox.prototype, "name", 2);
__decorateClass([
  n6()
], SlCheckbox.prototype, "value", 2);
__decorateClass([
  n6({ reflect: true })
], SlCheckbox.prototype, "size", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "disabled", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "checked", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "indeterminate", 2);
__decorateClass([
  defaultValue("checked")
], SlCheckbox.prototype, "defaultChecked", 2);
__decorateClass([
  n6({ reflect: true })
], SlCheckbox.prototype, "form", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "required", 2);
__decorateClass([
  n6({ attribute: "help-text" })
], SlCheckbox.prototype, "helpText", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlCheckbox.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch(["checked", "indeterminate"], { waitUntilFirstUpdate: true })
], SlCheckbox.prototype, "handleStateChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7DUCI5S4.js
var spinner_styles_default = i`
  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 2s;

    display: inline-flex;
    width: 1em;
    height: 1em;
    flex: none;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
      stroke-dasharray: 0.05em, 3em;
    }

    50% {
      transform: rotate(450deg);
      stroke-dasharray: 1.375em, 1.375em;
    }

    100% {
      transform: rotate(1080deg);
      stroke-dasharray: 0.05em, 3em;
    }
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.RADK4UXU.js
var SlSpinner = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
  }
  render() {
    return ke`
      <svg part="base" class="spinner" role="progressbar" aria-label=${this.localize.term("loading")}>
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
  }
};
SlSpinner.styles = [component_styles_default, spinner_styles_default];

// src/node_modules/lit-html/directives/when.js
function nn(n7, r9, t8) {
  return n7 ? r9(n7) : t8?.(n7);
}

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.VKNM5JU7.js
var _SlTreeItem = class _SlTreeItem2 extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.indeterminate = false;
    this.isLeaf = false;
    this.loading = false;
    this.selectable = false;
    this.expanded = false;
    this.selected = false;
    this.disabled = false;
    this.lazy = false;
  }
  static isTreeItem(node) {
    return node instanceof Element && node.getAttribute("role") === "treeitem";
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "treeitem");
    this.setAttribute("tabindex", "-1");
    if (this.isNestedItem()) {
      this.slot = "children";
    }
  }
  firstUpdated() {
    this.childrenContainer.hidden = !this.expanded;
    this.childrenContainer.style.height = this.expanded ? "auto" : "0";
    this.isLeaf = !this.lazy && this.getChildrenItems().length === 0;
    this.handleExpandedChange();
  }
  async animateCollapse() {
    this.emit("sl-collapse");
    await stopAnimations(this.childrenContainer);
    const { keyframes, options } = getAnimation(this, "tree-item.collapse", { dir: this.localize.dir() });
    await animateTo(
      this.childrenContainer,
      shimKeyframesHeightAuto(keyframes, this.childrenContainer.scrollHeight),
      options
    );
    this.childrenContainer.hidden = true;
    this.emit("sl-after-collapse");
  }
  // Checks whether the item is nested into an item
  isNestedItem() {
    const parent = this.parentElement;
    return !!parent && _SlTreeItem2.isTreeItem(parent);
  }
  handleChildrenSlotChange() {
    this.loading = false;
    this.isLeaf = !this.lazy && this.getChildrenItems().length === 0;
  }
  willUpdate(changedProperties) {
    if (changedProperties.has("selected") && !changedProperties.has("indeterminate")) {
      this.indeterminate = false;
    }
  }
  async animateExpand() {
    this.emit("sl-expand");
    await stopAnimations(this.childrenContainer);
    this.childrenContainer.hidden = false;
    const { keyframes, options } = getAnimation(this, "tree-item.expand", { dir: this.localize.dir() });
    await animateTo(
      this.childrenContainer,
      shimKeyframesHeightAuto(keyframes, this.childrenContainer.scrollHeight),
      options
    );
    this.childrenContainer.style.height = "auto";
    this.emit("sl-after-expand");
  }
  handleLoadingChange() {
    this.setAttribute("aria-busy", this.loading ? "true" : "false");
    if (!this.loading) {
      this.animateExpand();
    }
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleSelectedChange() {
    this.setAttribute("aria-selected", this.selected ? "true" : "false");
  }
  handleExpandedChange() {
    if (!this.isLeaf) {
      this.setAttribute("aria-expanded", this.expanded ? "true" : "false");
    } else {
      this.removeAttribute("aria-expanded");
    }
  }
  handleExpandAnimation() {
    if (this.expanded) {
      if (this.lazy) {
        this.loading = true;
        this.emit("sl-lazy-load");
      } else {
        this.animateExpand();
      }
    } else {
      this.animateCollapse();
    }
  }
  handleLazyChange() {
    this.emit("sl-lazy-change");
  }
  /** Gets all the nested tree items in this node. */
  getChildrenItems({ includeDisabled = true } = {}) {
    return this.childrenSlot ? [...this.childrenSlot.assignedElements({ flatten: true })].filter(
      (item) => _SlTreeItem2.isTreeItem(item) && (includeDisabled || !item.disabled)
    ) : [];
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    const showExpandButton = !this.loading && (!this.isLeaf || this.lazy);
    return ke`
      <div
        part="base"
        class="${Rt({
      "tree-item": true,
      "tree-item--expanded": this.expanded,
      "tree-item--selected": this.selected,
      "tree-item--disabled": this.disabled,
      "tree-item--leaf": this.isLeaf,
      "tree-item--has-expand-button": showExpandButton,
      "tree-item--rtl": this.localize.dir() === "rtl"
    })}"
      >
        <div
          class="tree-item__item"
          part="
            item
            ${this.disabled ? "item--disabled" : ""}
            ${this.expanded ? "item--expanded" : ""}
            ${this.indeterminate ? "item--indeterminate" : ""}
            ${this.selected ? "item--selected" : ""}
          "
        >
          <div class="tree-item__indentation" part="indentation"></div>

          <div
            part="expand-button"
            class=${Rt({
      "tree-item__expand-button": true,
      "tree-item__expand-button--visible": showExpandButton
    })}
            aria-hidden="true"
          >
            ${nn(
      this.loading,
      () => ke` <sl-spinner part="spinner" exportparts="base:spinner__base"></sl-spinner> `
    )}
            <slot class="tree-item__expand-icon-slot" name="expand-icon">
              <sl-icon library="system" name=${isRtl ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
            <slot class="tree-item__expand-icon-slot" name="collapse-icon">
              <sl-icon library="system" name=${isRtl ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
          </div>

          ${nn(
      this.selectable,
      () => ke`
              <sl-checkbox
                part="checkbox"
                exportparts="
                    base:checkbox__base,
                    control:checkbox__control,
                    control--checked:checkbox__control--checked,
                    control--indeterminate:checkbox__control--indeterminate,
                    checked-icon:checkbox__checked-icon,
                    indeterminate-icon:checkbox__indeterminate-icon,
                    label:checkbox__label
                  "
                class="tree-item__checkbox"
                ?disabled="${this.disabled}"
                ?checked="${Ft(this.selected)}"
                ?indeterminate="${this.indeterminate}"
                tabindex="-1"
              ></sl-checkbox>
            `
    )}

          <slot class="tree-item__label" part="label"></slot>
        </div>

        <div class="tree-item__children" part="children" role="group">
          <slot name="children" @slotchange="${this.handleChildrenSlotChange}"></slot>
        </div>
      </div>
    `;
  }
};
_SlTreeItem.styles = [component_styles_default, tree_item_styles_default];
_SlTreeItem.dependencies = {
  "sl-checkbox": SlCheckbox,
  "sl-icon": SlIcon,
  "sl-spinner": SlSpinner
};
__decorateClass([
  r5()
], _SlTreeItem.prototype, "indeterminate", 2);
__decorateClass([
  r5()
], _SlTreeItem.prototype, "isLeaf", 2);
__decorateClass([
  r5()
], _SlTreeItem.prototype, "loading", 2);
__decorateClass([
  r5()
], _SlTreeItem.prototype, "selectable", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], _SlTreeItem.prototype, "expanded", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], _SlTreeItem.prototype, "selected", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], _SlTreeItem.prototype, "disabled", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], _SlTreeItem.prototype, "lazy", 2);
__decorateClass([
  e7("slot:not([name])")
], _SlTreeItem.prototype, "defaultSlot", 2);
__decorateClass([
  e7("slot[name=children]")
], _SlTreeItem.prototype, "childrenSlot", 2);
__decorateClass([
  e7(".tree-item__item")
], _SlTreeItem.prototype, "itemElement", 2);
__decorateClass([
  e7(".tree-item__children")
], _SlTreeItem.prototype, "childrenContainer", 2);
__decorateClass([
  e7(".tree-item__expand-button slot")
], _SlTreeItem.prototype, "expandButtonSlot", 2);
__decorateClass([
  watch("loading", { waitUntilFirstUpdate: true })
], _SlTreeItem.prototype, "handleLoadingChange", 1);
__decorateClass([
  watch("disabled")
], _SlTreeItem.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("selected")
], _SlTreeItem.prototype, "handleSelectedChange", 1);
__decorateClass([
  watch("expanded", { waitUntilFirstUpdate: true })
], _SlTreeItem.prototype, "handleExpandedChange", 1);
__decorateClass([
  watch("expanded", { waitUntilFirstUpdate: true })
], _SlTreeItem.prototype, "handleExpandAnimation", 1);
__decorateClass([
  watch("lazy", { waitUntilFirstUpdate: true })
], _SlTreeItem.prototype, "handleLazyChange", 1);
var SlTreeItem = _SlTreeItem;
setDefaultAnimation("tree-item.expand", {
  keyframes: [
    { height: "0", opacity: "0", overflow: "hidden" },
    { height: "auto", opacity: "1", overflow: "hidden" }
  ],
  options: { duration: 250, easing: "cubic-bezier(0.4, 0.0, 0.2, 1)" }
});
setDefaultAnimation("tree-item.collapse", {
  keyframes: [
    { height: "auto", opacity: "1", overflow: "hidden" },
    { height: "0", opacity: "0", overflow: "hidden" }
  ],
  options: { duration: 200, easing: "cubic-bezier(0.4, 0.0, 0.2, 1)" }
});

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.HF7GESMZ.js
function clamp2(value, min2, max2) {
  const noNegativeZero = (n7) => Object.is(n7, -0) ? 0 : n7;
  if (value < min2) {
    return noNegativeZero(min2);
  }
  if (value > max2) {
    return noNegativeZero(max2);
  }
  return noNegativeZero(value);
}

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.EUQGKLE5.js
function syncCheckboxes(changedTreeItem, initialSync = false) {
  function syncParentItem(treeItem) {
    const children = treeItem.getChildrenItems({ includeDisabled: false });
    if (children.length) {
      const allChecked = children.every((item) => item.selected);
      const allUnchecked = children.every((item) => !item.selected && !item.indeterminate);
      treeItem.selected = allChecked;
      treeItem.indeterminate = !allChecked && !allUnchecked;
    }
  }
  function syncAncestors(treeItem) {
    const parentItem = treeItem.parentElement;
    if (SlTreeItem.isTreeItem(parentItem)) {
      syncParentItem(parentItem);
      syncAncestors(parentItem);
    }
  }
  function syncDescendants(treeItem) {
    for (const childItem of treeItem.getChildrenItems()) {
      childItem.selected = initialSync ? treeItem.selected || childItem.selected : !childItem.disabled && treeItem.selected;
      syncDescendants(childItem);
    }
    if (initialSync) {
      syncParentItem(treeItem);
    }
  }
  syncDescendants(changedTreeItem);
  syncAncestors(changedTreeItem);
}
var SlTree = class extends ShoelaceElement {
  constructor() {
    super();
    this.selection = "single";
    this.localize = new LocalizeController2(this);
    this.clickTarget = null;
    this.initTreeItem = (item) => {
      item.selectable = this.selection === "multiple";
      ["expand", "collapse"].filter((status) => !!this.querySelector(`[slot="${status}-icon"]`)).forEach((status) => {
        const existingIcon = item.querySelector(`[slot="${status}-icon"]`);
        const expandButtonIcon = this.getExpandButtonIcon(status);
        if (!expandButtonIcon)
          return;
        if (existingIcon === null) {
          item.append(expandButtonIcon);
        } else if (existingIcon.hasAttribute("data-default")) {
          existingIcon.replaceWith(expandButtonIcon);
        } else {
        }
      });
    };
    this.handleTreeChanged = (mutations) => {
      for (const mutation of mutations) {
        const addedNodes = [...mutation.addedNodes].filter(SlTreeItem.isTreeItem);
        const removedNodes = [...mutation.removedNodes].filter(SlTreeItem.isTreeItem);
        addedNodes.forEach(this.initTreeItem);
        if (this.lastFocusedItem && removedNodes.includes(this.lastFocusedItem)) {
          this.lastFocusedItem = null;
        }
      }
    };
    this.handleFocusOut = (event) => {
      const relatedTarget = event.relatedTarget;
      if (!relatedTarget || !this.contains(relatedTarget)) {
        this.tabIndex = 0;
      }
    };
    this.handleFocusIn = (event) => {
      const target = event.target;
      if (event.target === this) {
        this.focusItem(this.lastFocusedItem || this.getAllTreeItems()[0]);
      }
      if (SlTreeItem.isTreeItem(target) && !target.disabled) {
        if (this.lastFocusedItem) {
          this.lastFocusedItem.tabIndex = -1;
        }
        this.lastFocusedItem = target;
        this.tabIndex = -1;
        target.tabIndex = 0;
      }
    };
    this.addEventListener("focusin", this.handleFocusIn);
    this.addEventListener("focusout", this.handleFocusOut);
    this.addEventListener("sl-lazy-change", this.handleSlotChange);
  }
  async connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "tree");
    this.setAttribute("tabindex", "0");
    await this.updateComplete;
    this.mutationObserver = new MutationObserver(this.handleTreeChanged);
    this.mutationObserver.observe(this, { childList: true, subtree: true });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.mutationObserver.disconnect();
  }
  // Generates a clone of the expand icon element to use for each tree item
  getExpandButtonIcon(status) {
    const slot = status === "expand" ? this.expandedIconSlot : this.collapsedIconSlot;
    const icon = slot.assignedElements({ flatten: true })[0];
    if (icon) {
      const clone = icon.cloneNode(true);
      [clone, ...clone.querySelectorAll("[id]")].forEach((el) => el.removeAttribute("id"));
      clone.setAttribute("data-default", "");
      clone.slot = `${status}-icon`;
      return clone;
    }
    return null;
  }
  selectItem(selectedItem) {
    const previousSelection = [...this.selectedItems];
    if (this.selection === "multiple") {
      selectedItem.selected = !selectedItem.selected;
      if (selectedItem.lazy) {
        selectedItem.expanded = true;
      }
      syncCheckboxes(selectedItem);
    } else if (this.selection === "single" || selectedItem.isLeaf) {
      const items = this.getAllTreeItems();
      for (const item of items) {
        item.selected = item === selectedItem;
      }
    } else if (this.selection === "leaf") {
      selectedItem.expanded = !selectedItem.expanded;
    }
    const nextSelection = this.selectedItems;
    if (previousSelection.length !== nextSelection.length || nextSelection.some((item) => !previousSelection.includes(item))) {
      Promise.all(nextSelection.map((el) => el.updateComplete)).then(() => {
        this.emit("sl-selection-change", { detail: { selection: nextSelection } });
      });
    }
  }
  getAllTreeItems() {
    return [...this.querySelectorAll("sl-tree-item")];
  }
  focusItem(item) {
    item == null ? void 0 : item.focus();
  }
  handleKeyDown(event) {
    if (!["ArrowDown", "ArrowUp", "ArrowRight", "ArrowLeft", "Home", "End", "Enter", " "].includes(event.key)) {
      return;
    }
    if (event.composedPath().some((el) => {
      var _a24;
      return ["input", "textarea"].includes((_a24 = el == null ? void 0 : el.tagName) == null ? void 0 : _a24.toLowerCase());
    })) {
      return;
    }
    const items = this.getFocusableItems();
    const isLtr = this.localize.dir() === "ltr";
    const isRtl = this.localize.dir() === "rtl";
    if (items.length > 0) {
      event.preventDefault();
      const activeItemIndex = items.findIndex((item) => item.matches(":focus"));
      const activeItem = items[activeItemIndex];
      const focusItemAt = (index) => {
        const item = items[clamp2(index, 0, items.length - 1)];
        this.focusItem(item);
      };
      const toggleExpand = (expanded) => {
        activeItem.expanded = expanded;
      };
      if (event.key === "ArrowDown") {
        focusItemAt(activeItemIndex + 1);
      } else if (event.key === "ArrowUp") {
        focusItemAt(activeItemIndex - 1);
      } else if (isLtr && event.key === "ArrowRight" || isRtl && event.key === "ArrowLeft") {
        if (!activeItem || activeItem.disabled || activeItem.expanded || activeItem.isLeaf && !activeItem.lazy) {
          focusItemAt(activeItemIndex + 1);
        } else {
          toggleExpand(true);
        }
      } else if (isLtr && event.key === "ArrowLeft" || isRtl && event.key === "ArrowRight") {
        if (!activeItem || activeItem.disabled || activeItem.isLeaf || !activeItem.expanded) {
          focusItemAt(activeItemIndex - 1);
        } else {
          toggleExpand(false);
        }
      } else if (event.key === "Home") {
        focusItemAt(0);
      } else if (event.key === "End") {
        focusItemAt(items.length - 1);
      } else if (event.key === "Enter" || event.key === " ") {
        if (!activeItem.disabled) {
          this.selectItem(activeItem);
        }
      }
    }
  }
  handleClick(event) {
    const target = event.target;
    const treeItem = target.closest("sl-tree-item");
    const isExpandButton = event.composedPath().some((el) => {
      var _a24;
      return (_a24 = el == null ? void 0 : el.classList) == null ? void 0 : _a24.contains("tree-item__expand-button");
    });
    if (!treeItem || treeItem.disabled || target !== this.clickTarget) {
      return;
    }
    if (isExpandButton) {
      treeItem.expanded = !treeItem.expanded;
    } else {
      this.selectItem(treeItem);
    }
  }
  handleMouseDown(event) {
    this.clickTarget = event.target;
  }
  handleSlotChange() {
    const items = this.getAllTreeItems();
    items.forEach(this.initTreeItem);
  }
  async handleSelectionChange() {
    const isSelectionMultiple = this.selection === "multiple";
    const items = this.getAllTreeItems();
    this.setAttribute("aria-multiselectable", isSelectionMultiple ? "true" : "false");
    for (const item of items) {
      item.selectable = isSelectionMultiple;
    }
    if (isSelectionMultiple) {
      await this.updateComplete;
      [...this.querySelectorAll(":scope > sl-tree-item")].forEach(
        (treeItem) => syncCheckboxes(treeItem, true)
      );
    }
  }
  /** @internal Returns the list of tree items that are selected in the tree. */
  get selectedItems() {
    const items = this.getAllTreeItems();
    const isSelected = (item) => item.selected;
    return items.filter(isSelected);
  }
  /** @internal Gets focusable tree items in the tree. */
  getFocusableItems() {
    const items = this.getAllTreeItems();
    const collapsedItems = /* @__PURE__ */ new Set();
    return items.filter((item) => {
      var _a24;
      if (item.disabled)
        return false;
      const parent = (_a24 = item.parentElement) == null ? void 0 : _a24.closest("[role=treeitem]");
      if (parent && (!parent.expanded || parent.loading || collapsedItems.has(parent))) {
        collapsedItems.add(item);
      }
      return !collapsedItems.has(item);
    });
  }
  render() {
    return ke`
      <div
        part="base"
        class="tree"
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleMouseDown}
      >
        <slot @slotchange=${this.handleSlotChange}></slot>
        <span hidden aria-hidden="true"><slot name="expand-icon"></slot></span>
        <span hidden aria-hidden="true"><slot name="collapse-icon"></slot></span>
      </div>
    `;
  }
};
SlTree.styles = [component_styles_default, tree_styles_default];
__decorateClass([
  e7("slot:not([name])")
], SlTree.prototype, "defaultSlot", 2);
__decorateClass([
  e7("slot[name=expand-icon]")
], SlTree.prototype, "expandedIconSlot", 2);
__decorateClass([
  e7("slot[name=collapse-icon]")
], SlTree.prototype, "collapsedIconSlot", 2);
__decorateClass([
  n6()
], SlTree.prototype, "selection", 2);
__decorateClass([
  watch("selection")
], SlTree.prototype, "handleSelectionChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ZV4B5UAC.js
SlTree.define("sl-tree");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SK5FTE7C.js
SlTreeItem.define("sl-tree-item");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.BQSEJD7X.js
var tab_panel_styles_default = i`
  :host {
    --padding: 0;

    display: none;
  }

  :host([active]) {
    display: block;
  }

  .tab-panel {
    display: block;
    padding: var(--padding);
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.JBJQHIXK.js
var id = 0;
var SlTabPanel = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.attrId = ++id;
    this.componentId = `sl-tab-panel-${this.attrId}`;
    this.name = "";
    this.active = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.id = this.id.length > 0 ? this.id : this.componentId;
    this.setAttribute("role", "tabpanel");
  }
  handleActiveChange() {
    this.setAttribute("aria-hidden", this.active ? "false" : "true");
  }
  render() {
    return ke`
      <slot
        part="base"
        class=${Rt({
      "tab-panel": true,
      "tab-panel--active": this.active
    })}
      ></slot>
    `;
  }
};
SlTabPanel.styles = [component_styles_default, tab_panel_styles_default];
__decorateClass([
  n6({ reflect: true })
], SlTabPanel.prototype, "name", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlTabPanel.prototype, "active", 2);
__decorateClass([
  watch("active")
], SlTabPanel.prototype, "handleActiveChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7SESWKJL.js
SlTabPanel.define("sl-tab-panel");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.V2OL7VMD.js
var tag_styles_default = i`
  :host {
    display: inline-block;
  }

  .tag {
    display: flex;
    align-items: center;
    border: solid 1px;
    line-height: 1;
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
  }

  .tag__remove::part(base) {
    color: inherit;
    padding: 0;
  }

  /*
   * Variant modifiers
   */

  .tag--primary {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-200);
    color: var(--sl-color-primary-800);
  }

  .tag--primary:active > sl-icon-button {
    color: var(--sl-color-primary-600);
  }

  .tag--success {
    background-color: var(--sl-color-success-50);
    border-color: var(--sl-color-success-200);
    color: var(--sl-color-success-800);
  }

  .tag--success:active > sl-icon-button {
    color: var(--sl-color-success-600);
  }

  .tag--neutral {
    background-color: var(--sl-color-neutral-50);
    border-color: var(--sl-color-neutral-200);
    color: var(--sl-color-neutral-800);
  }

  .tag--neutral:active > sl-icon-button {
    color: var(--sl-color-neutral-600);
  }

  .tag--warning {
    background-color: var(--sl-color-warning-50);
    border-color: var(--sl-color-warning-200);
    color: var(--sl-color-warning-800);
  }

  .tag--warning:active > sl-icon-button {
    color: var(--sl-color-warning-600);
  }

  .tag--danger {
    background-color: var(--sl-color-danger-50);
    border-color: var(--sl-color-danger-200);
    color: var(--sl-color-danger-800);
  }

  .tag--danger:active > sl-icon-button {
    color: var(--sl-color-danger-600);
  }

  /*
   * Size modifiers
   */

  .tag--small {
    font-size: var(--sl-button-font-size-small);
    height: calc(var(--sl-input-height-small) * 0.8);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
    padding: 0 var(--sl-spacing-x-small);
  }

  .tag--medium {
    font-size: var(--sl-button-font-size-medium);
    height: calc(var(--sl-input-height-medium) * 0.8);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
    padding: 0 var(--sl-spacing-small);
  }

  .tag--large {
    font-size: var(--sl-button-font-size-large);
    height: calc(var(--sl-input-height-large) * 0.8);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
    padding: 0 var(--sl-spacing-medium);
  }

  .tag__remove {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /*
   * Pill modifier
   */

  .tag--pill {
    border-radius: var(--sl-border-radius-pill);
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.6I2T3DLI.js
var icon_button_styles_default = i`
  :host {
    display: inline-block;
    color: var(--sl-color-neutral-600);
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus-visible:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .icon-button__icon {
    pointer-events: none;
  }
`;

// src/node_modules/lit-html/static.js
var $e = Symbol.for("");
var xe = (t8) => {
  if (t8?.r === $e) return t8?._$litStatic$;
};
var er = (t8, ...r9) => ({ _$litStatic$: r9.reduce((r10, e10, a3) => r10 + ((t9) => {
  if (void 0 !== t9._$litStatic$) return t9._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t9}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(e10) + t8[a3 + 1], t8[0]), r: $e });
var Te = /* @__PURE__ */ new Map();
var Ee = (t8) => (r9, ...e10) => {
  const a3 = e10.length;
  let o7, s6;
  const i5 = [], l3 = [];
  let n7, u3 = 0, c6 = false;
  for (; u3 < a3; ) {
    for (n7 = r9[u3]; u3 < a3 && void 0 !== (s6 = e10[u3], o7 = xe(s6)); ) n7 += o7 + r9[++u3], c6 = true;
    u3 !== a3 && l3.push(s6), i5.push(n7), u3++;
  }
  if (u3 === a3 && i5.push(r9[a3]), c6) {
    const t9 = i5.join("$$lit$$");
    void 0 === (r9 = Te.get(t9)) && (i5.raw = i5, Te.set(t9, r9 = i5)), e10 = l3;
  }
  return t8(r9, ...e10);
};
var ke3 = Ee(ke);
var Oe3 = Ee(Oe);
var Se3 = Ee(Se);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.WQ4LAAP4.js
var SlIconButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasFocus = false;
    this.label = "";
    this.disabled = false;
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick(event) {
    if (this.disabled) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  /** Simulates a click on the icon button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the icon button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the icon button. */
  blur() {
    this.button.blur();
  }
  render() {
    const isLink = this.href ? true : false;
    const tag = isLink ? er`a` : er`button`;
    return ke3`
      <${tag}
        part="base"
        class=${Rt({
      "icon-button": true,
      "icon-button--disabled": !isLink && this.disabled,
      "icon-button--focused": this.hasFocus
    })}
        ?disabled=${to(isLink ? void 0 : this.disabled)}
        type=${to(isLink ? void 0 : "button")}
        href=${to(isLink ? this.href : void 0)}
        target=${to(isLink ? this.target : void 0)}
        download=${to(isLink ? this.download : void 0)}
        rel=${to(isLink && this.target ? "noreferrer noopener" : void 0)}
        role=${to(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-label="${this.label}"
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <sl-icon
          class="icon-button__icon"
          name=${to(this.name)}
          library=${to(this.library)}
          src=${to(this.src)}
          aria-hidden="true"
        ></sl-icon>
      </${tag}>
    `;
  }
};
SlIconButton.styles = [component_styles_default, icon_button_styles_default];
SlIconButton.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e7(".icon-button")
], SlIconButton.prototype, "button", 2);
__decorateClass([
  r5()
], SlIconButton.prototype, "hasFocus", 2);
__decorateClass([
  n6()
], SlIconButton.prototype, "name", 2);
__decorateClass([
  n6()
], SlIconButton.prototype, "library", 2);
__decorateClass([
  n6()
], SlIconButton.prototype, "src", 2);
__decorateClass([
  n6()
], SlIconButton.prototype, "href", 2);
__decorateClass([
  n6()
], SlIconButton.prototype, "target", 2);
__decorateClass([
  n6()
], SlIconButton.prototype, "download", 2);
__decorateClass([
  n6()
], SlIconButton.prototype, "label", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlIconButton.prototype, "disabled", 2);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2SC3JQJD.js
var SlTag = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.variant = "neutral";
    this.size = "medium";
    this.pill = false;
    this.removable = false;
  }
  handleRemoveClick() {
    this.emit("sl-remove");
  }
  render() {
    return ke`
      <span
        part="base"
        class=${Rt({
      tag: true,
      // Types
      "tag--primary": this.variant === "primary",
      "tag--success": this.variant === "success",
      "tag--neutral": this.variant === "neutral",
      "tag--warning": this.variant === "warning",
      "tag--danger": this.variant === "danger",
      "tag--text": this.variant === "text",
      // Sizes
      "tag--small": this.size === "small",
      "tag--medium": this.size === "medium",
      "tag--large": this.size === "large",
      // Modifiers
      "tag--pill": this.pill,
      "tag--removable": this.removable
    })}
      >
        <slot part="content" class="tag__content"></slot>

        ${this.removable ? ke`
              <sl-icon-button
                part="remove-button"
                exportparts="base:remove-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("remove")}
                class="tag__remove"
                @click=${this.handleRemoveClick}
                tabindex="-1"
              ></sl-icon-button>
            ` : ""}
      </span>
    `;
  }
};
SlTag.styles = [component_styles_default, tag_styles_default];
SlTag.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass([
  n6({ reflect: true })
], SlTag.prototype, "variant", 2);
__decorateClass([
  n6({ reflect: true })
], SlTag.prototype, "size", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlTag.prototype, "pill", 2);
__decorateClass([
  n6({ type: Boolean })
], SlTag.prototype, "removable", 2);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.IOHAIVO7.js
SlTag.define("sl-tag");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.PS5LPY3Z.js
var textarea_styles_default = i`
  :host {
    display: block;
  }

  .textarea {
    display: flex;
    align-items: center;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
    cursor: text;
  }

  /* Standard textareas */
  .textarea--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .textarea--standard:hover:not(.textarea--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }
  .textarea--standard:hover:not(.textarea--disabled) .textarea__control {
    color: var(--sl-input-color-hover);
  }

  .textarea--standard.textarea--focused:not(.textarea--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    color: var(--sl-input-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .textarea--standard.textarea--focused:not(.textarea--disabled) .textarea__control {
    color: var(--sl-input-color-focus);
  }

  .textarea--standard.textarea--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .textarea--standard.textarea--disabled .textarea__control {
    color: var(--sl-input-color-disabled);
  }

  .textarea--standard.textarea--disabled .textarea__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled textareas */
  .textarea--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .textarea--filled:hover:not(.textarea--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .textarea--filled.textarea--focused:not(.textarea--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .textarea--filled.textarea--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .textarea__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    line-height: 1.4;
    color: var(--sl-input-color);
    border: none;
    background: none;
    box-shadow: none;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .textarea__control::-webkit-search-decoration,
  .textarea__control::-webkit-search-cancel-button,
  .textarea__control::-webkit-search-results-button,
  .textarea__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .textarea__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
    -webkit-user-select: none;
  }

  .textarea__control:focus {
    outline: none;
  }

  /*
   * Size modifiers
   */

  .textarea--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
  }

  .textarea--small .textarea__control {
    padding: 0.5em var(--sl-input-spacing-small);
  }

  .textarea--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .textarea--medium .textarea__control {
    padding: 0.5em var(--sl-input-spacing-medium);
  }

  .textarea--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
  }

  .textarea--large .textarea__control {
    padding: 0.5em var(--sl-input-spacing-large);
  }

  /*
   * Resize types
   */

  .textarea--resize-none .textarea__control {
    resize: none;
  }

  .textarea--resize-vertical .textarea__control {
    resize: vertical;
  }

  .textarea--resize-auto .textarea__control {
    height: auto;
    resize: none;
    overflow-y: hidden;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.IHBOOL5P.js
var SlTextarea = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    });
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.hasFocus = false;
    this.title = "";
    this.name = "";
    this.value = "";
    this.size = "medium";
    this.filled = false;
    this.label = "";
    this.helpText = "";
    this.placeholder = "";
    this.rows = 4;
    this.resize = "vertical";
    this.disabled = false;
    this.readonly = false;
    this.form = "";
    this.required = false;
    this.spellcheck = true;
    this.defaultValue = "";
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver(() => this.setTextareaHeight());
    this.updateComplete.then(() => {
      this.setTextareaHeight();
      this.resizeObserver.observe(this.input);
    });
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.resizeObserver.unobserve(this.input);
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleChange() {
    this.value = this.input.value;
    this.setTextareaHeight();
    this.emit("sl-change");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleInput() {
    this.value = this.input.value;
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  setTextareaHeight() {
    if (this.resize === "auto") {
      this.input.style.height = "auto";
      this.input.style.height = `${this.input.scrollHeight}px`;
    } else {
      this.input.style.height = void 0;
    }
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleRowsChange() {
    this.setTextareaHeight();
  }
  async handleValueChange() {
    await this.updateComplete;
    this.formControlController.updateValidity();
    this.setTextareaHeight();
  }
  /** Sets focus on the textarea. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the textarea. */
  blur() {
    this.input.blur();
  }
  /** Selects all the text in the textarea. */
  select() {
    this.input.select();
  }
  /** Gets or sets the textarea's scroll position. */
  scrollPosition(position) {
    if (position) {
      if (typeof position.top === "number")
        this.input.scrollTop = position.top;
      if (typeof position.left === "number")
        this.input.scrollLeft = position.left;
      return void 0;
    }
    return {
      top: this.input.scrollTop,
      left: this.input.scrollTop
    };
  }
  /** Sets the start and end positions of the text selection (0-based). */
  setSelectionRange(selectionStart, selectionEnd, selectionDirection = "none") {
    this.input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
  }
  /** Replaces a range of text with a new string. */
  setRangeText(replacement, start, end, selectMode = "preserve") {
    const selectionStart = start != null ? start : this.input.selectionStart;
    const selectionEnd = end != null ? end : this.input.selectionEnd;
    this.input.setRangeText(replacement, selectionStart, selectionEnd, selectMode);
    if (this.value !== this.input.value) {
      this.value = this.input.value;
      this.setTextareaHeight();
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return ke`
      <div
        part="form-control"
        class=${Rt({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${Rt({
      textarea: true,
      "textarea--small": this.size === "small",
      "textarea--medium": this.size === "medium",
      "textarea--large": this.size === "large",
      "textarea--standard": !this.filled,
      "textarea--filled": this.filled,
      "textarea--disabled": this.disabled,
      "textarea--focused": this.hasFocus,
      "textarea--empty": !this.value,
      "textarea--resize-none": this.resize === "none",
      "textarea--resize-vertical": this.resize === "vertical",
      "textarea--resize-auto": this.resize === "auto"
    })}
          >
            <textarea
              part="textarea"
              id="input"
              class="textarea__control"
              title=${this.title}
              name=${to(this.name)}
              .value=${Ft(this.value)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${to(this.placeholder)}
              rows=${to(this.rows)}
              minlength=${to(this.minlength)}
              maxlength=${to(this.maxlength)}
              autocapitalize=${to(this.autocapitalize)}
              autocorrect=${to(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${to(this.spellcheck)}
              enterkeyhint=${to(this.enterkeyhint)}
              inputmode=${to(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            ></textarea>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlTextarea.styles = [component_styles_default, form_control_styles_default, textarea_styles_default];
__decorateClass([
  e7(".textarea__control")
], SlTextarea.prototype, "input", 2);
__decorateClass([
  r5()
], SlTextarea.prototype, "hasFocus", 2);
__decorateClass([
  n6()
], SlTextarea.prototype, "title", 2);
__decorateClass([
  n6()
], SlTextarea.prototype, "name", 2);
__decorateClass([
  n6()
], SlTextarea.prototype, "value", 2);
__decorateClass([
  n6({ reflect: true })
], SlTextarea.prototype, "size", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlTextarea.prototype, "filled", 2);
__decorateClass([
  n6()
], SlTextarea.prototype, "label", 2);
__decorateClass([
  n6({ attribute: "help-text" })
], SlTextarea.prototype, "helpText", 2);
__decorateClass([
  n6()
], SlTextarea.prototype, "placeholder", 2);
__decorateClass([
  n6({ type: Number })
], SlTextarea.prototype, "rows", 2);
__decorateClass([
  n6()
], SlTextarea.prototype, "resize", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlTextarea.prototype, "disabled", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlTextarea.prototype, "readonly", 2);
__decorateClass([
  n6({ reflect: true })
], SlTextarea.prototype, "form", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlTextarea.prototype, "required", 2);
__decorateClass([
  n6({ type: Number })
], SlTextarea.prototype, "minlength", 2);
__decorateClass([
  n6({ type: Number })
], SlTextarea.prototype, "maxlength", 2);
__decorateClass([
  n6()
], SlTextarea.prototype, "autocapitalize", 2);
__decorateClass([
  n6()
], SlTextarea.prototype, "autocorrect", 2);
__decorateClass([
  n6()
], SlTextarea.prototype, "autocomplete", 2);
__decorateClass([
  n6({ type: Boolean })
], SlTextarea.prototype, "autofocus", 2);
__decorateClass([
  n6()
], SlTextarea.prototype, "enterkeyhint", 2);
__decorateClass([
  n6({
    type: Boolean,
    converter: {
      // Allow "true|false" attribute values but keep the property boolean
      fromAttribute: (value) => !value || value === "false" ? false : true,
      toAttribute: (value) => value ? "true" : "false"
    }
  })
], SlTextarea.prototype, "spellcheck", 2);
__decorateClass([
  n6()
], SlTextarea.prototype, "inputmode", 2);
__decorateClass([
  defaultValue()
], SlTextarea.prototype, "defaultValue", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlTextarea.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("rows", { waitUntilFirstUpdate: true })
], SlTextarea.prototype, "handleRowsChange", 1);
__decorateClass([
  watch("value", { waitUntilFirstUpdate: true })
], SlTextarea.prototype, "handleValueChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TEMNESEP.js
var textarea_default = SlTextarea;
SlTextarea.define("sl-textarea");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.P6JE66YJ.js
var tab_styles_default = i`
  :host {
    display: inline-block;
  }

  .tab {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    border-radius: var(--sl-border-radius-medium);
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-medium) var(--sl-spacing-large);
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
    cursor: pointer;
    transition:
      var(--transition-speed) box-shadow,
      var(--transition-speed) color;
  }

  .tab:hover:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab:focus {
    outline: none;
  }

  .tab:focus-visible:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: calc(-1 * var(--sl-focus-ring-width) - var(--sl-focus-ring-offset));
  }

  .tab.tab--active:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab.tab--closable {
    padding-inline-end: var(--sl-spacing-small);
  }

  .tab.tab--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .tab__close-button {
    font-size: var(--sl-font-size-small);
    margin-inline-start: var(--sl-spacing-small);
  }

  .tab__close-button::part(base) {
    padding: var(--sl-spacing-3x-small);
  }

  @media (forced-colors: active) {
    .tab.tab--active:not(.tab--disabled) {
      outline: solid 1px transparent;
      outline-offset: -3px;
    }
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.K4TPGPP3.js
var id2 = 0;
var SlTab = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.attrId = ++id2;
    this.componentId = `sl-tab-${this.attrId}`;
    this.panel = "";
    this.active = false;
    this.closable = false;
    this.disabled = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "tab");
  }
  handleCloseClick(event) {
    event.stopPropagation();
    this.emit("sl-close");
  }
  handleActiveChange() {
    this.setAttribute("aria-selected", this.active ? "true" : "false");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  /** Sets focus to the tab. */
  focus(options) {
    this.tab.focus(options);
  }
  /** Removes focus from the tab. */
  blur() {
    this.tab.blur();
  }
  render() {
    this.id = this.id.length > 0 ? this.id : this.componentId;
    return ke`
      <div
        part="base"
        class=${Rt({
      tab: true,
      "tab--active": this.active,
      "tab--closable": this.closable,
      "tab--disabled": this.disabled
    })}
        tabindex=${this.disabled ? "-1" : "0"}
      >
        <slot></slot>
        ${this.closable ? ke`
              <sl-icon-button
                part="close-button"
                exportparts="base:close-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("close")}
                class="tab__close-button"
                @click=${this.handleCloseClick}
                tabindex="-1"
              ></sl-icon-button>
            ` : ""}
      </div>
    `;
  }
};
SlTab.styles = [component_styles_default, tab_styles_default];
SlTab.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass([
  e7(".tab")
], SlTab.prototype, "tab", 2);
__decorateClass([
  n6({ reflect: true })
], SlTab.prototype, "panel", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlTab.prototype, "active", 2);
__decorateClass([
  n6({ type: Boolean })
], SlTab.prototype, "closable", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlTab.prototype, "disabled", 2);
__decorateClass([
  watch("active")
], SlTab.prototype, "handleActiveChange", 1);
__decorateClass([
  watch("disabled")
], SlTab.prototype, "handleDisabledChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.DU2ADDTQ.js
SlTab.define("sl-tab");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.G4XIACTT.js
var tab_group_styles_default = i`
  :host {
    --indicator-color: var(--sl-color-primary-600);
    --track-color: var(--sl-color-neutral-200);
    --track-width: 2px;

    display: block;
  }

  .tab-group {
    display: flex;
    border-radius: 0;
  }

  .tab-group__tabs {
    display: flex;
    position: relative;
  }

  .tab-group__indicator {
    position: absolute;
    transition:
      var(--sl-transition-fast) translate ease,
      var(--sl-transition-fast) width ease;
  }

  .tab-group--has-scroll-controls .tab-group__nav-container {
    position: relative;
    padding: 0 var(--sl-spacing-x-large);
  }

  .tab-group__body {
    display: block;
    overflow: auto;
  }

  .tab-group__scroll-button {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    bottom: 0;
    width: var(--sl-spacing-x-large);
  }

  .tab-group__scroll-button--start {
    left: 0;
  }

  .tab-group__scroll-button--end {
    right: 0;
  }

  .tab-group--rtl .tab-group__scroll-button--start {
    left: auto;
    right: 0;
  }

  .tab-group--rtl .tab-group__scroll-button--end {
    left: 0;
    right: auto;
  }

  /*
   * Top
   */

  .tab-group--top {
    flex-direction: column;
  }

  .tab-group--top .tab-group__nav-container {
    order: 1;
  }

  .tab-group--top .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--top .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--top .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-bottom: solid var(--track-width) var(--track-color);
  }

  .tab-group--top .tab-group__indicator {
    bottom: calc(-1 * var(--track-width));
    border-bottom: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--top .tab-group__body {
    order: 2;
  }

  .tab-group--top ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Bottom
   */

  .tab-group--bottom {
    flex-direction: column;
  }

  .tab-group--bottom .tab-group__nav-container {
    order: 2;
  }

  .tab-group--bottom .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--bottom .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--bottom .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-top: solid var(--track-width) var(--track-color);
  }

  .tab-group--bottom .tab-group__indicator {
    top: calc(-1 * var(--track-width));
    border-top: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--bottom .tab-group__body {
    order: 1;
  }

  .tab-group--bottom ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Start
   */

  .tab-group--start {
    flex-direction: row;
  }

  .tab-group--start .tab-group__nav-container {
    order: 1;
  }

  .tab-group--start .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-inline-end: solid var(--track-width) var(--track-color);
  }

  .tab-group--start .tab-group__indicator {
    right: calc(-1 * var(--track-width));
    border-right: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--start.tab-group--rtl .tab-group__indicator {
    right: auto;
    left: calc(-1 * var(--track-width));
  }

  .tab-group--start .tab-group__body {
    flex: 1 1 auto;
    order: 2;
  }

  .tab-group--start ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }

  /*
   * End
   */

  .tab-group--end {
    flex-direction: row;
  }

  .tab-group--end .tab-group__nav-container {
    order: 2;
  }

  .tab-group--end .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-left: solid var(--track-width) var(--track-color);
  }

  .tab-group--end .tab-group__indicator {
    left: calc(-1 * var(--track-width));
    border-inline-start: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--end.tab-group--rtl .tab-group__indicator {
    right: calc(-1 * var(--track-width));
    left: auto;
  }

  .tab-group--end .tab-group__body {
    flex: 1 1 auto;
    order: 1;
  }

  .tab-group--end ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.BTENR4BI.js
function getOffset(element, parent) {
  return {
    top: Math.round(element.getBoundingClientRect().top - parent.getBoundingClientRect().top),
    left: Math.round(element.getBoundingClientRect().left - parent.getBoundingClientRect().left)
  };
}
var locks = /* @__PURE__ */ new Set();
function getScrollbarWidth() {
  const documentWidth = document.documentElement.clientWidth;
  return Math.abs(window.innerWidth - documentWidth);
}
function getExistingBodyPadding() {
  const padding = Number(getComputedStyle(document.body).paddingRight.replace(/px/, ""));
  if (isNaN(padding) || !padding) {
    return 0;
  }
  return padding;
}
function lockBodyScrolling(lockingEl) {
  locks.add(lockingEl);
  if (!document.documentElement.classList.contains("sl-scroll-lock")) {
    const scrollbarWidth = getScrollbarWidth() + getExistingBodyPadding();
    document.documentElement.classList.add("sl-scroll-lock");
    document.documentElement.style.setProperty("--sl-scroll-lock-size", `${scrollbarWidth}px`);
  }
}
function unlockBodyScrolling(lockingEl) {
  locks.delete(lockingEl);
  if (locks.size === 0) {
    document.documentElement.classList.remove("sl-scroll-lock");
    document.documentElement.style.removeProperty("--sl-scroll-lock-size");
  }
}
function scrollIntoView(element, container, direction = "vertical", behavior = "smooth") {
  const offset3 = getOffset(element, container);
  const offsetTop = offset3.top + container.scrollTop;
  const offsetLeft = offset3.left + container.scrollLeft;
  const minX = container.scrollLeft;
  const maxX = container.scrollLeft + container.offsetWidth;
  const minY = container.scrollTop;
  const maxY = container.scrollTop + container.offsetHeight;
  if (direction === "horizontal" || direction === "both") {
    if (offsetLeft < minX) {
      container.scrollTo({ left: offsetLeft, behavior });
    } else if (offsetLeft + element.clientWidth > maxX) {
      container.scrollTo({ left: offsetLeft - container.offsetWidth + element.clientWidth, behavior });
    }
  }
  if (direction === "vertical" || direction === "both") {
    if (offsetTop < minY) {
      container.scrollTo({ top: offsetTop, behavior });
    } else if (offsetTop + element.clientHeight > maxY) {
      container.scrollTo({ top: offsetTop - container.offsetHeight + element.clientHeight, behavior });
    }
  }
}

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ZBVVUYEV.js
var SlTabGroup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.tabs = [];
    this.panels = [];
    this.hasScrollControls = false;
    this.placement = "top";
    this.activation = "auto";
    this.noScrollControls = false;
  }
  connectedCallback() {
    const whenAllDefined = Promise.all([
      customElements.whenDefined("sl-tab"),
      customElements.whenDefined("sl-tab-panel")
    ]);
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver(() => {
      this.repositionIndicator();
      this.updateScrollControls();
    });
    this.mutationObserver = new MutationObserver((mutations) => {
      if (mutations.some((m3) => !["aria-labelledby", "aria-controls"].includes(m3.attributeName))) {
        setTimeout(() => this.setAriaLabels());
      }
      if (mutations.some((m3) => m3.attributeName === "disabled")) {
        this.syncTabsAndPanels();
      }
    });
    this.updateComplete.then(() => {
      this.syncTabsAndPanels();
      this.mutationObserver.observe(this, { attributes: true, childList: true, subtree: true });
      this.resizeObserver.observe(this.nav);
      whenAllDefined.then(() => {
        const intersectionObserver = new IntersectionObserver((entries, observer) => {
          var _a24;
          if (entries[0].intersectionRatio > 0) {
            this.setAriaLabels();
            this.setActiveTab((_a24 = this.getActiveTab()) != null ? _a24 : this.tabs[0], { emitEvents: false });
            observer.unobserve(entries[0].target);
          }
        });
        intersectionObserver.observe(this.tabGroup);
      });
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.mutationObserver.disconnect();
    this.resizeObserver.unobserve(this.nav);
  }
  getAllTabs(options = { includeDisabled: true }) {
    const slot = this.shadowRoot.querySelector('slot[name="nav"]');
    return [...slot.assignedElements()].filter((el) => {
      return options.includeDisabled ? el.tagName.toLowerCase() === "sl-tab" : el.tagName.toLowerCase() === "sl-tab" && !el.disabled;
    });
  }
  getAllPanels() {
    return [...this.body.assignedElements()].filter((el) => el.tagName.toLowerCase() === "sl-tab-panel");
  }
  getActiveTab() {
    return this.tabs.find((el) => el.active);
  }
  handleClick(event) {
    const target = event.target;
    const tab = target.closest("sl-tab");
    const tabGroup = tab == null ? void 0 : tab.closest("sl-tab-group");
    if (tabGroup !== this) {
      return;
    }
    if (tab !== null) {
      this.setActiveTab(tab, { scrollBehavior: "smooth" });
    }
  }
  handleKeyDown(event) {
    const target = event.target;
    const tab = target.closest("sl-tab");
    const tabGroup = tab == null ? void 0 : tab.closest("sl-tab-group");
    if (tabGroup !== this) {
      return;
    }
    if (["Enter", " "].includes(event.key)) {
      if (tab !== null) {
        this.setActiveTab(tab, { scrollBehavior: "smooth" });
        event.preventDefault();
      }
    }
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
      const activeEl = this.tabs.find((t8) => t8.matches(":focus"));
      const isRtl = this.localize.dir() === "rtl";
      if ((activeEl == null ? void 0 : activeEl.tagName.toLowerCase()) === "sl-tab") {
        let index = this.tabs.indexOf(activeEl);
        if (event.key === "Home") {
          index = 0;
        } else if (event.key === "End") {
          index = this.tabs.length - 1;
        } else if (["top", "bottom"].includes(this.placement) && event.key === (isRtl ? "ArrowRight" : "ArrowLeft") || ["start", "end"].includes(this.placement) && event.key === "ArrowUp") {
          index--;
        } else if (["top", "bottom"].includes(this.placement) && event.key === (isRtl ? "ArrowLeft" : "ArrowRight") || ["start", "end"].includes(this.placement) && event.key === "ArrowDown") {
          index++;
        }
        if (index < 0) {
          index = this.tabs.length - 1;
        }
        if (index > this.tabs.length - 1) {
          index = 0;
        }
        this.tabs[index].focus({ preventScroll: true });
        if (this.activation === "auto") {
          this.setActiveTab(this.tabs[index], { scrollBehavior: "smooth" });
        }
        if (["top", "bottom"].includes(this.placement)) {
          scrollIntoView(this.tabs[index], this.nav, "horizontal");
        }
        event.preventDefault();
      }
    }
  }
  handleScrollToStart() {
    this.nav.scroll({
      left: this.localize.dir() === "rtl" ? this.nav.scrollLeft + this.nav.clientWidth : this.nav.scrollLeft - this.nav.clientWidth,
      behavior: "smooth"
    });
  }
  handleScrollToEnd() {
    this.nav.scroll({
      left: this.localize.dir() === "rtl" ? this.nav.scrollLeft - this.nav.clientWidth : this.nav.scrollLeft + this.nav.clientWidth,
      behavior: "smooth"
    });
  }
  setActiveTab(tab, options) {
    options = __spreadValues({
      emitEvents: true,
      scrollBehavior: "auto"
    }, options);
    if (tab !== this.activeTab && !tab.disabled) {
      const previousTab = this.activeTab;
      this.activeTab = tab;
      this.tabs.forEach((el) => el.active = el === this.activeTab);
      this.panels.forEach((el) => {
        var _a24;
        return el.active = el.name === ((_a24 = this.activeTab) == null ? void 0 : _a24.panel);
      });
      this.syncIndicator();
      if (["top", "bottom"].includes(this.placement)) {
        scrollIntoView(this.activeTab, this.nav, "horizontal", options.scrollBehavior);
      }
      if (options.emitEvents) {
        if (previousTab) {
          this.emit("sl-tab-hide", { detail: { name: previousTab.panel } });
        }
        this.emit("sl-tab-show", { detail: { name: this.activeTab.panel } });
      }
    }
  }
  setAriaLabels() {
    this.tabs.forEach((tab) => {
      const panel = this.panels.find((el) => el.name === tab.panel);
      if (panel) {
        tab.setAttribute("aria-controls", panel.getAttribute("id"));
        panel.setAttribute("aria-labelledby", tab.getAttribute("id"));
      }
    });
  }
  repositionIndicator() {
    const currentTab = this.getActiveTab();
    if (!currentTab) {
      return;
    }
    const width = currentTab.clientWidth;
    const height = currentTab.clientHeight;
    const isRtl = this.localize.dir() === "rtl";
    const allTabs = this.getAllTabs();
    const precedingTabs = allTabs.slice(0, allTabs.indexOf(currentTab));
    const offset3 = precedingTabs.reduce(
      (previous, current) => ({
        left: previous.left + current.clientWidth,
        top: previous.top + current.clientHeight
      }),
      { left: 0, top: 0 }
    );
    switch (this.placement) {
      case "top":
      case "bottom":
        this.indicator.style.width = `${width}px`;
        this.indicator.style.height = "auto";
        this.indicator.style.translate = isRtl ? `${-1 * offset3.left}px` : `${offset3.left}px`;
        break;
      case "start":
      case "end":
        this.indicator.style.width = "auto";
        this.indicator.style.height = `${height}px`;
        this.indicator.style.translate = `0 ${offset3.top}px`;
        break;
    }
  }
  // This stores tabs and panels so we can refer to a cache instead of calling querySelectorAll() multiple times.
  syncTabsAndPanels() {
    this.tabs = this.getAllTabs({ includeDisabled: false });
    this.panels = this.getAllPanels();
    this.syncIndicator();
    this.updateComplete.then(() => this.updateScrollControls());
  }
  updateScrollControls() {
    if (this.noScrollControls) {
      this.hasScrollControls = false;
    } else {
      this.hasScrollControls = ["top", "bottom"].includes(this.placement) && this.nav.scrollWidth > this.nav.clientWidth + 1;
    }
  }
  syncIndicator() {
    const tab = this.getActiveTab();
    if (tab) {
      this.indicator.style.display = "block";
      this.repositionIndicator();
    } else {
      this.indicator.style.display = "none";
    }
  }
  /** Shows the specified tab panel. */
  show(panel) {
    const tab = this.tabs.find((el) => el.panel === panel);
    if (tab) {
      this.setActiveTab(tab, { scrollBehavior: "smooth" });
    }
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    return ke`
      <div
        part="base"
        class=${Rt({
      "tab-group": true,
      "tab-group--top": this.placement === "top",
      "tab-group--bottom": this.placement === "bottom",
      "tab-group--start": this.placement === "start",
      "tab-group--end": this.placement === "end",
      "tab-group--rtl": this.localize.dir() === "rtl",
      "tab-group--has-scroll-controls": this.hasScrollControls
    })}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
      >
        <div class="tab-group__nav-container" part="nav">
          ${this.hasScrollControls ? ke`
                <sl-icon-button
                  part="scroll-button scroll-button--start"
                  exportparts="base:scroll-button__base"
                  class="tab-group__scroll-button tab-group__scroll-button--start"
                  name=${isRtl ? "chevron-right" : "chevron-left"}
                  library="system"
                  label=${this.localize.term("scrollToStart")}
                  @click=${this.handleScrollToStart}
                ></sl-icon-button>
              ` : ""}

          <div class="tab-group__nav">
            <div part="tabs" class="tab-group__tabs" role="tablist">
              <div part="active-tab-indicator" class="tab-group__indicator"></div>
              <slot name="nav" @slotchange=${this.syncTabsAndPanels}></slot>
            </div>
          </div>

          ${this.hasScrollControls ? ke`
                <sl-icon-button
                  part="scroll-button scroll-button--end"
                  exportparts="base:scroll-button__base"
                  class="tab-group__scroll-button tab-group__scroll-button--end"
                  name=${isRtl ? "chevron-left" : "chevron-right"}
                  library="system"
                  label=${this.localize.term("scrollToEnd")}
                  @click=${this.handleScrollToEnd}
                ></sl-icon-button>
              ` : ""}
        </div>

        <slot part="body" class="tab-group__body" @slotchange=${this.syncTabsAndPanels}></slot>
      </div>
    `;
  }
};
SlTabGroup.styles = [component_styles_default, tab_group_styles_default];
SlTabGroup.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass([
  e7(".tab-group")
], SlTabGroup.prototype, "tabGroup", 2);
__decorateClass([
  e7(".tab-group__body")
], SlTabGroup.prototype, "body", 2);
__decorateClass([
  e7(".tab-group__nav")
], SlTabGroup.prototype, "nav", 2);
__decorateClass([
  e7(".tab-group__indicator")
], SlTabGroup.prototype, "indicator", 2);
__decorateClass([
  r5()
], SlTabGroup.prototype, "hasScrollControls", 2);
__decorateClass([
  n6()
], SlTabGroup.prototype, "placement", 2);
__decorateClass([
  n6()
], SlTabGroup.prototype, "activation", 2);
__decorateClass([
  n6({ attribute: "no-scroll-controls", type: Boolean })
], SlTabGroup.prototype, "noScrollControls", 2);
__decorateClass([
  watch("noScrollControls", { waitUntilFirstUpdate: true })
], SlTabGroup.prototype, "updateScrollControls", 1);
__decorateClass([
  watch("placement", { waitUntilFirstUpdate: true })
], SlTabGroup.prototype, "syncIndicator", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.PYWN6ES2.js
SlTabGroup.define("sl-tab-group");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7LFOY25T.js
SlSpinner.define("sl-spinner");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.UAYXD3AN.js
var split_panel_styles_default = i`
  :host {
    --divider-width: 4px;
    --divider-hit-area: 12px;
    --min: 0%;
    --max: 100%;

    display: grid;
  }

  .start,
  .end {
    overflow: hidden;
  }

  .divider {
    flex: 0 0 var(--divider-width);
    display: flex;
    position: relative;
    align-items: center;
    justify-content: center;
    background-color: var(--sl-color-neutral-200);
    color: var(--sl-color-neutral-900);
    z-index: 1;
  }

  .divider:focus {
    outline: none;
  }

  :host(:not([disabled])) .divider:focus-visible {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  :host([disabled]) .divider {
    cursor: not-allowed;
  }

  /* Horizontal */
  :host(:not([vertical], [disabled])) .divider {
    cursor: col-resize;
  }

  :host(:not([vertical])) .divider::after {
    display: flex;
    content: '';
    position: absolute;
    height: 100%;
    left: calc(var(--divider-hit-area) / -2 + var(--divider-width) / 2);
    width: var(--divider-hit-area);
  }

  /* Vertical */
  :host([vertical]) {
    flex-direction: column;
  }

  :host([vertical]:not([disabled])) .divider {
    cursor: row-resize;
  }

  :host([vertical]) .divider::after {
    content: '';
    position: absolute;
    width: 100%;
    top: calc(var(--divider-hit-area) / -2 + var(--divider-width) / 2);
    height: var(--divider-hit-area);
  }

  @media (forced-colors: active) {
    .divider {
      outline: solid 1px transparent;
    }
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ESELY2US.js
function drag(container, options) {
  function move(pointerEvent) {
    const dims = container.getBoundingClientRect();
    const defaultView = container.ownerDocument.defaultView;
    const offsetX = dims.left + defaultView.scrollX;
    const offsetY = dims.top + defaultView.scrollY;
    const x4 = pointerEvent.pageX - offsetX;
    const y3 = pointerEvent.pageY - offsetY;
    if (options == null ? void 0 : options.onMove) {
      options.onMove(x4, y3);
    }
  }
  function stop() {
    document.removeEventListener("pointermove", move);
    document.removeEventListener("pointerup", stop);
    if (options == null ? void 0 : options.onStop) {
      options.onStop();
    }
  }
  document.addEventListener("pointermove", move, { passive: true });
  document.addEventListener("pointerup", stop);
  if ((options == null ? void 0 : options.initialEvent) instanceof PointerEvent) {
    move(options.initialEvent);
  }
}

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.VDCOYJJY.js
var SlSplitPanel = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.position = 50;
    this.vertical = false;
    this.disabled = false;
    this.snapThreshold = 12;
  }
  connectedCallback() {
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver((entries) => this.handleResize(entries));
    this.updateComplete.then(() => this.resizeObserver.observe(this));
    this.detectSize();
    this.cachedPositionInPixels = this.percentageToPixels(this.position);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.resizeObserver.unobserve(this);
  }
  detectSize() {
    const { width, height } = this.getBoundingClientRect();
    this.size = this.vertical ? height : width;
  }
  percentageToPixels(value) {
    return this.size * (value / 100);
  }
  pixelsToPercentage(value) {
    return value / this.size * 100;
  }
  handleDrag(event) {
    const isRtl = this.localize.dir() === "rtl";
    if (this.disabled) {
      return;
    }
    if (event.cancelable) {
      event.preventDefault();
    }
    drag(this, {
      onMove: (x4, y3) => {
        let newPositionInPixels = this.vertical ? y3 : x4;
        if (this.primary === "end") {
          newPositionInPixels = this.size - newPositionInPixels;
        }
        if (this.snap) {
          const snaps = this.snap.split(" ");
          snaps.forEach((value) => {
            let snapPoint;
            if (value.endsWith("%")) {
              snapPoint = this.size * (parseFloat(value) / 100);
            } else {
              snapPoint = parseFloat(value);
            }
            if (isRtl && !this.vertical) {
              snapPoint = this.size - snapPoint;
            }
            if (newPositionInPixels >= snapPoint - this.snapThreshold && newPositionInPixels <= snapPoint + this.snapThreshold) {
              newPositionInPixels = snapPoint;
            }
          });
        }
        this.position = clamp2(this.pixelsToPercentage(newPositionInPixels), 0, 100);
      },
      initialEvent: event
    });
  }
  handleKeyDown(event) {
    if (this.disabled) {
      return;
    }
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
      let newPosition = this.position;
      const incr = (event.shiftKey ? 10 : 1) * (this.primary === "end" ? -1 : 1);
      event.preventDefault();
      if (event.key === "ArrowLeft" && !this.vertical || event.key === "ArrowUp" && this.vertical) {
        newPosition -= incr;
      }
      if (event.key === "ArrowRight" && !this.vertical || event.key === "ArrowDown" && this.vertical) {
        newPosition += incr;
      }
      if (event.key === "Home") {
        newPosition = this.primary === "end" ? 100 : 0;
      }
      if (event.key === "End") {
        newPosition = this.primary === "end" ? 0 : 100;
      }
      this.position = clamp2(newPosition, 0, 100);
    }
  }
  handleResize(entries) {
    const { width, height } = entries[0].contentRect;
    this.size = this.vertical ? height : width;
    if (this.primary) {
      this.position = this.pixelsToPercentage(this.cachedPositionInPixels);
    }
  }
  handlePositionChange() {
    this.cachedPositionInPixels = this.percentageToPixels(this.position);
    this.positionInPixels = this.percentageToPixels(this.position);
    this.emit("sl-reposition");
  }
  handlePositionInPixelsChange() {
    this.position = this.pixelsToPercentage(this.positionInPixels);
  }
  handleVerticalChange() {
    this.detectSize();
  }
  render() {
    const gridTemplate = this.vertical ? "gridTemplateRows" : "gridTemplateColumns";
    const gridTemplateAlt = this.vertical ? "gridTemplateColumns" : "gridTemplateRows";
    const isRtl = this.localize.dir() === "rtl";
    const primary = `
      clamp(
        0%,
        clamp(
          var(--min),
          ${this.position}% - var(--divider-width) / 2,
          var(--max)
        ),
        calc(100% - var(--divider-width))
      )
    `;
    const secondary = "auto";
    if (this.primary === "end") {
      if (isRtl && !this.vertical) {
        this.style[gridTemplate] = `${primary} var(--divider-width) ${secondary}`;
      } else {
        this.style[gridTemplate] = `${secondary} var(--divider-width) ${primary}`;
      }
    } else {
      if (isRtl && !this.vertical) {
        this.style[gridTemplate] = `${secondary} var(--divider-width) ${primary}`;
      } else {
        this.style[gridTemplate] = `${primary} var(--divider-width) ${secondary}`;
      }
    }
    this.style[gridTemplateAlt] = "";
    return ke`
      <slot name="start" part="panel start" class="start"></slot>

      <div
        part="divider"
        class="divider"
        tabindex=${to(this.disabled ? void 0 : "0")}
        role="separator"
        aria-valuenow=${this.position}
        aria-valuemin="0"
        aria-valuemax="100"
        aria-label=${this.localize.term("resize")}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleDrag}
        @touchstart=${this.handleDrag}
      >
        <slot name="divider"></slot>
      </div>

      <slot name="end" part="panel end" class="end"></slot>
    `;
  }
};
SlSplitPanel.styles = [component_styles_default, split_panel_styles_default];
__decorateClass([
  e7(".divider")
], SlSplitPanel.prototype, "divider", 2);
__decorateClass([
  n6({ type: Number, reflect: true })
], SlSplitPanel.prototype, "position", 2);
__decorateClass([
  n6({ attribute: "position-in-pixels", type: Number })
], SlSplitPanel.prototype, "positionInPixels", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlSplitPanel.prototype, "vertical", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlSplitPanel.prototype, "disabled", 2);
__decorateClass([
  n6()
], SlSplitPanel.prototype, "primary", 2);
__decorateClass([
  n6()
], SlSplitPanel.prototype, "snap", 2);
__decorateClass([
  n6({ type: Number, attribute: "snap-threshold" })
], SlSplitPanel.prototype, "snapThreshold", 2);
__decorateClass([
  watch("position")
], SlSplitPanel.prototype, "handlePositionChange", 1);
__decorateClass([
  watch("positionInPixels")
], SlSplitPanel.prototype, "handlePositionInPixelsChange", 1);
__decorateClass([
  watch("vertical")
], SlSplitPanel.prototype, "handleVerticalChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GBUTRKE2.js
SlSplitPanel.define("sl-split-panel");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.EU44RQUN.js
var switch_styles_default = i`
  :host {
    display: inline-block;
  }

  :host([size='small']) {
    --height: var(--sl-toggle-size-small);
    --thumb-size: calc(var(--sl-toggle-size-small) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-small);
  }

  :host([size='medium']) {
    --height: var(--sl-toggle-size-medium);
    --thumb-size: calc(var(--sl-toggle-size-medium) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-medium);
  }

  :host([size='large']) {
    --height: var(--sl-toggle-size-large);
    --thumb-size: calc(var(--sl-toggle-size-large) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-large);
  }

  .switch {
    position: relative;
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-input-font-family);
    font-size: inherit;
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .switch__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--width);
    height: var(--height);
    background-color: var(--sl-color-neutral-400);
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    border-radius: var(--height);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color;
  }

  .switch__control .switch__thumb {
    width: var(--thumb-size);
    height: var(--thumb-size);
    background-color: var(--sl-color-neutral-0);
    border-radius: 50%;
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    translate: calc((var(--width) - var(--height)) / -2);
    transition:
      var(--sl-transition-fast) translate ease,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) box-shadow;
  }

  .switch__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  /* Hover */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-400);
  }

  /* Focus */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__input:focus-visible ~ .switch__control {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled) .switch__input:focus-visible ~ .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Checked */
  .switch--checked .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch--checked .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    translate: calc((var(--width) - var(--height)) / 2);
  }

  /* Checked + hover */
  .switch.switch--checked:not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
  }

  /* Checked + focus */
  .switch.switch--checked:not(.switch--disabled) .switch__input:focus-visible ~ .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled) .switch__input:focus-visible ~ .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .switch--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .switch__label {
    display: inline-block;
    line-height: var(--height);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }

  :host([required]) .switch__label::after {
    content: var(--sl-input-required-content);
    color: var(--sl-input-required-content-color);
    margin-inline-start: var(--sl-input-required-content-offset);
  }

  @media (forced-colors: active) {
    .switch.switch--checked:not(.switch--disabled) .switch__control:hover .switch__thumb,
    .switch--checked .switch__control .switch__thumb {
      background-color: ButtonText;
    }
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.S33XS33R.js
var SlSwitch = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      value: (control) => control.checked ? control.value || "on" : void 0,
      defaultValue: (control) => control.defaultChecked,
      setValue: (control, checked) => control.checked = checked
    });
    this.hasSlotController = new HasSlotController(this, "help-text");
    this.hasFocus = false;
    this.title = "";
    this.name = "";
    this.size = "medium";
    this.disabled = false;
    this.checked = false;
    this.defaultChecked = false;
    this.form = "";
    this.required = false;
    this.helpText = "";
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleInput() {
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleClick() {
    this.checked = !this.checked;
    this.emit("sl-change");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleKeyDown(event) {
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      this.checked = false;
      this.emit("sl-change");
      this.emit("sl-input");
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      this.checked = true;
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleCheckedChange() {
    this.input.checked = this.checked;
    this.formControlController.updateValidity();
  }
  handleDisabledChange() {
    this.formControlController.setValidity(true);
  }
  /** Simulates a click on the switch. */
  click() {
    this.input.click();
  }
  /** Sets focus on the switch. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the switch. */
  blur() {
    this.input.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return ke`
      <div
        class=${Rt({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="base"
          class=${Rt({
      switch: true,
      "switch--checked": this.checked,
      "switch--disabled": this.disabled,
      "switch--focused": this.hasFocus,
      "switch--small": this.size === "small",
      "switch--medium": this.size === "medium",
      "switch--large": this.size === "large"
    })}
        >
          <input
            class="switch__input"
            type="checkbox"
            title=${this.title}
            name=${this.name}
            value=${to(this.value)}
            .checked=${Ft(this.checked)}
            .disabled=${this.disabled}
            .required=${this.required}
            role="switch"
            aria-checked=${this.checked ? "true" : "false"}
            aria-describedby="help-text"
            @click=${this.handleClick}
            @input=${this.handleInput}
            @invalid=${this.handleInvalid}
            @blur=${this.handleBlur}
            @focus=${this.handleFocus}
            @keydown=${this.handleKeyDown}
          />

          <span part="control" class="switch__control">
            <span part="thumb" class="switch__thumb"></span>
          </span>

          <div part="label" class="switch__label">
            <slot></slot>
          </div>
        </label>

        <div
          aria-hidden=${hasHelpText ? "false" : "true"}
          class="form-control__help-text"
          id="help-text"
          part="form-control-help-text"
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlSwitch.styles = [component_styles_default, form_control_styles_default, switch_styles_default];
__decorateClass([
  e7('input[type="checkbox"]')
], SlSwitch.prototype, "input", 2);
__decorateClass([
  r5()
], SlSwitch.prototype, "hasFocus", 2);
__decorateClass([
  n6()
], SlSwitch.prototype, "title", 2);
__decorateClass([
  n6()
], SlSwitch.prototype, "name", 2);
__decorateClass([
  n6()
], SlSwitch.prototype, "value", 2);
__decorateClass([
  n6({ reflect: true })
], SlSwitch.prototype, "size", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlSwitch.prototype, "disabled", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlSwitch.prototype, "checked", 2);
__decorateClass([
  defaultValue("checked")
], SlSwitch.prototype, "defaultChecked", 2);
__decorateClass([
  n6({ reflect: true })
], SlSwitch.prototype, "form", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlSwitch.prototype, "required", 2);
__decorateClass([
  n6({ attribute: "help-text" })
], SlSwitch.prototype, "helpText", 2);
__decorateClass([
  watch("checked", { waitUntilFirstUpdate: true })
], SlSwitch.prototype, "handleCheckedChange", 1);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlSwitch.prototype, "handleDisabledChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TUJRSXNR.js
var switch_default = SlSwitch;
SlSwitch.define("sl-switch");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.5VKIB4HA.js
var resize_observer_styles_default = i`
  :host {
    display: contents;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.S745IPNZ.js
var SlResizeObserver = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.observedElements = [];
    this.disabled = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver((entries) => {
      this.emit("sl-resize", { detail: { entries } });
    });
    if (!this.disabled) {
      this.startObserver();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stopObserver();
  }
  handleSlotChange() {
    if (!this.disabled) {
      this.startObserver();
    }
  }
  startObserver() {
    const slot = this.shadowRoot.querySelector("slot");
    if (slot !== null) {
      const elements = slot.assignedElements({ flatten: true });
      this.observedElements.forEach((el) => this.resizeObserver.unobserve(el));
      this.observedElements = [];
      elements.forEach((el) => {
        this.resizeObserver.observe(el);
        this.observedElements.push(el);
      });
    }
  }
  stopObserver() {
    this.resizeObserver.disconnect();
  }
  handleDisabledChange() {
    if (this.disabled) {
      this.stopObserver();
    } else {
      this.startObserver();
    }
  }
  render() {
    return ke` <slot @slotchange=${this.handleSlotChange}></slot> `;
  }
};
SlResizeObserver.styles = [component_styles_default, resize_observer_styles_default];
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlResizeObserver.prototype, "disabled", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlResizeObserver.prototype, "handleDisabledChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.CM4CDNC2.js
SlResizeObserver.define("sl-resize-observer");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.AN6YZWTU.js
var select_styles_default = i`
  :host {
    display: block;
  }

  /** The popup */
  .select {
    flex: 1 1 auto;
    display: inline-flex;
    width: 100%;
    position: relative;
    vertical-align: middle;
  }

  .select::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .select[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .select[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  /* Combobox */
  .select__combobox {
    flex: 1;
    display: flex;
    width: 100%;
    min-width: 0;
    position: relative;
    align-items: center;
    justify-content: start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: pointer;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  .select__display-input {
    position: relative;
    width: 100%;
    font: inherit;
    border: none;
    background: none;
    color: var(--sl-input-color);
    cursor: inherit;
    overflow: hidden;
    padding: 0;
    margin: 0;
    -webkit-appearance: none;
  }

  .select__display-input::placeholder {
    color: var(--sl-input-placeholder-color);
  }

  .select:not(.select--disabled):hover .select__display-input {
    color: var(--sl-input-color-hover);
  }

  .select__display-input:focus {
    outline: none;
  }

  /* Visually hide the display input when multiple is enabled */
  .select--multiple:not(.select--placeholder-visible) .select__display-input {
    position: absolute;
    z-index: -1;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
  }

  .select__value-input {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 0;
    margin: 0;
    opacity: 0;
    z-index: -1;
  }

  .select__tags {
    display: flex;
    flex: 1;
    align-items: center;
    flex-wrap: wrap;
    margin-inline-start: var(--sl-spacing-2x-small);
  }

  .select__tags::slotted(sl-tag) {
    cursor: pointer !important;
  }

  .select--disabled .select__tags,
  .select--disabled .select__tags::slotted(sl-tag) {
    cursor: not-allowed !important;
  }

  /* Standard selects */
  .select--standard .select__combobox {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .select--standard.select--disabled .select__combobox {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    color: var(--sl-input-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
    outline: none;
  }

  .select--standard:not(.select--disabled).select--open .select__combobox,
  .select--standard:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  /* Filled selects */
  .select--filled .select__combobox {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .select--filled:hover:not(.select--disabled) .select__combobox {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .select--filled.select--disabled .select__combobox {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .select--filled:not(.select--disabled).select--open .select__combobox,
  .select--filled:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
  }

  /* Sizes */
  .select--small .select__combobox {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    min-height: var(--sl-input-height-small);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-small);
  }

  .select--small .select__clear {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .select--small .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .select--small.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-block: 2px;
    padding-inline-start: 0;
  }

  .select--small .select__tags {
    gap: 2px;
  }

  .select--medium .select__combobox {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    min-height: var(--sl-input-height-medium);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-medium);
  }

  .select--medium .select__clear {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .select--medium .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .select--medium.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 3px;
  }

  .select--medium .select__tags {
    gap: 3px;
  }

  .select--large .select__combobox {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    min-height: var(--sl-input-height-large);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-large);
  }

  .select--large .select__clear {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .select--large .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  .select--large.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 4px;
  }

  .select--large .select__tags {
    gap: 4px;
  }

  /* Pills */
  .select--pill.select--small .select__combobox {
    border-radius: var(--sl-input-height-small);
  }

  .select--pill.select--medium .select__combobox {
    border-radius: var(--sl-input-height-medium);
  }

  .select--pill.select--large .select__combobox {
    border-radius: var(--sl-input-height-large);
  }

  /* Prefix */
  .select__prefix {
    flex: 0;
    display: inline-flex;
    align-items: center;
    color: var(--sl-input-placeholder-color);
  }

  /* Clear button */
  .select__clear {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .select__clear:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .select__clear:focus {
    outline: none;
  }

  /* Expand icon */
  .select__expand-icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    transition: var(--sl-transition-medium) rotate ease;
    rotate: 0;
    margin-inline-start: var(--sl-spacing-small);
  }

  .select--open .select__expand-icon {
    rotate: -180deg;
  }

  /* Listbox */
  .select__listbox {
    display: block;
    position: relative;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding-block: var(--sl-spacing-x-small);
    padding-inline: 0;
    overflow: auto;
    overscroll-behavior: none;

    /* Make sure it adheres to the popup's auto size */
    max-width: var(--auto-size-available-width);
    max-height: var(--auto-size-available-height);
  }

  .select__listbox ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }

  .select__listbox ::slotted(small) {
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    color: var(--sl-color-neutral-500);
    padding-block: var(--sl-spacing-x-small);
    padding-inline: var(--sl-spacing-x-large);
  }
`;

// src/node_modules/lit-html/directives/unsafe-html.js
var le = class extends i4 {
  constructor(i5) {
    if (super(i5), this.it = D, i5.type !== t6.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(t8) {
    if (t8 === D || null == t8) return this._t = void 0, this.it = t8;
    if (t8 === R) return t8;
    if ("string" != typeof t8) throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (t8 === this.it) return this._t;
    this.it = t8;
    const i5 = [t8];
    return i5.raw = i5, this._t = { _$litType$: this.constructor.resultType, strings: i5, values: [] };
  }
};
le.directiveName = "unsafeHTML", le.resultType = 1;
var ae = e9(le);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.XHABG7B5.js
var SlSelect = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    });
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController2(this);
    this.typeToSelectString = "";
    this.hasFocus = false;
    this.displayLabel = "";
    this.selectedOptions = [];
    this.name = "";
    this.value = "";
    this.defaultValue = "";
    this.size = "medium";
    this.placeholder = "";
    this.multiple = false;
    this.maxOptionsVisible = 3;
    this.disabled = false;
    this.clearable = false;
    this.open = false;
    this.hoist = false;
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.placement = "bottom";
    this.helpText = "";
    this.form = "";
    this.required = false;
    this.getTag = (option) => {
      return ke`
      <sl-tag
        part="tag"
        exportparts="
              base:tag__base,
              content:tag__content,
              remove-button:tag__remove-button,
              remove-button__base:tag__remove-button__base
            "
        ?pill=${this.pill}
        size=${this.size}
        removable
        @sl-remove=${(event) => this.handleTagRemove(event, option)}
      >
        ${option.getTextLabel()}
      </sl-tag>
    `;
    };
    this.handleDocumentFocusIn = (event) => {
      const path = event.composedPath();
      if (this && !path.includes(this)) {
        this.hide();
      }
    };
    this.handleDocumentKeyDown = (event) => {
      const target = event.target;
      const isClearButton = target.closest(".select__clear") !== null;
      const isIconButton = target.closest("sl-icon-button") !== null;
      if (isClearButton || isIconButton) {
        return;
      }
      if (event.key === "Escape" && this.open && !this.closeWatcher) {
        event.preventDefault();
        event.stopPropagation();
        this.hide();
        this.displayInput.focus({ preventScroll: true });
      }
      if (event.key === "Enter" || event.key === " " && this.typeToSelectString === "") {
        event.preventDefault();
        event.stopImmediatePropagation();
        if (!this.open) {
          this.show();
          return;
        }
        if (this.currentOption && !this.currentOption.disabled) {
          if (this.multiple) {
            this.toggleOptionSelection(this.currentOption);
          } else {
            this.setSelectedOptions(this.currentOption);
          }
          this.updateComplete.then(() => {
            this.emit("sl-input");
            this.emit("sl-change");
          });
          if (!this.multiple) {
            this.hide();
            this.displayInput.focus({ preventScroll: true });
          }
        }
        return;
      }
      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
        const allOptions = this.getAllOptions();
        const currentIndex = allOptions.indexOf(this.currentOption);
        let newIndex = Math.max(0, currentIndex);
        event.preventDefault();
        if (!this.open) {
          this.show();
          if (this.currentOption) {
            return;
          }
        }
        if (event.key === "ArrowDown") {
          newIndex = currentIndex + 1;
          if (newIndex > allOptions.length - 1)
            newIndex = 0;
        } else if (event.key === "ArrowUp") {
          newIndex = currentIndex - 1;
          if (newIndex < 0)
            newIndex = allOptions.length - 1;
        } else if (event.key === "Home") {
          newIndex = 0;
        } else if (event.key === "End") {
          newIndex = allOptions.length - 1;
        }
        this.setCurrentOption(allOptions[newIndex]);
      }
      if (event.key.length === 1 || event.key === "Backspace") {
        const allOptions = this.getAllOptions();
        if (event.metaKey || event.ctrlKey || event.altKey) {
          return;
        }
        if (!this.open) {
          if (event.key === "Backspace") {
            return;
          }
          this.show();
        }
        event.stopPropagation();
        event.preventDefault();
        clearTimeout(this.typeToSelectTimeout);
        this.typeToSelectTimeout = window.setTimeout(() => this.typeToSelectString = "", 1e3);
        if (event.key === "Backspace") {
          this.typeToSelectString = this.typeToSelectString.slice(0, -1);
        } else {
          this.typeToSelectString += event.key.toLowerCase();
        }
        for (const option of allOptions) {
          const label = option.getTextLabel().toLowerCase();
          if (label.startsWith(this.typeToSelectString)) {
            this.setCurrentOption(option);
            break;
          }
        }
      }
    };
    this.handleDocumentMouseDown = (event) => {
      const path = event.composedPath();
      if (this && !path.includes(this)) {
        this.hide();
      }
    };
  }
  /** Gets the validity state object */
  get validity() {
    return this.valueInput.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.valueInput.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback();
    this.open = false;
  }
  addOpenListeners() {
    var _a24;
    document.addEventListener("focusin", this.handleDocumentFocusIn);
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
    if (this.getRootNode() !== document) {
      this.getRootNode().addEventListener("focusin", this.handleDocumentFocusIn);
    }
    if ("CloseWatcher" in window) {
      (_a24 = this.closeWatcher) == null ? void 0 : _a24.destroy();
      this.closeWatcher = new CloseWatcher();
      this.closeWatcher.onclose = () => {
        if (this.open) {
          this.hide();
          this.displayInput.focus({ preventScroll: true });
        }
      };
    }
  }
  removeOpenListeners() {
    var _a24;
    document.removeEventListener("focusin", this.handleDocumentFocusIn);
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
    if (this.getRootNode() !== document) {
      this.getRootNode().removeEventListener("focusin", this.handleDocumentFocusIn);
    }
    (_a24 = this.closeWatcher) == null ? void 0 : _a24.destroy();
  }
  handleFocus() {
    this.hasFocus = true;
    this.displayInput.setSelectionRange(0, 0);
    this.emit("sl-focus");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleLabelClick() {
    this.displayInput.focus();
  }
  handleComboboxMouseDown(event) {
    const path = event.composedPath();
    const isIconButton = path.some((el) => el instanceof Element && el.tagName.toLowerCase() === "sl-icon-button");
    if (this.disabled || isIconButton) {
      return;
    }
    event.preventDefault();
    this.displayInput.focus({ preventScroll: true });
    this.open = !this.open;
  }
  handleComboboxKeyDown(event) {
    if (event.key === "Tab") {
      return;
    }
    event.stopPropagation();
    this.handleDocumentKeyDown(event);
  }
  handleClearClick(event) {
    event.stopPropagation();
    if (this.value !== "") {
      this.setSelectedOptions([]);
      this.displayInput.focus({ preventScroll: true });
      this.updateComplete.then(() => {
        this.emit("sl-clear");
        this.emit("sl-input");
        this.emit("sl-change");
      });
    }
  }
  handleClearMouseDown(event) {
    event.stopPropagation();
    event.preventDefault();
  }
  handleOptionClick(event) {
    const target = event.target;
    const option = target.closest("sl-option");
    const oldValue = this.value;
    if (option && !option.disabled) {
      if (this.multiple) {
        this.toggleOptionSelection(option);
      } else {
        this.setSelectedOptions(option);
      }
      this.updateComplete.then(() => this.displayInput.focus({ preventScroll: true }));
      if (this.value !== oldValue) {
        this.updateComplete.then(() => {
          this.emit("sl-input");
          this.emit("sl-change");
        });
      }
      if (!this.multiple) {
        this.hide();
        this.displayInput.focus({ preventScroll: true });
      }
    }
  }
  handleDefaultSlotChange() {
    const allOptions = this.getAllOptions();
    const value = Array.isArray(this.value) ? this.value : [this.value];
    const values = [];
    if (customElements.get("sl-option")) {
      allOptions.forEach((option) => values.push(option.value));
      this.setSelectedOptions(allOptions.filter((el) => value.includes(el.value)));
    } else {
      customElements.whenDefined("sl-option").then(() => this.handleDefaultSlotChange());
    }
  }
  handleTagRemove(event, option) {
    event.stopPropagation();
    if (!this.disabled) {
      this.toggleOptionSelection(option, false);
      this.updateComplete.then(() => {
        this.emit("sl-input");
        this.emit("sl-change");
      });
    }
  }
  // Gets an array of all <sl-option> elements
  getAllOptions() {
    return [...this.querySelectorAll("sl-option")];
  }
  // Gets the first <sl-option> element
  getFirstOption() {
    return this.querySelector("sl-option");
  }
  // Sets the current option, which is the option the user is currently interacting with (e.g. via keyboard). Only one
  // option may be "current" at a time.
  setCurrentOption(option) {
    const allOptions = this.getAllOptions();
    allOptions.forEach((el) => {
      el.current = false;
      el.tabIndex = -1;
    });
    if (option) {
      this.currentOption = option;
      option.current = true;
      option.tabIndex = 0;
      option.focus();
    }
  }
  // Sets the selected option(s)
  setSelectedOptions(option) {
    const allOptions = this.getAllOptions();
    const newSelectedOptions = Array.isArray(option) ? option : [option];
    allOptions.forEach((el) => el.selected = false);
    if (newSelectedOptions.length) {
      newSelectedOptions.forEach((el) => el.selected = true);
    }
    this.selectionChanged();
  }
  // Toggles an option's selected state
  toggleOptionSelection(option, force) {
    if (force === true || force === false) {
      option.selected = force;
    } else {
      option.selected = !option.selected;
    }
    this.selectionChanged();
  }
  // This method must be called whenever the selection changes. It will update the selected options cache, the current
  // value, and the display value
  selectionChanged() {
    var _a24, _b, _c, _d;
    this.selectedOptions = this.getAllOptions().filter((el) => el.selected);
    if (this.multiple) {
      this.value = this.selectedOptions.map((el) => el.value);
      if (this.placeholder && this.value.length === 0) {
        this.displayLabel = "";
      } else {
        this.displayLabel = this.localize.term("numOptionsSelected", this.selectedOptions.length);
      }
    } else {
      this.value = (_b = (_a24 = this.selectedOptions[0]) == null ? void 0 : _a24.value) != null ? _b : "";
      this.displayLabel = (_d = (_c = this.selectedOptions[0]) == null ? void 0 : _c.getTextLabel()) != null ? _d : "";
    }
    this.updateComplete.then(() => {
      this.formControlController.updateValidity();
    });
  }
  get tags() {
    return this.selectedOptions.map((option, index) => {
      if (index < this.maxOptionsVisible || this.maxOptionsVisible <= 0) {
        const tag = this.getTag(option, index);
        return ke`<div @sl-remove=${(e10) => this.handleTagRemove(e10, option)}>
          ${typeof tag === "string" ? ae(tag) : tag}
        </div>`;
      } else if (index === this.maxOptionsVisible) {
        return ke`<sl-tag size=${this.size}>+${this.selectedOptions.length - index}</sl-tag>`;
      }
      return ke``;
    });
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleDisabledChange() {
    if (this.disabled) {
      this.open = false;
      this.handleOpenChange();
    }
  }
  handleValueChange() {
    const allOptions = this.getAllOptions();
    const value = Array.isArray(this.value) ? this.value : [this.value];
    this.setSelectedOptions(allOptions.filter((el) => value.includes(el.value)));
  }
  async handleOpenChange() {
    if (this.open && !this.disabled) {
      this.setCurrentOption(this.selectedOptions[0] || this.getFirstOption());
      this.emit("sl-show");
      this.addOpenListeners();
      await stopAnimations(this);
      this.listbox.hidden = false;
      this.popup.active = true;
      requestAnimationFrame(() => {
        this.setCurrentOption(this.currentOption);
      });
      const { keyframes, options } = getAnimation(this, "select.show", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      if (this.currentOption) {
        scrollIntoView(this.currentOption, this.listbox, "vertical", "auto");
      }
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      await stopAnimations(this);
      const { keyframes, options } = getAnimation(this, "select.hide", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      this.listbox.hidden = true;
      this.popup.active = false;
      this.emit("sl-after-hide");
    }
  }
  /** Shows the listbox. */
  async show() {
    if (this.open || this.disabled) {
      this.open = false;
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the listbox. */
  async hide() {
    if (!this.open || this.disabled) {
      this.open = false;
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.valueInput.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.valueInput.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.valueInput.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  /** Sets focus on the control. */
  focus(options) {
    this.displayInput.focus(options);
  }
  /** Removes focus from the control. */
  blur() {
    this.displayInput.blur();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const hasClearIcon = this.clearable && !this.disabled && this.value.length > 0;
    const isPlaceholderVisible = this.placeholder && this.value.length === 0;
    return ke`
      <div
        part="form-control"
        class=${Rt({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          id="label"
          part="form-control-label"
          class="form-control__label"
          aria-hidden=${hasLabel ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <sl-popup
            class=${Rt({
      select: true,
      "select--standard": true,
      "select--filled": this.filled,
      "select--pill": this.pill,
      "select--open": this.open,
      "select--disabled": this.disabled,
      "select--multiple": this.multiple,
      "select--focused": this.hasFocus,
      "select--placeholder-visible": isPlaceholderVisible,
      "select--top": this.placement === "top",
      "select--bottom": this.placement === "bottom",
      "select--small": this.size === "small",
      "select--medium": this.size === "medium",
      "select--large": this.size === "large"
    })}
            placement=${this.placement}
            strategy=${this.hoist ? "fixed" : "absolute"}
            flip
            shift
            sync="width"
            auto-size="vertical"
            auto-size-padding="10"
          >
            <div
              part="combobox"
              class="select__combobox"
              slot="anchor"
              @keydown=${this.handleComboboxKeyDown}
              @mousedown=${this.handleComboboxMouseDown}
            >
              <slot part="prefix" name="prefix" class="select__prefix"></slot>

              <input
                part="display-input"
                class="select__display-input"
                type="text"
                placeholder=${this.placeholder}
                .disabled=${this.disabled}
                .value=${this.displayLabel}
                autocomplete="off"
                spellcheck="false"
                autocapitalize="off"
                readonly
                aria-controls="listbox"
                aria-expanded=${this.open ? "true" : "false"}
                aria-haspopup="listbox"
                aria-labelledby="label"
                aria-disabled=${this.disabled ? "true" : "false"}
                aria-describedby="help-text"
                role="combobox"
                tabindex="0"
                @focus=${this.handleFocus}
                @blur=${this.handleBlur}
              />

              ${this.multiple ? ke`<div part="tags" class="select__tags">${this.tags}</div>` : ""}

              <input
                class="select__value-input"
                type="text"
                ?disabled=${this.disabled}
                ?required=${this.required}
                .value=${Array.isArray(this.value) ? this.value.join(", ") : this.value}
                tabindex="-1"
                aria-hidden="true"
                @focus=${() => this.focus()}
                @invalid=${this.handleInvalid}
              />

              ${hasClearIcon ? ke`
                    <button
                      part="clear-button"
                      class="select__clear"
                      type="button"
                      aria-label=${this.localize.term("clearEntry")}
                      @mousedown=${this.handleClearMouseDown}
                      @click=${this.handleClearClick}
                      tabindex="-1"
                    >
                      <slot name="clear-icon">
                        <sl-icon name="x-circle-fill" library="system"></sl-icon>
                      </slot>
                    </button>
                  ` : ""}

              <slot name="expand-icon" part="expand-icon" class="select__expand-icon">
                <sl-icon library="system" name="chevron-down"></sl-icon>
              </slot>
            </div>

            <div
              id="listbox"
              role="listbox"
              aria-expanded=${this.open ? "true" : "false"}
              aria-multiselectable=${this.multiple ? "true" : "false"}
              aria-labelledby="label"
              part="listbox"
              class="select__listbox"
              tabindex="-1"
              @mouseup=${this.handleOptionClick}
              @slotchange=${this.handleDefaultSlotChange}
            >
              <slot></slot>
            </div>
          </sl-popup>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlSelect.styles = [component_styles_default, form_control_styles_default, select_styles_default];
SlSelect.dependencies = {
  "sl-icon": SlIcon,
  "sl-popup": SlPopup,
  "sl-tag": SlTag
};
__decorateClass([
  e7(".select")
], SlSelect.prototype, "popup", 2);
__decorateClass([
  e7(".select__combobox")
], SlSelect.prototype, "combobox", 2);
__decorateClass([
  e7(".select__display-input")
], SlSelect.prototype, "displayInput", 2);
__decorateClass([
  e7(".select__value-input")
], SlSelect.prototype, "valueInput", 2);
__decorateClass([
  e7(".select__listbox")
], SlSelect.prototype, "listbox", 2);
__decorateClass([
  r5()
], SlSelect.prototype, "hasFocus", 2);
__decorateClass([
  r5()
], SlSelect.prototype, "displayLabel", 2);
__decorateClass([
  r5()
], SlSelect.prototype, "currentOption", 2);
__decorateClass([
  r5()
], SlSelect.prototype, "selectedOptions", 2);
__decorateClass([
  n6()
], SlSelect.prototype, "name", 2);
__decorateClass([
  n6({
    converter: {
      fromAttribute: (value) => value.split(" "),
      toAttribute: (value) => value.join(" ")
    }
  })
], SlSelect.prototype, "value", 2);
__decorateClass([
  defaultValue()
], SlSelect.prototype, "defaultValue", 2);
__decorateClass([
  n6({ reflect: true })
], SlSelect.prototype, "size", 2);
__decorateClass([
  n6()
], SlSelect.prototype, "placeholder", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlSelect.prototype, "multiple", 2);
__decorateClass([
  n6({ attribute: "max-options-visible", type: Number })
], SlSelect.prototype, "maxOptionsVisible", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlSelect.prototype, "disabled", 2);
__decorateClass([
  n6({ type: Boolean })
], SlSelect.prototype, "clearable", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlSelect.prototype, "open", 2);
__decorateClass([
  n6({ type: Boolean })
], SlSelect.prototype, "hoist", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlSelect.prototype, "filled", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlSelect.prototype, "pill", 2);
__decorateClass([
  n6()
], SlSelect.prototype, "label", 2);
__decorateClass([
  n6({ reflect: true })
], SlSelect.prototype, "placement", 2);
__decorateClass([
  n6({ attribute: "help-text" })
], SlSelect.prototype, "helpText", 2);
__decorateClass([
  n6({ reflect: true })
], SlSelect.prototype, "form", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlSelect.prototype, "required", 2);
__decorateClass([
  n6()
], SlSelect.prototype, "getTag", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlSelect.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("value", { waitUntilFirstUpdate: true })
], SlSelect.prototype, "handleValueChange", 1);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: true })
], SlSelect.prototype, "handleOpenChange", 1);
setDefaultAnimation("select.show", {
  keyframes: [
    { opacity: 0, scale: 0.9 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 100, easing: "ease" }
});
setDefaultAnimation("select.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.9 }
  ],
  options: { duration: 100, easing: "ease" }
});

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.I6RKALKD.js
var select_default = SlSelect;
SlSelect.define("sl-select");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.HTQNKB5E.js
var skeleton_styles_default = i`
  :host {
    --border-radius: var(--sl-border-radius-pill);
    --color: var(--sl-color-neutral-200);
    --sheen-color: var(--sl-color-neutral-300);

    display: block;
    position: relative;
  }

  .skeleton {
    display: flex;
    width: 100%;
    height: 100%;
    min-height: 1rem;
  }

  .skeleton__indicator {
    flex: 1 1 auto;
    background: var(--color);
    border-radius: var(--border-radius);
  }

  .skeleton--sheen .skeleton__indicator {
    background: linear-gradient(270deg, var(--sheen-color), var(--color), var(--color), var(--sheen-color));
    background-size: 400% 100%;
    animation: sheen 8s ease-in-out infinite;
  }

  .skeleton--pulse .skeleton__indicator {
    animation: pulse 2s ease-in-out 0.5s infinite;
  }

  /* Forced colors mode */
  @media (forced-colors: active) {
    :host {
      --color: GrayText;
    }
  }

  @keyframes sheen {
    0% {
      background-position: 200% 0;
    }
    to {
      background-position: -200% 0;
    }
  }

  @keyframes pulse {
    0% {
      opacity: 1;
    }
    50% {
      opacity: 0.4;
    }
    100% {
      opacity: 1;
    }
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.CVE5UBBJ.js
var SlSkeleton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.effect = "none";
  }
  render() {
    return ke`
      <div
        part="base"
        class=${Rt({
      skeleton: true,
      "skeleton--pulse": this.effect === "pulse",
      "skeleton--sheen": this.effect === "sheen"
    })}
      >
        <div part="indicator" class="skeleton__indicator"></div>
      </div>
    `;
  }
};
SlSkeleton.styles = [component_styles_default, skeleton_styles_default];
__decorateClass([
  n6()
], SlSkeleton.prototype, "effect", 2);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.WJ4D25RT.js
SlSkeleton.define("sl-skeleton");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.5D6IT2SR.js
var range_styles_default = i`
  :host {
    --thumb-size: 20px;
    --tooltip-offset: 10px;
    --track-color-active: var(--sl-color-neutral-200);
    --track-color-inactive: var(--sl-color-neutral-200);
    --track-active-offset: 0%;
    --track-height: 6px;

    display: block;
  }

  .range {
    position: relative;
  }

  .range__control {
    --percent: 0%;
    -webkit-appearance: none;
    border-radius: 3px;
    width: 100%;
    height: var(--track-height);
    background: transparent;
    line-height: var(--sl-input-height-medium);
    vertical-align: middle;
    margin: 0;

    background-image: linear-gradient(
      to right,
      var(--track-color-inactive) 0%,
      var(--track-color-inactive) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) 100%
    );
  }

  .range--rtl .range__control {
    background-image: linear-gradient(
      to left,
      var(--track-color-inactive) 0%,
      var(--track-color-inactive) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) 100%
    );
  }

  /* Webkit */
  .range__control::-webkit-slider-runnable-track {
    width: 100%;
    height: var(--track-height);
    border-radius: 3px;
    border: none;
  }

  .range__control::-webkit-slider-thumb {
    border: none;
    width: var(--thumb-size);
    height: var(--thumb-size);
    border-radius: 50%;
    background-color: var(--sl-color-primary-600);
    border: solid var(--sl-input-border-width) var(--sl-color-primary-600);
    -webkit-appearance: none;
    margin-top: calc(var(--thumb-size) / -2 + var(--track-height) / 2);
    cursor: pointer;
  }

  .range__control:enabled::-webkit-slider-thumb:hover {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
  }

  .range__control:enabled:focus-visible::-webkit-slider-thumb {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .range__control:enabled::-webkit-slider-thumb:active {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    cursor: grabbing;
  }

  /* Firefox */
  .range__control::-moz-focus-outer {
    border: 0;
  }

  .range__control::-moz-range-progress {
    background-color: var(--track-color-active);
    border-radius: 3px;
    height: var(--track-height);
  }

  .range__control::-moz-range-track {
    width: 100%;
    height: var(--track-height);
    background-color: var(--track-color-inactive);
    border-radius: 3px;
    border: none;
  }

  .range__control::-moz-range-thumb {
    border: none;
    height: var(--thumb-size);
    width: var(--thumb-size);
    border-radius: 50%;
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
    cursor: pointer;
  }

  .range__control:enabled::-moz-range-thumb:hover {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
  }

  .range__control:enabled:focus-visible::-moz-range-thumb {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .range__control:enabled::-moz-range-thumb:active {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    cursor: grabbing;
  }

  /* States */
  .range__control:focus-visible {
    outline: none;
  }

  .range__control:disabled {
    opacity: 0.5;
  }

  .range__control:disabled::-webkit-slider-thumb {
    cursor: not-allowed;
  }

  .range__control:disabled::-moz-range-thumb {
    cursor: not-allowed;
  }

  /* Tooltip output */
  .range__tooltip {
    position: absolute;
    z-index: var(--sl-z-index-tooltip);
    left: 0;
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    color: var(--sl-tooltip-color);
    opacity: 0;
    padding: var(--sl-tooltip-padding);
    transition: var(--sl-transition-fast) opacity;
    pointer-events: none;
  }

  .range__tooltip:after {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    left: 50%;
    translate: calc(-1 * var(--sl-tooltip-arrow-size));
  }

  .range--tooltip-visible .range__tooltip {
    opacity: 1;
  }

  /* Tooltip on top */
  .range--tooltip-top .range__tooltip {
    top: calc(-1 * var(--thumb-size) - var(--tooltip-offset));
  }

  .range--tooltip-top .range__tooltip:after {
    border-top: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
    top: 100%;
  }

  /* Tooltip on bottom */
  .range--tooltip-bottom .range__tooltip {
    bottom: calc(-1 * var(--thumb-size) - var(--tooltip-offset));
  }

  .range--tooltip-bottom .range__tooltip:after {
    border-bottom: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
    bottom: 100%;
  }

  @media (forced-colors: active) {
    .range__control,
    .range__tooltip {
      border: solid 1px transparent;
    }

    .range__control::-webkit-slider-thumb {
      border: solid 1px transparent;
    }

    .range__control::-moz-range-thumb {
      border: solid 1px transparent;
    }

    .range__tooltip:after {
      display: none;
    }
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.WWKUWCIX.js
var SlRange = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this);
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.hasTooltip = false;
    this.title = "";
    this.name = "";
    this.value = 0;
    this.label = "";
    this.helpText = "";
    this.disabled = false;
    this.min = 0;
    this.max = 100;
    this.step = 1;
    this.tooltip = "top";
    this.tooltipFormatter = (value) => value.toString();
    this.form = "";
    this.defaultValue = 0;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver(() => this.syncRange());
    if (this.value < this.min) {
      this.value = this.min;
    }
    if (this.value > this.max) {
      this.value = this.max;
    }
    this.updateComplete.then(() => {
      this.syncRange();
      this.resizeObserver.observe(this.input);
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.resizeObserver.unobserve(this.input);
  }
  handleChange() {
    this.emit("sl-change");
  }
  handleInput() {
    this.value = parseFloat(this.input.value);
    this.emit("sl-input");
    this.syncRange();
  }
  handleBlur() {
    this.hasFocus = false;
    this.hasTooltip = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.hasTooltip = true;
    this.emit("sl-focus");
  }
  handleThumbDragStart() {
    this.hasTooltip = true;
  }
  handleThumbDragEnd() {
    this.hasTooltip = false;
  }
  syncProgress(percent) {
    this.input.style.setProperty("--percent", `${percent * 100}%`);
  }
  syncTooltip(percent) {
    if (this.output !== null) {
      const inputWidth = this.input.offsetWidth;
      const tooltipWidth = this.output.offsetWidth;
      const thumbSize = getComputedStyle(this.input).getPropertyValue("--thumb-size");
      const isRtl = this.localize.dir() === "rtl";
      const percentAsWidth = inputWidth * percent;
      if (isRtl) {
        const x4 = `${inputWidth - percentAsWidth}px + ${percent} * ${thumbSize}`;
        this.output.style.translate = `calc((${x4} - ${tooltipWidth / 2}px - ${thumbSize} / 2))`;
      } else {
        const x4 = `${percentAsWidth}px - ${percent} * ${thumbSize}`;
        this.output.style.translate = `calc(${x4} - ${tooltipWidth / 2}px + ${thumbSize} / 2)`;
      }
    }
  }
  handleValueChange() {
    this.formControlController.updateValidity();
    this.input.value = this.value.toString();
    this.value = parseFloat(this.input.value);
    this.syncRange();
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  syncRange() {
    const percent = Math.max(0, (this.value - this.min) / (this.max - this.min));
    this.syncProgress(percent);
    if (this.tooltip !== "none") {
      this.syncTooltip(percent);
    }
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  /** Sets focus on the range. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the range. */
  blur() {
    this.input.blur();
  }
  /** Increments the value of the range by the value of the step attribute. */
  stepUp() {
    this.input.stepUp();
    if (this.value !== Number(this.input.value)) {
      this.value = Number(this.input.value);
    }
  }
  /** Decrements the value of the range by the value of the step attribute. */
  stepDown() {
    this.input.stepDown();
    if (this.value !== Number(this.input.value)) {
      this.value = Number(this.input.value);
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return ke`
      <div
        part="form-control"
        class=${Rt({
      "form-control": true,
      "form-control--medium": true,
      // range only has one size
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${Rt({
      range: true,
      "range--disabled": this.disabled,
      "range--focused": this.hasFocus,
      "range--rtl": this.localize.dir() === "rtl",
      "range--tooltip-visible": this.hasTooltip,
      "range--tooltip-top": this.tooltip === "top",
      "range--tooltip-bottom": this.tooltip === "bottom"
    })}
            @mousedown=${this.handleThumbDragStart}
            @mouseup=${this.handleThumbDragEnd}
            @touchstart=${this.handleThumbDragStart}
            @touchend=${this.handleThumbDragEnd}
          >
            <input
              part="input"
              id="input"
              class="range__control"
              title=${this.title}
              type="range"
              name=${to(this.name)}
              ?disabled=${this.disabled}
              min=${to(this.min)}
              max=${to(this.max)}
              step=${to(this.step)}
              .value=${Ft(this.value.toString())}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @focus=${this.handleFocus}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @blur=${this.handleBlur}
            />
            ${this.tooltip !== "none" && !this.disabled ? ke`
                  <output part="tooltip" class="range__tooltip">
                    ${typeof this.tooltipFormatter === "function" ? this.tooltipFormatter(this.value) : this.value}
                  </output>
                ` : ""}
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlRange.styles = [component_styles_default, form_control_styles_default, range_styles_default];
__decorateClass([
  e7(".range__control")
], SlRange.prototype, "input", 2);
__decorateClass([
  e7(".range__tooltip")
], SlRange.prototype, "output", 2);
__decorateClass([
  r5()
], SlRange.prototype, "hasFocus", 2);
__decorateClass([
  r5()
], SlRange.prototype, "hasTooltip", 2);
__decorateClass([
  n6()
], SlRange.prototype, "title", 2);
__decorateClass([
  n6()
], SlRange.prototype, "name", 2);
__decorateClass([
  n6({ type: Number })
], SlRange.prototype, "value", 2);
__decorateClass([
  n6()
], SlRange.prototype, "label", 2);
__decorateClass([
  n6({ attribute: "help-text" })
], SlRange.prototype, "helpText", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlRange.prototype, "disabled", 2);
__decorateClass([
  n6({ type: Number })
], SlRange.prototype, "min", 2);
__decorateClass([
  n6({ type: Number })
], SlRange.prototype, "max", 2);
__decorateClass([
  n6({ type: Number })
], SlRange.prototype, "step", 2);
__decorateClass([
  n6()
], SlRange.prototype, "tooltip", 2);
__decorateClass([
  n6({ attribute: false })
], SlRange.prototype, "tooltipFormatter", 2);
__decorateClass([
  n6({ reflect: true })
], SlRange.prototype, "form", 2);
__decorateClass([
  defaultValue()
], SlRange.prototype, "defaultValue", 2);
__decorateClass([
  t5({ passive: true })
], SlRange.prototype, "handleThumbDragStart", 1);
__decorateClass([
  watch("value", { waitUntilFirstUpdate: true })
], SlRange.prototype, "handleValueChange", 1);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlRange.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("hasTooltip", { waitUntilFirstUpdate: true })
], SlRange.prototype, "syncRange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.KTUIDAYY.js
var range_default = SlRange;
SlRange.define("sl-range");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.X2WW2TWJ.js
var rating_styles_default = i`
  :host {
    --symbol-color: var(--sl-color-neutral-300);
    --symbol-color-active: var(--sl-color-amber-500);
    --symbol-size: 1.2rem;
    --symbol-spacing: var(--sl-spacing-3x-small);

    display: inline-flex;
  }

  .rating {
    position: relative;
    display: inline-flex;
    border-radius: var(--sl-border-radius-medium);
    vertical-align: middle;
  }

  .rating:focus {
    outline: none;
  }

  .rating:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .rating__symbols {
    display: inline-flex;
    position: relative;
    font-size: var(--symbol-size);
    line-height: 0;
    color: var(--symbol-color);
    white-space: nowrap;
    cursor: pointer;
  }

  .rating__symbols > * {
    padding: var(--symbol-spacing);
  }

  .rating__symbol--active,
  .rating__partial--filled {
    color: var(--symbol-color-active);
  }

  .rating__partial-symbol-container {
    position: relative;
  }

  .rating__partial--filled {
    position: absolute;
    top: var(--symbol-spacing);
    left: var(--symbol-spacing);
  }

  .rating__symbol {
    transition: var(--sl-transition-fast) scale;
    pointer-events: none;
  }

  .rating__symbol--hover {
    scale: 1.2;
  }

  .rating--disabled .rating__symbols,
  .rating--readonly .rating__symbols {
    cursor: default;
  }

  .rating--disabled .rating__symbol--hover,
  .rating--readonly .rating__symbol--hover {
    scale: none;
  }

  .rating--disabled {
    opacity: 0.5;
  }

  .rating--disabled .rating__symbols {
    cursor: not-allowed;
  }

  /* Forced colors mode */
  @media (forced-colors: active) {
    .rating__symbol--active {
      color: SelectedItem;
    }
  }
`;

// src/node_modules/lit-html/directives/style-map.js
var ee = "important";
var ie = " !" + ee;
var se = e9(class extends i4 {
  constructor(e10) {
    if (super(e10), e10.type !== t6.ATTRIBUTE || "style" !== e10.name || e10.strings?.length > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(t8) {
    return Object.keys(t8).reduce((e10, r9) => {
      const s6 = t8[r9];
      return null == s6 ? e10 : e10 + `${r9 = r9.includes("-") ? r9 : r9.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s6};`;
    }, "");
  }
  update(t8, [e10]) {
    const { style: r9 } = t8.element;
    if (void 0 === this.ft) return this.ft = new Set(Object.keys(e10)), this.render(e10);
    for (const t9 of this.ft) null == e10[t9] && (this.ft.delete(t9), t9.includes("-") ? r9.removeProperty(t9) : r9[t9] = null);
    for (const t9 in e10) {
      const s6 = e10[t9];
      if (null != s6) {
        this.ft.add(t9);
        const e11 = "string" == typeof s6 && s6.endsWith(ie);
        t9.includes("-") || e11 ? r9.setProperty(t9, e11 ? s6.slice(0, -11) : s6, e11 ? ee : "") : r9[t9] = s6;
      }
    }
    return R;
  }
});

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GPQTYS3D.js
var SlRating = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.hoverValue = 0;
    this.isHovering = false;
    this.label = "";
    this.value = 0;
    this.max = 5;
    this.precision = 1;
    this.readonly = false;
    this.disabled = false;
    this.getSymbol = () => '<sl-icon name="star-fill" library="system"></sl-icon>';
  }
  getValueFromMousePosition(event) {
    return this.getValueFromXCoordinate(event.clientX);
  }
  getValueFromTouchPosition(event) {
    return this.getValueFromXCoordinate(event.touches[0].clientX);
  }
  getValueFromXCoordinate(coordinate) {
    const isRtl = this.localize.dir() === "rtl";
    const { left, right, width } = this.rating.getBoundingClientRect();
    const value = isRtl ? this.roundToPrecision((right - coordinate) / width * this.max, this.precision) : this.roundToPrecision((coordinate - left) / width * this.max, this.precision);
    return clamp2(value, 0, this.max);
  }
  handleClick(event) {
    if (this.disabled) {
      return;
    }
    this.setValue(this.getValueFromMousePosition(event));
    this.emit("sl-change");
  }
  setValue(newValue) {
    if (this.disabled || this.readonly) {
      return;
    }
    this.value = newValue === this.value ? 0 : newValue;
    this.isHovering = false;
  }
  handleKeyDown(event) {
    const isLtr = this.localize.dir() === "ltr";
    const isRtl = this.localize.dir() === "rtl";
    const oldValue = this.value;
    if (this.disabled || this.readonly) {
      return;
    }
    if (event.key === "ArrowDown" || isLtr && event.key === "ArrowLeft" || isRtl && event.key === "ArrowRight") {
      const decrement = event.shiftKey ? 1 : this.precision;
      this.value = Math.max(0, this.value - decrement);
      event.preventDefault();
    }
    if (event.key === "ArrowUp" || isLtr && event.key === "ArrowRight" || isRtl && event.key === "ArrowLeft") {
      const increment = event.shiftKey ? 1 : this.precision;
      this.value = Math.min(this.max, this.value + increment);
      event.preventDefault();
    }
    if (event.key === "Home") {
      this.value = 0;
      event.preventDefault();
    }
    if (event.key === "End") {
      this.value = this.max;
      event.preventDefault();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
    }
  }
  handleMouseEnter(event) {
    this.isHovering = true;
    this.hoverValue = this.getValueFromMousePosition(event);
  }
  handleMouseMove(event) {
    this.hoverValue = this.getValueFromMousePosition(event);
  }
  handleMouseLeave() {
    this.isHovering = false;
  }
  handleTouchStart(event) {
    this.isHovering = true;
    this.hoverValue = this.getValueFromTouchPosition(event);
    event.preventDefault();
  }
  handleTouchMove(event) {
    this.hoverValue = this.getValueFromTouchPosition(event);
  }
  handleTouchEnd(event) {
    this.isHovering = false;
    this.setValue(this.hoverValue);
    this.emit("sl-change");
    event.preventDefault();
  }
  roundToPrecision(numberToRound, precision = 0.5) {
    const multiplier = 1 / precision;
    return Math.ceil(numberToRound * multiplier) / multiplier;
  }
  handleHoverValueChange() {
    this.emit("sl-hover", {
      detail: {
        phase: "move",
        value: this.hoverValue
      }
    });
  }
  handleIsHoveringChange() {
    this.emit("sl-hover", {
      detail: {
        phase: this.isHovering ? "start" : "end",
        value: this.hoverValue
      }
    });
  }
  /** Sets focus on the rating. */
  focus(options) {
    this.rating.focus(options);
  }
  /** Removes focus from the rating. */
  blur() {
    this.rating.blur();
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    const counter = Array.from(Array(this.max).keys());
    let displayValue = 0;
    if (this.disabled || this.readonly) {
      displayValue = this.value;
    } else {
      displayValue = this.isHovering ? this.hoverValue : this.value;
    }
    return ke`
      <div
        part="base"
        class=${Rt({
      rating: true,
      "rating--readonly": this.readonly,
      "rating--disabled": this.disabled,
      "rating--rtl": isRtl
    })}
        role="slider"
        aria-label=${this.label}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-readonly=${this.readonly ? "true" : "false"}
        aria-valuenow=${this.value}
        aria-valuemin=${0}
        aria-valuemax=${this.max}
        tabindex=${this.disabled ? "-1" : "0"}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mouseenter=${this.handleMouseEnter}
        @touchstart=${this.handleTouchStart}
        @mouseleave=${this.handleMouseLeave}
        @touchend=${this.handleTouchEnd}
        @mousemove=${this.handleMouseMove}
        @touchmove=${this.handleTouchMove}
      >
        <span class="rating__symbols">
          ${counter.map((index) => {
      if (displayValue > index && displayValue < index + 1) {
        return ke`
                <span
                  class=${Rt({
          rating__symbol: true,
          "rating__partial-symbol-container": true,
          "rating__symbol--hover": this.isHovering && Math.ceil(displayValue) === index + 1
        })}
                  role="presentation"
                >
                  <div
                    style=${se({
          clipPath: isRtl ? `inset(0 ${(displayValue - index) * 100}% 0 0)` : `inset(0 0 0 ${(displayValue - index) * 100}%)`
        })}
                  >
                    ${ae(this.getSymbol(index + 1))}
                  </div>
                  <div
                    class="rating__partial--filled"
                    style=${se({
          clipPath: isRtl ? `inset(0 0 0 ${100 - (displayValue - index) * 100}%)` : `inset(0 ${100 - (displayValue - index) * 100}% 0 0)`
        })}
                  >
                    ${ae(this.getSymbol(index + 1))}
                  </div>
                </span>
              `;
      }
      return ke`
              <span
                class=${Rt({
        rating__symbol: true,
        "rating__symbol--hover": this.isHovering && Math.ceil(displayValue) === index + 1,
        "rating__symbol--active": displayValue >= index + 1
      })}
                role="presentation"
              >
                ${ae(this.getSymbol(index + 1))}
              </span>
            `;
    })}
        </span>
      </div>
    `;
  }
};
SlRating.styles = [component_styles_default, rating_styles_default];
SlRating.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e7(".rating")
], SlRating.prototype, "rating", 2);
__decorateClass([
  r5()
], SlRating.prototype, "hoverValue", 2);
__decorateClass([
  r5()
], SlRating.prototype, "isHovering", 2);
__decorateClass([
  n6()
], SlRating.prototype, "label", 2);
__decorateClass([
  n6({ type: Number })
], SlRating.prototype, "value", 2);
__decorateClass([
  n6({ type: Number })
], SlRating.prototype, "max", 2);
__decorateClass([
  n6({ type: Number })
], SlRating.prototype, "precision", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlRating.prototype, "readonly", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlRating.prototype, "disabled", 2);
__decorateClass([
  n6()
], SlRating.prototype, "getSymbol", 2);
__decorateClass([
  t5({ passive: true })
], SlRating.prototype, "handleTouchMove", 1);
__decorateClass([
  watch("hoverValue")
], SlRating.prototype, "handleHoverValueChange", 1);
__decorateClass([
  watch("isHovering")
], SlRating.prototype, "handleIsHoveringChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.5AZIVGJ7.js
SlRating.define("sl-rating");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.WQW4TNIG.js
var availableUnits = [
  { max: 276e4, value: 6e4, unit: "minute" },
  // max 46 minutes
  { max: 72e6, value: 36e5, unit: "hour" },
  // max 20 hours
  { max: 5184e5, value: 864e5, unit: "day" },
  // max 6 days
  { max: 24192e5, value: 6048e5, unit: "week" },
  // max 28 days
  { max: 28512e6, value: 2592e6, unit: "month" },
  // max 11 months
  { max: Infinity, value: 31536e6, unit: "year" }
];
var SlRelativeTime = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.isoTime = "";
    this.relativeTime = "";
    this.titleTime = "";
    this.date = /* @__PURE__ */ new Date();
    this.format = "long";
    this.numeric = "auto";
    this.sync = false;
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    clearTimeout(this.updateTimeout);
  }
  render() {
    const now = /* @__PURE__ */ new Date();
    const then = new Date(this.date);
    if (isNaN(then.getMilliseconds())) {
      this.relativeTime = "";
      this.isoTime = "";
      return "";
    }
    const diff = then.getTime() - now.getTime();
    const { unit, value } = availableUnits.find((singleUnit) => Math.abs(diff) < singleUnit.max);
    this.isoTime = then.toISOString();
    this.titleTime = this.localize.date(then, {
      month: "long",
      year: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      timeZoneName: "short"
    });
    this.relativeTime = this.localize.relativeTime(Math.round(diff / value), unit, {
      numeric: this.numeric,
      style: this.format
    });
    clearTimeout(this.updateTimeout);
    if (this.sync) {
      let nextInterval;
      if (unit === "minute") {
        nextInterval = getTimeUntilNextUnit("second");
      } else if (unit === "hour") {
        nextInterval = getTimeUntilNextUnit("minute");
      } else if (unit === "day") {
        nextInterval = getTimeUntilNextUnit("hour");
      } else {
        nextInterval = getTimeUntilNextUnit("day");
      }
      this.updateTimeout = window.setTimeout(() => this.requestUpdate(), nextInterval);
    }
    return ke` <time datetime=${this.isoTime} title=${this.titleTime}>${this.relativeTime}</time> `;
  }
};
__decorateClass([
  r5()
], SlRelativeTime.prototype, "isoTime", 2);
__decorateClass([
  r5()
], SlRelativeTime.prototype, "relativeTime", 2);
__decorateClass([
  r5()
], SlRelativeTime.prototype, "titleTime", 2);
__decorateClass([
  n6()
], SlRelativeTime.prototype, "date", 2);
__decorateClass([
  n6()
], SlRelativeTime.prototype, "format", 2);
__decorateClass([
  n6()
], SlRelativeTime.prototype, "numeric", 2);
__decorateClass([
  n6({ type: Boolean })
], SlRelativeTime.prototype, "sync", 2);
function getTimeUntilNextUnit(unit) {
  const units = { second: 1e3, minute: 6e4, hour: 36e5, day: 864e5 };
  const value = units[unit];
  return value - Date.now() % value;
}

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.R5JVUKAF.js
SlRelativeTime.define("sl-relative-time");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.HLDU3ZPH.js
var button_styles_default = i`
  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition:
      var(--sl-transition-x-fast) background-color,
      var(--sl-transition-x-fast) color,
      var(--sl-transition-x-fast) border,
      var(--sl-transition-x-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up from children */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label {
    display: inline-block;
  }

  .button__label::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled),
  .button--outline.button--default.button--checked:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled),
  .button--outline.button--primary.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled),
  .button--outline.button--success.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled),
  .button--outline.button--neutral.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled),
  .button--outline.button--warning.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled),
  .button--outline.button--danger.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  @media (forced-colors: active) {
    .button.button--outline.button--checked:not(.button--disabled) {
      outline: solid 2px transparent;
    }
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:focus-visible:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    height: auto;
    min-height: var(--sl-input-height-small);
    font-size: var(--sl-button-font-size-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    height: auto;
    min-height: var(--sl-input-height-medium);
    font-size: var(--sl-button-font-size-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    height: auto;
    min-height: var(--sl-input-height-large);
    font-size: var(--sl-button-font-size-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    height: auto;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    translate: 50% -50%;
    pointer-events: none;
  }

  .button--rtl ::slotted(sl-badge) {
    right: auto;
    left: 0;
    translate: -50% -50%;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host([data-sl-button-group__button--first]:not([data-sl-button-group__button--last])) .button {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  :host([data-sl-button-group__button--inner]) .button {
    border-radius: 0;
  }

  :host([data-sl-button-group__button--last]:not([data-sl-button-group__button--first])) .button {
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  /* All except the first */
  :host([data-sl-button-group__button]:not([data-sl-button-group__button--first])) {
    margin-inline-start: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(
      [data-sl-button-group__button]:not(
          [data-sl-button-group__button--first],
          [data-sl-button-group__button--radio],
          [variant='default']
        ):not(:hover)
    )
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    inset-inline-start: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump hovered, focused, and checked buttons up so their focus ring isn't clipped */
  :host([data-sl-button-group__button--hover]) {
    z-index: 1;
  }

  /* Focus and checked are always on top */
  :host([data-sl-button-group__button--focus]),
  :host([data-sl-button-group__button[checked]]) {
    z-index: 2;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.F7FBSKCL.js
var radio_button_styles_default = i`
  ${button_styles_default}

  .button__prefix,
  .button__suffix,
  .button__label {
    display: inline-flex;
    position: relative;
    align-items: center;
  }

  /* We use a hidden input so constraint validation errors work, since they don't appear to show when used with buttons.
    We can't actually hide it, though, otherwise the messages will be suppressed by the browser. */
  .hidden-input {
    all: unset;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    outline: dotted 1px red;
    opacity: 0;
    z-index: -1;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.X2RSAQ6S.js
var SlRadioButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "[default]", "prefix", "suffix");
    this.hasFocus = false;
    this.checked = false;
    this.disabled = false;
    this.size = "medium";
    this.pill = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "presentation");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleClick(e10) {
    if (this.disabled) {
      e10.preventDefault();
      e10.stopPropagation();
      return;
    }
    this.checked = true;
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  /** Sets focus on the radio button. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the radio button. */
  blur() {
    this.input.blur();
  }
  render() {
    return ke3`
      <div part="base" role="presentation">
        <button
          part="${`button${this.checked ? " button--checked" : ""}`}"
          role="radio"
          aria-checked="${this.checked}"
          class=${Rt({
      button: true,
      "button--default": true,
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--checked": this.checked,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--outline": true,
      "button--pill": this.pill,
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
          aria-disabled=${this.disabled}
          type="button"
          value=${to(this.value)}
          tabindex="${this.checked ? "0" : "-1"}"
          @blur=${this.handleBlur}
          @focus=${this.handleFocus}
          @click=${this.handleClick}
        >
          <slot name="prefix" part="prefix" class="button__prefix"></slot>
          <slot part="label" class="button__label"></slot>
          <slot name="suffix" part="suffix" class="button__suffix"></slot>
        </button>
      </div>
    `;
  }
};
SlRadioButton.styles = [component_styles_default, radio_button_styles_default];
__decorateClass([
  e7(".button")
], SlRadioButton.prototype, "input", 2);
__decorateClass([
  e7(".hidden-input")
], SlRadioButton.prototype, "hiddenInput", 2);
__decorateClass([
  r5()
], SlRadioButton.prototype, "hasFocus", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlRadioButton.prototype, "checked", 2);
__decorateClass([
  n6()
], SlRadioButton.prototype, "value", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlRadioButton.prototype, "disabled", 2);
__decorateClass([
  n6({ reflect: true })
], SlRadioButton.prototype, "size", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlRadioButton.prototype, "pill", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlRadioButton.prototype, "handleDisabledChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ONTVSX2S.js
SlRadioButton.define("sl-radio-button");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.B63YXDJO.js
var radio_group_styles_default = i`
  :host {
    display: block;
  }

  .form-control {
    position: relative;
    border: none;
    padding: 0;
    margin: 0;
  }

  .form-control__label {
    padding: 0;
  }

  .radio-group--required .radio-group__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
  }

  .visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2OUC42YY.js
var button_group_styles_default = i`
  :host {
    display: inline-block;
  }

  .button-group {
    display: flex;
    flex-wrap: nowrap;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ZHDMOJHQ.js
var SlButtonGroup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.disableRole = false;
    this.label = "";
  }
  handleFocus(event) {
    const button = findButton(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--focus", true);
  }
  handleBlur(event) {
    const button = findButton(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--focus", false);
  }
  handleMouseOver(event) {
    const button = findButton(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--hover", true);
  }
  handleMouseOut(event) {
    const button = findButton(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--hover", false);
  }
  handleSlotChange() {
    const slottedElements = [...this.defaultSlot.assignedElements({ flatten: true })];
    slottedElements.forEach((el) => {
      const index = slottedElements.indexOf(el);
      const button = findButton(el);
      if (button) {
        button.toggleAttribute("data-sl-button-group__button", true);
        button.toggleAttribute("data-sl-button-group__button--first", index === 0);
        button.toggleAttribute("data-sl-button-group__button--inner", index > 0 && index < slottedElements.length - 1);
        button.toggleAttribute("data-sl-button-group__button--last", index === slottedElements.length - 1);
        button.toggleAttribute(
          "data-sl-button-group__button--radio",
          button.tagName.toLowerCase() === "sl-radio-button"
        );
      }
    });
  }
  render() {
    return ke`
      <div
        part="base"
        class="button-group"
        role="${this.disableRole ? "presentation" : "group"}"
        aria-label=${this.label}
        @focusout=${this.handleBlur}
        @focusin=${this.handleFocus}
        @mouseover=${this.handleMouseOver}
        @mouseout=${this.handleMouseOut}
      >
        <slot @slotchange=${this.handleSlotChange}></slot>
      </div>
    `;
  }
};
SlButtonGroup.styles = [component_styles_default, button_group_styles_default];
__decorateClass([
  e7("slot")
], SlButtonGroup.prototype, "defaultSlot", 2);
__decorateClass([
  r5()
], SlButtonGroup.prototype, "disableRole", 2);
__decorateClass([
  n6()
], SlButtonGroup.prototype, "label", 2);
function findButton(el) {
  var _a24;
  const selector = "sl-button, sl-radio-button";
  return (_a24 = el.closest(selector)) != null ? _a24 : el.querySelector(selector);
}

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.PP6TOUKR.js
var SlRadioGroup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this);
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.customValidityMessage = "";
    this.hasButtonGroup = false;
    this.errorMessage = "";
    this.defaultValue = "";
    this.label = "";
    this.helpText = "";
    this.name = "option";
    this.value = "";
    this.size = "medium";
    this.form = "";
    this.required = false;
  }
  /** Gets the validity state object */
  get validity() {
    const isRequiredAndEmpty = this.required && !this.value;
    const hasCustomValidityMessage = this.customValidityMessage !== "";
    if (hasCustomValidityMessage) {
      return customErrorValidityState;
    } else if (isRequiredAndEmpty) {
      return valueMissingValidityState;
    }
    return validValidityState;
  }
  /** Gets the validation message */
  get validationMessage() {
    const isRequiredAndEmpty = this.required && !this.value;
    const hasCustomValidityMessage = this.customValidityMessage !== "";
    if (hasCustomValidityMessage) {
      return this.customValidityMessage;
    } else if (isRequiredAndEmpty) {
      return this.validationInput.validationMessage;
    }
    return "";
  }
  connectedCallback() {
    super.connectedCallback();
    this.defaultValue = this.value;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  getAllRadios() {
    return [...this.querySelectorAll("sl-radio, sl-radio-button")];
  }
  handleRadioClick(event) {
    const target = event.target.closest("sl-radio, sl-radio-button");
    const radios = this.getAllRadios();
    const oldValue = this.value;
    if (target.disabled) {
      return;
    }
    this.value = target.value;
    radios.forEach((radio) => radio.checked = radio === target);
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleKeyDown(event) {
    var _a24;
    if (!["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(event.key)) {
      return;
    }
    const radios = this.getAllRadios().filter((radio) => !radio.disabled);
    const checkedRadio = (_a24 = radios.find((radio) => radio.checked)) != null ? _a24 : radios[0];
    const incr = event.key === " " ? 0 : ["ArrowUp", "ArrowLeft"].includes(event.key) ? -1 : 1;
    const oldValue = this.value;
    let index = radios.indexOf(checkedRadio) + incr;
    if (index < 0) {
      index = radios.length - 1;
    }
    if (index > radios.length - 1) {
      index = 0;
    }
    this.getAllRadios().forEach((radio) => {
      radio.checked = false;
      if (!this.hasButtonGroup) {
        radio.tabIndex = -1;
      }
    });
    this.value = radios[index].value;
    radios[index].checked = true;
    if (!this.hasButtonGroup) {
      radios[index].tabIndex = 0;
      radios[index].focus();
    } else {
      radios[index].shadowRoot.querySelector("button").focus();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
    event.preventDefault();
  }
  handleLabelClick() {
    const radios = this.getAllRadios();
    const checked = radios.find((radio) => radio.checked);
    const radioToFocus = checked || radios[0];
    if (radioToFocus) {
      radioToFocus.focus();
    }
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  async syncRadioElements() {
    var _a24, _b;
    const radios = this.getAllRadios();
    await Promise.all(
      // Sync the checked state and size
      radios.map(async (radio) => {
        await radio.updateComplete;
        radio.checked = radio.value === this.value;
        radio.size = this.size;
      })
    );
    this.hasButtonGroup = radios.some((radio) => radio.tagName.toLowerCase() === "sl-radio-button");
    if (radios.length > 0 && !radios.some((radio) => radio.checked)) {
      if (this.hasButtonGroup) {
        const buttonRadio = (_a24 = radios[0].shadowRoot) == null ? void 0 : _a24.querySelector("button");
        if (buttonRadio) {
          buttonRadio.tabIndex = 0;
        }
      } else {
        radios[0].tabIndex = 0;
      }
    }
    if (this.hasButtonGroup) {
      const buttonGroup = (_b = this.shadowRoot) == null ? void 0 : _b.querySelector("sl-button-group");
      if (buttonGroup) {
        buttonGroup.disableRole = true;
      }
    }
  }
  syncRadios() {
    if (customElements.get("sl-radio") && customElements.get("sl-radio-button")) {
      this.syncRadioElements();
      return;
    }
    if (customElements.get("sl-radio")) {
      this.syncRadioElements();
    } else {
      customElements.whenDefined("sl-radio").then(() => this.syncRadios());
    }
    if (customElements.get("sl-radio-button")) {
      this.syncRadioElements();
    } else {
      customElements.whenDefined("sl-radio-button").then(() => this.syncRadios());
    }
  }
  updateCheckedRadio() {
    const radios = this.getAllRadios();
    radios.forEach((radio) => radio.checked = radio.value === this.value);
    this.formControlController.setValidity(this.validity.valid);
  }
  handleSizeChange() {
    this.syncRadios();
  }
  handleValueChange() {
    if (this.hasUpdated) {
      this.updateCheckedRadio();
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    const isRequiredAndEmpty = this.required && !this.value;
    const hasCustomValidityMessage = this.customValidityMessage !== "";
    if (isRequiredAndEmpty || hasCustomValidityMessage) {
      this.formControlController.emitInvalidEvent();
      return false;
    }
    return true;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    const isValid = this.validity.valid;
    this.errorMessage = this.customValidityMessage || isValid ? "" : this.validationInput.validationMessage;
    this.formControlController.setValidity(isValid);
    this.validationInput.hidden = true;
    clearTimeout(this.validationTimeout);
    if (!isValid) {
      this.validationInput.hidden = false;
      this.validationInput.reportValidity();
      this.validationTimeout = setTimeout(() => this.validationInput.hidden = true, 1e4);
    }
    return isValid;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message = "") {
    this.customValidityMessage = message;
    this.errorMessage = message;
    this.validationInput.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const defaultSlot = ke`
      <slot @slotchange=${this.syncRadios} @click=${this.handleRadioClick} @keydown=${this.handleKeyDown}></slot>
    `;
    return ke`
      <fieldset
        part="form-control"
        class=${Rt({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--radio-group": true,
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
        role="radiogroup"
        aria-labelledby="label"
        aria-describedby="help-text"
        aria-errormessage="error-message"
      >
        <label
          part="form-control-label"
          id="label"
          class="form-control__label"
          aria-hidden=${hasLabel ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div class="visually-hidden">
            <div id="error-message" aria-live="assertive">${this.errorMessage}</div>
            <label class="radio-group__validation">
              <input
                type="text"
                class="radio-group__validation-input"
                ?required=${this.required}
                tabindex="-1"
                hidden
                @invalid=${this.handleInvalid}
              />
            </label>
          </div>

          ${this.hasButtonGroup ? ke`
                <sl-button-group part="button-group" exportparts="base:button-group__base" role="presentation">
                  ${defaultSlot}
                </sl-button-group>
              ` : defaultSlot}
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </fieldset>
    `;
  }
};
SlRadioGroup.styles = [component_styles_default, form_control_styles_default, radio_group_styles_default];
SlRadioGroup.dependencies = { "sl-button-group": SlButtonGroup };
__decorateClass([
  e7("slot:not([name])")
], SlRadioGroup.prototype, "defaultSlot", 2);
__decorateClass([
  e7(".radio-group__validation-input")
], SlRadioGroup.prototype, "validationInput", 2);
__decorateClass([
  r5()
], SlRadioGroup.prototype, "hasButtonGroup", 2);
__decorateClass([
  r5()
], SlRadioGroup.prototype, "errorMessage", 2);
__decorateClass([
  r5()
], SlRadioGroup.prototype, "defaultValue", 2);
__decorateClass([
  n6()
], SlRadioGroup.prototype, "label", 2);
__decorateClass([
  n6({ attribute: "help-text" })
], SlRadioGroup.prototype, "helpText", 2);
__decorateClass([
  n6()
], SlRadioGroup.prototype, "name", 2);
__decorateClass([
  n6({ reflect: true })
], SlRadioGroup.prototype, "value", 2);
__decorateClass([
  n6({ reflect: true })
], SlRadioGroup.prototype, "size", 2);
__decorateClass([
  n6({ reflect: true })
], SlRadioGroup.prototype, "form", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlRadioGroup.prototype, "required", 2);
__decorateClass([
  watch("size", { waitUntilFirstUpdate: true })
], SlRadioGroup.prototype, "handleSizeChange", 1);
__decorateClass([
  watch("value")
], SlRadioGroup.prototype, "handleValueChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.F7LKX3GX.js
SlRadioGroup.define("sl-radio-group");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.XOSELTMG.js
var progress_ring_styles_default = i`
  :host {
    --size: 128px;
    --track-width: 4px;
    --track-color: var(--sl-color-neutral-200);
    --indicator-width: var(--track-width);
    --indicator-color: var(--sl-color-primary-600);
    --indicator-transition-duration: 0.35s;

    display: inline-flex;
  }

  .progress-ring {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  .progress-ring__image {
    width: var(--size);
    height: var(--size);
    rotate: -90deg;
    transform-origin: 50% 50%;
  }

  .progress-ring__track,
  .progress-ring__indicator {
    --radius: calc(var(--size) / 2 - max(var(--track-width), var(--indicator-width)) * 0.5);
    --circumference: calc(var(--radius) * 2 * 3.141592654);

    fill: none;
    r: var(--radius);
    cx: calc(var(--size) / 2);
    cy: calc(var(--size) / 2);
  }

  .progress-ring__track {
    stroke: var(--track-color);
    stroke-width: var(--track-width);
  }

  .progress-ring__indicator {
    stroke: var(--indicator-color);
    stroke-width: var(--indicator-width);
    stroke-linecap: round;
    transition-property: stroke-dashoffset;
    transition-duration: var(--indicator-transition-duration);
    stroke-dasharray: var(--circumference) var(--circumference);
    stroke-dashoffset: calc(var(--circumference) - var(--percentage) * var(--circumference));
  }

  .progress-ring__label {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    text-align: center;
    user-select: none;
    -webkit-user-select: none;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.C5KOCY2K.js
var SlProgressRing = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.value = 0;
    this.label = "";
  }
  updated(changedProps) {
    super.updated(changedProps);
    if (changedProps.has("value")) {
      const radius = parseFloat(getComputedStyle(this.indicator).getPropertyValue("r"));
      const circumference = 2 * Math.PI * radius;
      const offset3 = circumference - this.value / 100 * circumference;
      this.indicatorOffset = `${offset3}px`;
    }
  }
  render() {
    return ke`
      <div
        part="base"
        class="progress-ring"
        role="progressbar"
        aria-label=${this.label.length > 0 ? this.label : this.localize.term("progress")}
        aria-describedby="label"
        aria-valuemin="0"
        aria-valuemax="100"
        aria-valuenow="${this.value}"
        style="--percentage: ${this.value / 100}"
      >
        <svg class="progress-ring__image">
          <circle class="progress-ring__track"></circle>
          <circle class="progress-ring__indicator" style="stroke-dashoffset: ${this.indicatorOffset}"></circle>
        </svg>

        <slot id="label" part="label" class="progress-ring__label"></slot>
      </div>
    `;
  }
};
SlProgressRing.styles = [component_styles_default, progress_ring_styles_default];
__decorateClass([
  e7(".progress-ring__indicator")
], SlProgressRing.prototype, "indicator", 2);
__decorateClass([
  r5()
], SlProgressRing.prototype, "indicatorOffset", 2);
__decorateClass([
  n6({ type: Number, reflect: true })
], SlProgressRing.prototype, "value", 2);
__decorateClass([
  n6()
], SlProgressRing.prototype, "label", 2);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.L75YBONN.js
SlProgressRing.define("sl-progress-ring");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2IHMH66B.js
var qr_code_styles_default = i`
  :host {
    display: inline-block;
  }
`;

// src/node_modules/qr-creator/dist/qr-creator.es6.min.js
var G3 = null;
var H = class {
};
H.render = function(w3, B3) {
  G3(w3, B3);
};
self.QrCreator = H;
(function(w3) {
  function B3(t8, c6, a3, e10) {
    var b3 = {}, h5 = w3(a3, c6);
    h5.u(t8);
    h5.J();
    e10 = e10 || 0;
    var r9 = h5.h(), d3 = h5.h() + 2 * e10;
    b3.text = t8;
    b3.level = c6;
    b3.version = a3;
    b3.O = d3;
    b3.a = function(b4, a4) {
      b4 -= e10;
      a4 -= e10;
      return 0 > b4 || b4 >= r9 || 0 > a4 || a4 >= r9 ? false : h5.a(b4, a4);
    };
    return b3;
  }
  function C(t8, c6, a3, e10, b3, h5, r9, d3, g3, x4) {
    function u3(b4, a4, f5, c7, d4, r10, g4) {
      b4 ? (t8.lineTo(a4 + r10, f5 + g4), t8.arcTo(a4, f5, c7, d4, h5)) : t8.lineTo(a4, f5);
    }
    r9 ? t8.moveTo(c6 + h5, a3) : t8.moveTo(c6, a3);
    u3(d3, e10, a3, e10, b3, -h5, 0);
    u3(g3, e10, b3, c6, b3, 0, -h5);
    u3(x4, c6, b3, c6, a3, h5, 0);
    u3(r9, c6, a3, e10, a3, 0, h5);
  }
  function z3(t8, c6, a3, e10, b3, h5, r9, d3, g3, x4) {
    function u3(b4, a4, c7, d4) {
      t8.moveTo(b4 + c7, a4);
      t8.lineTo(
        b4,
        a4
      );
      t8.lineTo(b4, a4 + d4);
      t8.arcTo(b4, a4, b4 + c7, a4, h5);
    }
    r9 && u3(c6, a3, h5, h5);
    d3 && u3(e10, a3, -h5, h5);
    g3 && u3(e10, b3, -h5, -h5);
    x4 && u3(c6, b3, h5, -h5);
  }
  function A(t8, c6) {
    var a3 = c6.fill;
    if ("string" === typeof a3) t8.fillStyle = a3;
    else {
      var e10 = a3.type, b3 = a3.colorStops;
      a3 = a3.position.map((b4) => Math.round(b4 * c6.size));
      if ("linear-gradient" === e10) var h5 = t8.createLinearGradient.apply(t8, a3);
      else if ("radial-gradient" === e10) h5 = t8.createRadialGradient.apply(t8, a3);
      else throw Error("Unsupported fill");
      b3.forEach(([b4, a4]) => {
        h5.addColorStop(b4, a4);
      });
      t8.fillStyle = h5;
    }
  }
  function y3(t8, c6) {
    a: {
      var a3 = c6.text, e10 = c6.v, b3 = c6.N, h5 = c6.K, r9 = c6.P;
      b3 = Math.max(1, b3 || 1);
      for (h5 = Math.min(40, h5 || 40); b3 <= h5; b3 += 1) try {
        var d3 = B3(a3, e10, b3, r9);
        break a;
      } catch (J) {
      }
      d3 = void 0;
    }
    if (!d3) return null;
    a3 = t8.getContext("2d");
    c6.background && (a3.fillStyle = c6.background, a3.fillRect(c6.left, c6.top, c6.size, c6.size));
    e10 = d3.O;
    h5 = c6.size / e10;
    a3.beginPath();
    for (r9 = 0; r9 < e10; r9 += 1) for (b3 = 0; b3 < e10; b3 += 1) {
      var g3 = a3, x4 = c6.left + b3 * h5, u3 = c6.top + r9 * h5, p3 = r9, q3 = b3, f5 = d3.a, k3 = x4 + h5, m3 = u3 + h5, D3 = p3 - 1, E3 = p3 + 1, n7 = q3 - 1, l3 = q3 + 1, y4 = Math.floor(Math.min(0.5, Math.max(0, c6.R)) * h5), v4 = f5(p3, q3), I3 = f5(D3, n7), w4 = f5(D3, q3);
      D3 = f5(D3, l3);
      var F3 = f5(p3, l3);
      l3 = f5(E3, l3);
      q3 = f5(
        E3,
        q3
      );
      E3 = f5(E3, n7);
      p3 = f5(p3, n7);
      x4 = Math.round(x4);
      u3 = Math.round(u3);
      k3 = Math.round(k3);
      m3 = Math.round(m3);
      v4 ? C(g3, x4, u3, k3, m3, y4, !w4 && !p3, !w4 && !F3, !q3 && !F3, !q3 && !p3) : z3(g3, x4, u3, k3, m3, y4, w4 && p3 && I3, w4 && F3 && D3, q3 && F3 && l3, q3 && p3 && E3);
    }
    A(a3, c6);
    a3.fill();
    return t8;
  }
  var v3 = { minVersion: 1, maxVersion: 40, ecLevel: "L", left: 0, top: 0, size: 200, fill: "#000", background: null, text: "no text", radius: 0.5, quiet: 0 };
  G3 = function(t8, c6) {
    var a3 = {};
    Object.assign(a3, v3, t8);
    a3.N = a3.minVersion;
    a3.K = a3.maxVersion;
    a3.v = a3.ecLevel;
    a3.left = a3.left;
    a3.top = a3.top;
    a3.size = a3.size;
    a3.fill = a3.fill;
    a3.background = a3.background;
    a3.text = a3.text;
    a3.R = a3.radius;
    a3.P = a3.quiet;
    if (c6 instanceof HTMLCanvasElement) {
      if (c6.width !== a3.size || c6.height !== a3.size) c6.width = a3.size, c6.height = a3.size;
      c6.getContext("2d").clearRect(0, 0, c6.width, c6.height);
      y3(c6, a3);
    } else t8 = document.createElement("canvas"), t8.width = a3.size, t8.height = a3.size, a3 = y3(t8, a3), c6.appendChild(a3);
  };
})(function() {
  function w3(c6) {
    var a3 = C.s(c6);
    return { S: function() {
      return 4;
    }, b: function() {
      return a3.length;
    }, write: function(c7) {
      for (var b3 = 0; b3 < a3.length; b3 += 1) c7.put(a3[b3], 8);
    } };
  }
  function B3() {
    var c6 = [], a3 = 0, e10 = {
      B: function() {
        return c6;
      },
      c: function(b3) {
        return 1 == (c6[Math.floor(b3 / 8)] >>> 7 - b3 % 8 & 1);
      },
      put: function(b3, h5) {
        for (var a4 = 0; a4 < h5; a4 += 1) e10.m(1 == (b3 >>> h5 - a4 - 1 & 1));
      },
      f: function() {
        return a3;
      },
      m: function(b3) {
        var h5 = Math.floor(a3 / 8);
        c6.length <= h5 && c6.push(0);
        b3 && (c6[h5] |= 128 >>> a3 % 8);
        a3 += 1;
      }
    };
    return e10;
  }
  function C(c6, a3) {
    function e10(b4, h6) {
      for (var a4 = -1; 7 >= a4; a4 += 1) if (!(-1 >= b4 + a4 || d3 <= b4 + a4)) for (var c7 = -1; 7 >= c7; c7 += 1) -1 >= h6 + c7 || d3 <= h6 + c7 || (r9[b4 + a4][h6 + c7] = 0 <= a4 && 6 >= a4 && (0 == c7 || 6 == c7) || 0 <= c7 && 6 >= c7 && (0 == a4 || 6 == a4) || 2 <= a4 && 4 >= a4 && 2 <= c7 && 4 >= c7 ? true : false);
    }
    function b3(b4, a4) {
      for (var f5 = d3 = 4 * c6 + 17, k3 = Array(f5), m3 = 0; m3 < f5; m3 += 1) {
        k3[m3] = Array(f5);
        for (var p3 = 0; p3 < f5; p3 += 1) k3[m3][p3] = null;
      }
      r9 = k3;
      e10(0, 0);
      e10(d3 - 7, 0);
      e10(0, d3 - 7);
      f5 = y3.G(c6);
      for (k3 = 0; k3 < f5.length; k3 += 1) for (m3 = 0; m3 < f5.length; m3 += 1) {
        p3 = f5[k3];
        var q3 = f5[m3];
        if (null == r9[p3][q3]) for (var n7 = -2; 2 >= n7; n7 += 1) for (var l3 = -2; 2 >= l3; l3 += 1) r9[p3 + n7][q3 + l3] = -2 == n7 || 2 == n7 || -2 == l3 || 2 == l3 || 0 == n7 && 0 == l3;
      }
      for (f5 = 8; f5 < d3 - 8; f5 += 1) null == r9[f5][6] && (r9[f5][6] = 0 == f5 % 2);
      for (f5 = 8; f5 < d3 - 8; f5 += 1) null == r9[6][f5] && (r9[6][f5] = 0 == f5 % 2);
      f5 = y3.w(h5 << 3 | a4);
      for (k3 = 0; 15 > k3; k3 += 1) m3 = !b4 && 1 == (f5 >> k3 & 1), r9[6 > k3 ? k3 : 8 > k3 ? k3 + 1 : d3 - 15 + k3][8] = m3, r9[8][8 > k3 ? d3 - k3 - 1 : 9 > k3 ? 15 - k3 : 14 - k3] = m3;
      r9[d3 - 8][8] = !b4;
      if (7 <= c6) {
        f5 = y3.A(c6);
        for (k3 = 0; 18 > k3; k3 += 1) m3 = !b4 && 1 == (f5 >> k3 & 1), r9[Math.floor(k3 / 3)][k3 % 3 + d3 - 8 - 3] = m3;
        for (k3 = 0; 18 > k3; k3 += 1) m3 = !b4 && 1 == (f5 >> k3 & 1), r9[k3 % 3 + d3 - 8 - 3][Math.floor(k3 / 3)] = m3;
      }
      if (null == g3) {
        b4 = t8.I(c6, h5);
        f5 = B3();
        for (k3 = 0; k3 < x4.length; k3 += 1) m3 = x4[k3], f5.put(4, 4), f5.put(m3.b(), y3.f(4, c6)), m3.write(f5);
        for (k3 = m3 = 0; k3 < b4.length; k3 += 1) m3 += b4[k3].j;
        if (f5.f() > 8 * m3) throw Error("code length overflow. (" + f5.f() + ">" + 8 * m3 + ")");
        for (f5.f() + 4 <= 8 * m3 && f5.put(0, 4); 0 != f5.f() % 8; ) f5.m(false);
        for (; !(f5.f() >= 8 * m3); ) {
          f5.put(236, 8);
          if (f5.f() >= 8 * m3) break;
          f5.put(17, 8);
        }
        var u4 = 0;
        m3 = k3 = 0;
        p3 = Array(b4.length);
        q3 = Array(b4.length);
        for (n7 = 0; n7 < b4.length; n7 += 1) {
          var v4 = b4[n7].j, w4 = b4[n7].o - v4;
          k3 = Math.max(k3, v4);
          m3 = Math.max(m3, w4);
          p3[n7] = Array(v4);
          for (l3 = 0; l3 < p3[n7].length; l3 += 1) p3[n7][l3] = 255 & f5.B()[l3 + u4];
          u4 += v4;
          l3 = y3.C(w4);
          v4 = z3(p3[n7], l3.b() - 1).l(l3);
          q3[n7] = Array(l3.b() - 1);
          for (l3 = 0; l3 < q3[n7].length; l3 += 1) w4 = l3 + v4.b() - q3[n7].length, q3[n7][l3] = 0 <= w4 ? v4.c(w4) : 0;
        }
        for (l3 = f5 = 0; l3 < b4.length; l3 += 1) f5 += b4[l3].o;
        f5 = Array(f5);
        for (l3 = u4 = 0; l3 < k3; l3 += 1) for (n7 = 0; n7 < b4.length; n7 += 1) l3 < p3[n7].length && (f5[u4] = p3[n7][l3], u4 += 1);
        for (l3 = 0; l3 < m3; l3 += 1) for (n7 = 0; n7 < b4.length; n7 += 1) l3 < q3[n7].length && (f5[u4] = q3[n7][l3], u4 += 1);
        g3 = f5;
      }
      b4 = g3;
      f5 = -1;
      k3 = d3 - 1;
      m3 = 7;
      p3 = 0;
      a4 = y3.F(a4);
      for (q3 = d3 - 1; 0 < q3; q3 -= 2) for (6 == q3 && --q3; ; ) {
        for (n7 = 0; 2 > n7; n7 += 1) null == r9[k3][q3 - n7] && (l3 = false, p3 < b4.length && (l3 = 1 == (b4[p3] >>> m3 & 1)), a4(k3, q3 - n7) && (l3 = !l3), r9[k3][q3 - n7] = l3, --m3, -1 == m3 && (p3 += 1, m3 = 7));
        k3 += f5;
        if (0 > k3 || d3 <= k3) {
          k3 -= f5;
          f5 = -f5;
          break;
        }
      }
    }
    var h5 = A[a3], r9 = null, d3 = 0, g3 = null, x4 = [], u3 = { u: function(b4) {
      b4 = w3(b4);
      x4.push(b4);
      g3 = null;
    }, a: function(b4, a4) {
      if (0 > b4 || d3 <= b4 || 0 > a4 || d3 <= a4) throw Error(b4 + "," + a4);
      return r9[b4][a4];
    }, h: function() {
      return d3;
    }, J: function() {
      for (var a4 = 0, h6 = 0, c7 = 0; 8 > c7; c7 += 1) {
        b3(true, c7);
        var d4 = y3.D(u3);
        if (0 == c7 || a4 > d4) a4 = d4, h6 = c7;
      }
      b3(false, h6);
    } };
    return u3;
  }
  function z3(c6, a3) {
    if ("undefined" == typeof c6.length) throw Error(c6.length + "/" + a3);
    var e10 = function() {
      for (var b4 = 0; b4 < c6.length && 0 == c6[b4]; ) b4 += 1;
      for (var r9 = Array(c6.length - b4 + a3), d3 = 0; d3 < c6.length - b4; d3 += 1) r9[d3] = c6[d3 + b4];
      return r9;
    }(), b3 = { c: function(b4) {
      return e10[b4];
    }, b: function() {
      return e10.length;
    }, multiply: function(a4) {
      for (var h5 = Array(b3.b() + a4.b() - 1), c7 = 0; c7 < b3.b(); c7 += 1) for (var g3 = 0; g3 < a4.b(); g3 += 1) h5[c7 + g3] ^= v3.i(v3.g(b3.c(c7)) + v3.g(a4.c(g3)));
      return z3(h5, 0);
    }, l: function(a4) {
      if (0 > b3.b() - a4.b()) return b3;
      for (var c7 = v3.g(b3.c(0)) - v3.g(a4.c(0)), h5 = Array(b3.b()), g3 = 0; g3 < b3.b(); g3 += 1) h5[g3] = b3.c(g3);
      for (g3 = 0; g3 < a4.b(); g3 += 1) h5[g3] ^= v3.i(v3.g(a4.c(g3)) + c7);
      return z3(h5, 0).l(a4);
    } };
    return b3;
  }
  C.s = function(c6) {
    for (var a3 = [], e10 = 0; e10 < c6.length; e10++) {
      var b3 = c6.charCodeAt(e10);
      128 > b3 ? a3.push(b3) : 2048 > b3 ? a3.push(192 | b3 >> 6, 128 | b3 & 63) : 55296 > b3 || 57344 <= b3 ? a3.push(224 | b3 >> 12, 128 | b3 >> 6 & 63, 128 | b3 & 63) : (e10++, b3 = 65536 + ((b3 & 1023) << 10 | c6.charCodeAt(e10) & 1023), a3.push(240 | b3 >> 18, 128 | b3 >> 12 & 63, 128 | b3 >> 6 & 63, 128 | b3 & 63));
    }
    return a3;
  };
  var A = { L: 1, M: 0, Q: 3, H: 2 }, y3 = /* @__PURE__ */ function() {
    function c6(b3) {
      for (var a4 = 0; 0 != b3; ) a4 += 1, b3 >>>= 1;
      return a4;
    }
    var a3 = [
      [],
      [6, 18],
      [6, 22],
      [6, 26],
      [6, 30],
      [6, 34],
      [6, 22, 38],
      [6, 24, 42],
      [6, 26, 46],
      [6, 28, 50],
      [6, 30, 54],
      [6, 32, 58],
      [6, 34, 62],
      [6, 26, 46, 66],
      [6, 26, 48, 70],
      [6, 26, 50, 74],
      [6, 30, 54, 78],
      [6, 30, 56, 82],
      [6, 30, 58, 86],
      [6, 34, 62, 90],
      [6, 28, 50, 72, 94],
      [6, 26, 50, 74, 98],
      [6, 30, 54, 78, 102],
      [6, 28, 54, 80, 106],
      [6, 32, 58, 84, 110],
      [6, 30, 58, 86, 114],
      [6, 34, 62, 90, 118],
      [6, 26, 50, 74, 98, 122],
      [6, 30, 54, 78, 102, 126],
      [6, 26, 52, 78, 104, 130],
      [6, 30, 56, 82, 108, 134],
      [6, 34, 60, 86, 112, 138],
      [6, 30, 58, 86, 114, 142],
      [6, 34, 62, 90, 118, 146],
      [6, 30, 54, 78, 102, 126, 150],
      [6, 24, 50, 76, 102, 128, 154],
      [6, 28, 54, 80, 106, 132, 158],
      [6, 32, 58, 84, 110, 136, 162],
      [6, 26, 54, 82, 110, 138, 166],
      [6, 30, 58, 86, 114, 142, 170]
    ], e10 = { w: function(b3) {
      for (var a4 = b3 << 10; 0 <= c6(a4) - c6(1335); ) a4 ^= 1335 << c6(a4) - c6(1335);
      return (b3 << 10 | a4) ^ 21522;
    }, A: function(b3) {
      for (var a4 = b3 << 12; 0 <= c6(a4) - c6(7973); ) a4 ^= 7973 << c6(a4) - c6(7973);
      return b3 << 12 | a4;
    }, G: function(b3) {
      return a3[b3 - 1];
    }, F: function(b3) {
      switch (b3) {
        case 0:
          return function(b4, a4) {
            return 0 == (b4 + a4) % 2;
          };
        case 1:
          return function(b4) {
            return 0 == b4 % 2;
          };
        case 2:
          return function(b4, a4) {
            return 0 == a4 % 3;
          };
        case 3:
          return function(b4, a4) {
            return 0 == (b4 + a4) % 3;
          };
        case 4:
          return function(b4, a4) {
            return 0 == (Math.floor(b4 / 2) + Math.floor(a4 / 3)) % 2;
          };
        case 5:
          return function(b4, a4) {
            return 0 == b4 * a4 % 2 + b4 * a4 % 3;
          };
        case 6:
          return function(b4, a4) {
            return 0 == (b4 * a4 % 2 + b4 * a4 % 3) % 2;
          };
        case 7:
          return function(b4, a4) {
            return 0 == (b4 * a4 % 3 + (b4 + a4) % 2) % 2;
          };
        default:
          throw Error("bad maskPattern:" + b3);
      }
    }, C: function(b3) {
      for (var a4 = z3([1], 0), c7 = 0; c7 < b3; c7 += 1) a4 = a4.multiply(z3([1, v3.i(c7)], 0));
      return a4;
    }, f: function(b3, a4) {
      if (4 != b3 || 1 > a4 || 40 < a4) throw Error("mode: " + b3 + "; type: " + a4);
      return 10 > a4 ? 8 : 16;
    }, D: function(b3) {
      for (var a4 = b3.h(), c7 = 0, d3 = 0; d3 < a4; d3 += 1) for (var g3 = 0; g3 < a4; g3 += 1) {
        for (var e11 = 0, t9 = b3.a(d3, g3), p3 = -1; 1 >= p3; p3 += 1) if (!(0 > d3 + p3 || a4 <= d3 + p3)) for (var q3 = -1; 1 >= q3; q3 += 1) 0 > g3 + q3 || a4 <= g3 + q3 || (0 != p3 || 0 != q3) && t9 == b3.a(d3 + p3, g3 + q3) && (e11 += 1);
        5 < e11 && (c7 += 3 + e11 - 5);
      }
      for (d3 = 0; d3 < a4 - 1; d3 += 1) for (g3 = 0; g3 < a4 - 1; g3 += 1) if (e11 = 0, b3.a(d3, g3) && (e11 += 1), b3.a(d3 + 1, g3) && (e11 += 1), b3.a(d3, g3 + 1) && (e11 += 1), b3.a(d3 + 1, g3 + 1) && (e11 += 1), 0 == e11 || 4 == e11) c7 += 3;
      for (d3 = 0; d3 < a4; d3 += 1) for (g3 = 0; g3 < a4 - 6; g3 += 1) b3.a(d3, g3) && !b3.a(d3, g3 + 1) && b3.a(d3, g3 + 2) && b3.a(d3, g3 + 3) && b3.a(d3, g3 + 4) && !b3.a(d3, g3 + 5) && b3.a(d3, g3 + 6) && (c7 += 40);
      for (g3 = 0; g3 < a4; g3 += 1) for (d3 = 0; d3 < a4 - 6; d3 += 1) b3.a(d3, g3) && !b3.a(d3 + 1, g3) && b3.a(d3 + 2, g3) && b3.a(d3 + 3, g3) && b3.a(d3 + 4, g3) && !b3.a(d3 + 5, g3) && b3.a(d3 + 6, g3) && (c7 += 40);
      for (g3 = e11 = 0; g3 < a4; g3 += 1) for (d3 = 0; d3 < a4; d3 += 1) b3.a(d3, g3) && (e11 += 1);
      return c7 += Math.abs(100 * e11 / a4 / a4 - 50) / 5 * 10;
    } };
    return e10;
  }(), v3 = function() {
    for (var c6 = Array(256), a3 = Array(256), e10 = 0; 8 > e10; e10 += 1) c6[e10] = 1 << e10;
    for (e10 = 8; 256 > e10; e10 += 1) c6[e10] = c6[e10 - 4] ^ c6[e10 - 5] ^ c6[e10 - 6] ^ c6[e10 - 8];
    for (e10 = 0; 255 > e10; e10 += 1) a3[c6[e10]] = e10;
    return { g: function(b3) {
      if (1 > b3) throw Error("glog(" + b3 + ")");
      return a3[b3];
    }, i: function(b3) {
      for (; 0 > b3; ) b3 += 255;
      for (; 256 <= b3; ) b3 -= 255;
      return c6[b3];
    } };
  }(), t8 = /* @__PURE__ */ function() {
    function c6(b3, c7) {
      switch (c7) {
        case A.L:
          return a3[4 * (b3 - 1)];
        case A.M:
          return a3[4 * (b3 - 1) + 1];
        case A.Q:
          return a3[4 * (b3 - 1) + 2];
        case A.H:
          return a3[4 * (b3 - 1) + 3];
      }
    }
    var a3 = [
      [1, 26, 19],
      [1, 26, 16],
      [1, 26, 13],
      [1, 26, 9],
      [1, 44, 34],
      [1, 44, 28],
      [1, 44, 22],
      [1, 44, 16],
      [1, 70, 55],
      [1, 70, 44],
      [2, 35, 17],
      [2, 35, 13],
      [1, 100, 80],
      [2, 50, 32],
      [2, 50, 24],
      [4, 25, 9],
      [1, 134, 108],
      [2, 67, 43],
      [2, 33, 15, 2, 34, 16],
      [2, 33, 11, 2, 34, 12],
      [2, 86, 68],
      [4, 43, 27],
      [4, 43, 19],
      [4, 43, 15],
      [2, 98, 78],
      [4, 49, 31],
      [2, 32, 14, 4, 33, 15],
      [4, 39, 13, 1, 40, 14],
      [2, 121, 97],
      [2, 60, 38, 2, 61, 39],
      [4, 40, 18, 2, 41, 19],
      [4, 40, 14, 2, 41, 15],
      [2, 146, 116],
      [
        3,
        58,
        36,
        2,
        59,
        37
      ],
      [4, 36, 16, 4, 37, 17],
      [4, 36, 12, 4, 37, 13],
      [2, 86, 68, 2, 87, 69],
      [4, 69, 43, 1, 70, 44],
      [6, 43, 19, 2, 44, 20],
      [6, 43, 15, 2, 44, 16],
      [4, 101, 81],
      [1, 80, 50, 4, 81, 51],
      [4, 50, 22, 4, 51, 23],
      [3, 36, 12, 8, 37, 13],
      [2, 116, 92, 2, 117, 93],
      [6, 58, 36, 2, 59, 37],
      [4, 46, 20, 6, 47, 21],
      [7, 42, 14, 4, 43, 15],
      [4, 133, 107],
      [8, 59, 37, 1, 60, 38],
      [8, 44, 20, 4, 45, 21],
      [12, 33, 11, 4, 34, 12],
      [3, 145, 115, 1, 146, 116],
      [4, 64, 40, 5, 65, 41],
      [11, 36, 16, 5, 37, 17],
      [11, 36, 12, 5, 37, 13],
      [5, 109, 87, 1, 110, 88],
      [5, 65, 41, 5, 66, 42],
      [5, 54, 24, 7, 55, 25],
      [11, 36, 12, 7, 37, 13],
      [5, 122, 98, 1, 123, 99],
      [
        7,
        73,
        45,
        3,
        74,
        46
      ],
      [15, 43, 19, 2, 44, 20],
      [3, 45, 15, 13, 46, 16],
      [1, 135, 107, 5, 136, 108],
      [10, 74, 46, 1, 75, 47],
      [1, 50, 22, 15, 51, 23],
      [2, 42, 14, 17, 43, 15],
      [5, 150, 120, 1, 151, 121],
      [9, 69, 43, 4, 70, 44],
      [17, 50, 22, 1, 51, 23],
      [2, 42, 14, 19, 43, 15],
      [3, 141, 113, 4, 142, 114],
      [3, 70, 44, 11, 71, 45],
      [17, 47, 21, 4, 48, 22],
      [9, 39, 13, 16, 40, 14],
      [3, 135, 107, 5, 136, 108],
      [3, 67, 41, 13, 68, 42],
      [15, 54, 24, 5, 55, 25],
      [15, 43, 15, 10, 44, 16],
      [4, 144, 116, 4, 145, 117],
      [17, 68, 42],
      [17, 50, 22, 6, 51, 23],
      [19, 46, 16, 6, 47, 17],
      [2, 139, 111, 7, 140, 112],
      [17, 74, 46],
      [7, 54, 24, 16, 55, 25],
      [34, 37, 13],
      [
        4,
        151,
        121,
        5,
        152,
        122
      ],
      [4, 75, 47, 14, 76, 48],
      [11, 54, 24, 14, 55, 25],
      [16, 45, 15, 14, 46, 16],
      [6, 147, 117, 4, 148, 118],
      [6, 73, 45, 14, 74, 46],
      [11, 54, 24, 16, 55, 25],
      [30, 46, 16, 2, 47, 17],
      [8, 132, 106, 4, 133, 107],
      [8, 75, 47, 13, 76, 48],
      [7, 54, 24, 22, 55, 25],
      [22, 45, 15, 13, 46, 16],
      [10, 142, 114, 2, 143, 115],
      [19, 74, 46, 4, 75, 47],
      [28, 50, 22, 6, 51, 23],
      [33, 46, 16, 4, 47, 17],
      [8, 152, 122, 4, 153, 123],
      [22, 73, 45, 3, 74, 46],
      [8, 53, 23, 26, 54, 24],
      [12, 45, 15, 28, 46, 16],
      [3, 147, 117, 10, 148, 118],
      [3, 73, 45, 23, 74, 46],
      [4, 54, 24, 31, 55, 25],
      [11, 45, 15, 31, 46, 16],
      [7, 146, 116, 7, 147, 117],
      [21, 73, 45, 7, 74, 46],
      [1, 53, 23, 37, 54, 24],
      [19, 45, 15, 26, 46, 16],
      [5, 145, 115, 10, 146, 116],
      [19, 75, 47, 10, 76, 48],
      [15, 54, 24, 25, 55, 25],
      [23, 45, 15, 25, 46, 16],
      [13, 145, 115, 3, 146, 116],
      [2, 74, 46, 29, 75, 47],
      [42, 54, 24, 1, 55, 25],
      [23, 45, 15, 28, 46, 16],
      [17, 145, 115],
      [10, 74, 46, 23, 75, 47],
      [10, 54, 24, 35, 55, 25],
      [19, 45, 15, 35, 46, 16],
      [17, 145, 115, 1, 146, 116],
      [14, 74, 46, 21, 75, 47],
      [29, 54, 24, 19, 55, 25],
      [11, 45, 15, 46, 46, 16],
      [13, 145, 115, 6, 146, 116],
      [14, 74, 46, 23, 75, 47],
      [44, 54, 24, 7, 55, 25],
      [59, 46, 16, 1, 47, 17],
      [12, 151, 121, 7, 152, 122],
      [12, 75, 47, 26, 76, 48],
      [39, 54, 24, 14, 55, 25],
      [22, 45, 15, 41, 46, 16],
      [6, 151, 121, 14, 152, 122],
      [6, 75, 47, 34, 76, 48],
      [46, 54, 24, 10, 55, 25],
      [2, 45, 15, 64, 46, 16],
      [17, 152, 122, 4, 153, 123],
      [29, 74, 46, 14, 75, 47],
      [49, 54, 24, 10, 55, 25],
      [24, 45, 15, 46, 46, 16],
      [4, 152, 122, 18, 153, 123],
      [13, 74, 46, 32, 75, 47],
      [48, 54, 24, 14, 55, 25],
      [42, 45, 15, 32, 46, 16],
      [20, 147, 117, 4, 148, 118],
      [40, 75, 47, 7, 76, 48],
      [43, 54, 24, 22, 55, 25],
      [10, 45, 15, 67, 46, 16],
      [19, 148, 118, 6, 149, 119],
      [18, 75, 47, 31, 76, 48],
      [34, 54, 24, 34, 55, 25],
      [20, 45, 15, 61, 46, 16]
    ], e10 = { I: function(b3, a4) {
      var e11 = c6(b3, a4);
      if ("undefined" == typeof e11) throw Error("bad rs block @ typeNumber:" + b3 + "/errorCorrectLevel:" + a4);
      b3 = e11.length / 3;
      a4 = [];
      for (var d3 = 0; d3 < b3; d3 += 1) for (var g3 = e11[3 * d3], h5 = e11[3 * d3 + 1], t9 = e11[3 * d3 + 2], p3 = 0; p3 < g3; p3 += 1) {
        var q3 = t9, f5 = {};
        f5.o = h5;
        f5.j = q3;
        a4.push(f5);
      }
      return a4;
    } };
    return e10;
  }();
  return C;
}());
var qr_creator_es6_min_default = QrCreator;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2ES3IGE6.js
var SlQrCode = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.value = "";
    this.label = "";
    this.size = 128;
    this.fill = "black";
    this.background = "white";
    this.radius = 0;
    this.errorCorrection = "H";
  }
  firstUpdated() {
    this.generate();
  }
  generate() {
    if (!this.hasUpdated) {
      return;
    }
    qr_creator_es6_min_default.render(
      {
        text: this.value,
        radius: this.radius,
        ecLevel: this.errorCorrection,
        fill: this.fill,
        background: this.background,
        // We draw the canvas larger and scale its container down to avoid blurring on high-density displays
        size: this.size * 2
      },
      this.canvas
    );
  }
  render() {
    var _a24;
    return ke`
      <canvas
        part="base"
        class="qr-code"
        role="img"
        aria-label=${((_a24 = this.label) == null ? void 0 : _a24.length) > 0 ? this.label : this.value}
        style=${se({
      width: `${this.size}px`,
      height: `${this.size}px`
    })}
      ></canvas>
    `;
  }
};
SlQrCode.styles = [component_styles_default, qr_code_styles_default];
__decorateClass([
  e7("canvas")
], SlQrCode.prototype, "canvas", 2);
__decorateClass([
  n6()
], SlQrCode.prototype, "value", 2);
__decorateClass([
  n6()
], SlQrCode.prototype, "label", 2);
__decorateClass([
  n6({ type: Number })
], SlQrCode.prototype, "size", 2);
__decorateClass([
  n6()
], SlQrCode.prototype, "fill", 2);
__decorateClass([
  n6()
], SlQrCode.prototype, "background", 2);
__decorateClass([
  n6({ type: Number })
], SlQrCode.prototype, "radius", 2);
__decorateClass([
  n6({ attribute: "error-correction" })
], SlQrCode.prototype, "errorCorrection", 2);
__decorateClass([
  watch(["background", "errorCorrection", "fill", "radius", "size", "value"])
], SlQrCode.prototype, "generate", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SWS433Z2.js
SlQrCode.define("sl-qr-code");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.FKMWLPHV.js
var radio_styles_default = i`
  :host {
    display: block;
  }

  :host(:focus-visible) {
    outline: 0px;
  }

  .radio {
    display: inline-flex;
    align-items: top;
    font-family: var(--sl-input-font-family);
    font-size: var(--sl-input-font-size-medium);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .radio--small {
    --toggle-size: var(--sl-toggle-size-small);
    font-size: var(--sl-input-font-size-small);
  }

  .radio--medium {
    --toggle-size: var(--sl-toggle-size-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .radio--large {
    --toggle-size: var(--sl-toggle-size-large);
    font-size: var(--sl-input-font-size-large);
  }

  .radio__checked-icon {
    display: inline-flex;
    width: var(--toggle-size);
    height: var(--toggle-size);
  }

  .radio__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--toggle-size);
    height: var(--toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 50%;
    background-color: var(--sl-input-background-color);
    color: transparent;
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
  }

  .radio__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  /* Hover */
  .radio:not(.radio--checked):not(.radio--disabled) .radio__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Checked */
  .radio--checked .radio__control {
    color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked + hover */
  .radio.radio--checked:not(.radio--disabled) .radio__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked + focus */
  :host(:focus-visible) .radio__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .radio--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When the control isn't checked, hide the circle for Windows High Contrast mode a11y */
  .radio:not(.radio--checked) svg circle {
    opacity: 0;
  }

  .radio__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    line-height: var(--toggle-size);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GTNKLGVA.js
var SlRadio = class extends ShoelaceElement {
  constructor() {
    super();
    this.checked = false;
    this.hasFocus = false;
    this.size = "medium";
    this.disabled = false;
    this.handleBlur = () => {
      this.hasFocus = false;
      this.emit("sl-blur");
    };
    this.handleClick = () => {
      if (!this.disabled) {
        this.checked = true;
      }
    };
    this.handleFocus = () => {
      this.hasFocus = true;
      this.emit("sl-focus");
    };
    this.addEventListener("blur", this.handleBlur);
    this.addEventListener("click", this.handleClick);
    this.addEventListener("focus", this.handleFocus);
  }
  connectedCallback() {
    super.connectedCallback();
    this.setInitialAttributes();
  }
  setInitialAttributes() {
    this.setAttribute("role", "radio");
    this.setAttribute("tabindex", "-1");
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleCheckedChange() {
    this.setAttribute("aria-checked", this.checked ? "true" : "false");
    this.setAttribute("tabindex", this.checked ? "0" : "-1");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  render() {
    return ke`
      <span
        part="base"
        class=${Rt({
      radio: true,
      "radio--checked": this.checked,
      "radio--disabled": this.disabled,
      "radio--focused": this.hasFocus,
      "radio--small": this.size === "small",
      "radio--medium": this.size === "medium",
      "radio--large": this.size === "large"
    })}
      >
        <span part="${`control${this.checked ? " control--checked" : ""}`}" class="radio__control">
          ${this.checked ? ke` <sl-icon part="checked-icon" class="radio__checked-icon" library="system" name="radio"></sl-icon> ` : ""}
        </span>

        <slot part="label" class="radio__label"></slot>
      </span>
    `;
  }
};
SlRadio.styles = [component_styles_default, radio_styles_default];
SlRadio.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  r5()
], SlRadio.prototype, "checked", 2);
__decorateClass([
  r5()
], SlRadio.prototype, "hasFocus", 2);
__decorateClass([
  n6()
], SlRadio.prototype, "value", 2);
__decorateClass([
  n6({ reflect: true })
], SlRadio.prototype, "size", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlRadio.prototype, "disabled", 2);
__decorateClass([
  watch("checked")
], SlRadio.prototype, "handleCheckedChange", 1);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlRadio.prototype, "handleDisabledChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.RTXWOK5I.js
SlRadio.define("sl-radio");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.FXXKMG2P.js
var option_styles_default = i`
  :host {
    display: block;
    user-select: none;
    -webkit-user-select: none;
  }

  :host(:focus) {
    outline: none;
  }

  .option {
    position: relative;
    display: flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-x-small) var(--sl-spacing-medium) var(--sl-spacing-x-small) var(--sl-spacing-x-small);
    transition: var(--sl-transition-fast) fill;
    cursor: pointer;
  }

  .option--hover:not(.option--current):not(.option--disabled) {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  .option--current,
  .option--current.option--disabled {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .option--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .option__label {
    flex: 1 1 auto;
    display: inline-block;
    line-height: var(--sl-line-height-dense);
  }

  .option .option__check {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    visibility: hidden;
    padding-inline-end: var(--sl-spacing-2x-small);
  }

  .option--selected .option__check {
    visibility: visible;
  }

  .option__prefix,
  .option__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .option__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .option__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .option {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.BSVOYXQV.js
var SlOption = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.current = false;
    this.selected = false;
    this.hasHover = false;
    this.value = "";
    this.disabled = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "option");
    this.setAttribute("aria-selected", "false");
  }
  handleDefaultSlotChange() {
    const textLabel = this.getTextLabel();
    if (typeof this.cachedTextLabel === "undefined") {
      this.cachedTextLabel = textLabel;
      return;
    }
    if (textLabel !== this.cachedTextLabel) {
      this.cachedTextLabel = textLabel;
      this.emit("slotchange", { bubbles: true, composed: false, cancelable: false });
    }
  }
  handleMouseEnter() {
    this.hasHover = true;
  }
  handleMouseLeave() {
    this.hasHover = false;
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleSelectedChange() {
    this.setAttribute("aria-selected", this.selected ? "true" : "false");
  }
  handleValueChange() {
    if (typeof this.value !== "string") {
      this.value = String(this.value);
    }
    if (this.value.includes(" ")) {
      console.error(`Option values cannot include a space. All spaces have been replaced with underscores.`, this);
      this.value = this.value.replace(/ /g, "_");
    }
  }
  /** Returns a plain text label based on the option's content. */
  getTextLabel() {
    const nodes = this.childNodes;
    let label = "";
    [...nodes].forEach((node) => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        if (!node.hasAttribute("slot")) {
          label += node.textContent;
        }
      }
      if (node.nodeType === Node.TEXT_NODE) {
        label += node.textContent;
      }
    });
    return label.trim();
  }
  render() {
    return ke`
      <div
        part="base"
        class=${Rt({
      option: true,
      "option--current": this.current,
      "option--disabled": this.disabled,
      "option--selected": this.selected,
      "option--hover": this.hasHover
    })}
        @mouseenter=${this.handleMouseEnter}
        @mouseleave=${this.handleMouseLeave}
      >
        <sl-icon part="checked-icon" class="option__check" name="check" library="system" aria-hidden="true"></sl-icon>
        <slot part="prefix" name="prefix" class="option__prefix"></slot>
        <slot part="label" class="option__label" @slotchange=${this.handleDefaultSlotChange}></slot>
        <slot part="suffix" name="suffix" class="option__suffix"></slot>
      </div>
    `;
  }
};
SlOption.styles = [component_styles_default, option_styles_default];
SlOption.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e7(".option__label")
], SlOption.prototype, "defaultSlot", 2);
__decorateClass([
  r5()
], SlOption.prototype, "current", 2);
__decorateClass([
  r5()
], SlOption.prototype, "selected", 2);
__decorateClass([
  r5()
], SlOption.prototype, "hasHover", 2);
__decorateClass([
  n6({ reflect: true })
], SlOption.prototype, "value", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlOption.prototype, "disabled", 2);
__decorateClass([
  watch("disabled")
], SlOption.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("selected")
], SlOption.prototype, "handleSelectedChange", 1);
__decorateClass([
  watch("value")
], SlOption.prototype, "handleValueChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.NL3CVVMV.js
var option_default = SlOption;
SlOption.define("sl-option");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.JCYNYY3E.js
SlPopup.define("sl-popup");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GXC456DW.js
var progress_bar_styles_default = i`
  :host {
    --height: 1rem;
    --track-color: var(--sl-color-neutral-200);
    --indicator-color: var(--sl-color-primary-600);
    --label-color: var(--sl-color-neutral-0);

    display: block;
  }

  .progress-bar {
    position: relative;
    background-color: var(--track-color);
    height: var(--height);
    border-radius: var(--sl-border-radius-pill);
    box-shadow: inset var(--sl-shadow-small);
    overflow: hidden;
  }

  .progress-bar__indicator {
    height: 100%;
    font-family: var(--sl-font-sans);
    font-size: 12px;
    font-weight: var(--sl-font-weight-normal);
    background-color: var(--indicator-color);
    color: var(--label-color);
    text-align: center;
    line-height: var(--height);
    white-space: nowrap;
    overflow: hidden;
    transition:
      400ms width,
      400ms background-color;
    user-select: none;
    -webkit-user-select: none;
  }

  /* Indeterminate */
  .progress-bar--indeterminate .progress-bar__indicator {
    position: absolute;
    animation: indeterminate 2.5s infinite cubic-bezier(0.37, 0, 0.63, 1);
  }

  .progress-bar--indeterminate.progress-bar--rtl .progress-bar__indicator {
    animation-name: indeterminate-rtl;
  }

  @media (forced-colors: active) {
    .progress-bar {
      outline: solid 1px SelectedItem;
      background-color: var(--sl-color-neutral-0);
    }

    .progress-bar__indicator {
      outline: solid 1px SelectedItem;
      background-color: SelectedItem;
    }
  }

  @keyframes indeterminate {
    0% {
      left: -50%;
      width: 50%;
    }
    75%,
    100% {
      left: 100%;
      width: 50%;
    }
  }

  @keyframes indeterminate-rtl {
    0% {
      right: -50%;
      width: 50%;
    }
    75%,
    100% {
      right: 100%;
      width: 50%;
    }
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2S7DHWQZ.js
var SlProgressBar = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.value = 0;
    this.indeterminate = false;
    this.label = "";
  }
  render() {
    return ke`
      <div
        part="base"
        class=${Rt({
      "progress-bar": true,
      "progress-bar--indeterminate": this.indeterminate,
      "progress-bar--rtl": this.localize.dir() === "rtl"
    })}
        role="progressbar"
        title=${to(this.title)}
        aria-label=${this.label.length > 0 ? this.label : this.localize.term("progress")}
        aria-valuemin="0"
        aria-valuemax="100"
        aria-valuenow=${this.indeterminate ? 0 : this.value}
      >
        <div part="indicator" class="progress-bar__indicator" style=${se({ width: `${this.value}%` })}>
          ${!this.indeterminate ? ke` <slot part="label" class="progress-bar__label"></slot> ` : ""}
        </div>
      </div>
    `;
  }
};
SlProgressBar.styles = [component_styles_default, progress_bar_styles_default];
__decorateClass([
  n6({ type: Number, reflect: true })
], SlProgressBar.prototype, "value", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlProgressBar.prototype, "indeterminate", 2);
__decorateClass([
  n6()
], SlProgressBar.prototype, "label", 2);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.VO7MMZV3.js
SlProgressBar.define("sl-progress-bar");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2W6X55FG.js
var mutation_observer_styles_default = i`
  :host {
    display: contents;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.S2K2Q7FF.js
var SlMutationObserver = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.attrOldValue = false;
    this.charData = false;
    this.charDataOldValue = false;
    this.childList = false;
    this.disabled = false;
    this.handleMutation = (mutationList) => {
      this.emit("sl-mutation", {
        detail: { mutationList }
      });
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.mutationObserver = new MutationObserver(this.handleMutation);
    if (!this.disabled) {
      this.startObserver();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stopObserver();
  }
  startObserver() {
    const observeAttributes = typeof this.attr === "string" && this.attr.length > 0;
    const attributeFilter = observeAttributes && this.attr !== "*" ? this.attr.split(" ") : void 0;
    try {
      this.mutationObserver.observe(this, {
        subtree: true,
        childList: this.childList,
        attributes: observeAttributes,
        attributeFilter,
        attributeOldValue: this.attrOldValue,
        characterData: this.charData,
        characterDataOldValue: this.charDataOldValue
      });
    } catch (e10) {
    }
  }
  stopObserver() {
    this.mutationObserver.disconnect();
  }
  handleDisabledChange() {
    if (this.disabled) {
      this.stopObserver();
    } else {
      this.startObserver();
    }
  }
  handleChange() {
    this.stopObserver();
    this.startObserver();
  }
  render() {
    return ke` <slot></slot> `;
  }
};
SlMutationObserver.styles = [component_styles_default, mutation_observer_styles_default];
__decorateClass([
  n6({ reflect: true })
], SlMutationObserver.prototype, "attr", 2);
__decorateClass([
  n6({ attribute: "attr-old-value", type: Boolean, reflect: true })
], SlMutationObserver.prototype, "attrOldValue", 2);
__decorateClass([
  n6({ attribute: "char-data", type: Boolean, reflect: true })
], SlMutationObserver.prototype, "charData", 2);
__decorateClass([
  n6({ attribute: "char-data-old-value", type: Boolean, reflect: true })
], SlMutationObserver.prototype, "charDataOldValue", 2);
__decorateClass([
  n6({ attribute: "child-list", type: Boolean, reflect: true })
], SlMutationObserver.prototype, "childList", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlMutationObserver.prototype, "disabled", 2);
__decorateClass([
  watch("disabled")
], SlMutationObserver.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("attr", { waitUntilFirstUpdate: true }),
  watch("attr-old-value", { waitUntilFirstUpdate: true }),
  watch("char-data", { waitUntilFirstUpdate: true }),
  watch("char-data-old-value", { waitUntilFirstUpdate: true }),
  watch("childList", { waitUntilFirstUpdate: true })
], SlMutationObserver.prototype, "handleChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.WSDIVFUV.js
SlMutationObserver.define("sl-mutation-observer");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.KWZXGPBI.js
var menu_item_styles_default = i`
  :host {
    --submenu-offset: -2px;

    display: block;
  }

  :host([inert]) {
    display: none;
  }

  .menu-item {
    position: relative;
    display: flex;
    align-items: stretch;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-2x-small) var(--sl-spacing-2x-small);
    transition: var(--sl-transition-fast) fill;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    cursor: pointer;
  }

  .menu-item.menu-item--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .menu-item.menu-item--loading {
    outline: none;
    cursor: wait;
  }

  .menu-item.menu-item--loading *:not(sl-spinner) {
    opacity: 0.5;
  }

  .menu-item--loading sl-spinner {
    --indicator-color: currentColor;
    --track-width: 1px;
    position: absolute;
    font-size: 0.75em;
    top: calc(50% - 0.5em);
    left: 0.65rem;
    opacity: 1;
  }

  .menu-item .menu-item__label {
    flex: 1 1 auto;
    display: inline-block;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  .menu-item .menu-item__prefix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .menu-item .menu-item__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /* Safe triangle */
  .menu-item--submenu-expanded::after {
    content: '';
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--safe-triangle-cursor-x, 0) var(--safe-triangle-cursor-y, 0),
      var(--safe-triangle-submenu-start-x, 0) var(--safe-triangle-submenu-start-y, 0),
      var(--safe-triangle-submenu-end-x, 0) var(--safe-triangle-submenu-end-y, 0)
    );
  }

  :host(:focus-visible) {
    outline: none;
  }

  :host(:hover:not([aria-disabled='true'], :focus-visible)) .menu-item,
  .menu-item--submenu-expanded {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  :host(:focus-visible) .menu-item {
    outline: none;
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .menu-item .menu-item__check,
  .menu-item .menu-item__chevron {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 1.5em;
    visibility: hidden;
  }

  .menu-item--checked .menu-item__check,
  .menu-item--has-submenu .menu-item__chevron {
    visibility: visible;
  }

  /* Add elevation and z-index to submenus */
  sl-popup::part(popup) {
    box-shadow: var(--sl-shadow-large);
    z-index: var(--sl-z-index-dropdown);
    margin-left: var(--submenu-offset);
  }

  .menu-item--rtl sl-popup::part(popup) {
    margin-left: calc(-1 * var(--submenu-offset));
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .menu-item,
    :host(:focus-visible) .menu-item {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }
`;

// src/node_modules/lit-html/async-directive.js
var mt = (i5, t8) => {
  const e10 = i5._$AN;
  if (void 0 === e10) return false;
  for (const i6 of e10) i6._$AO?.(t8, false), mt(i6, t8);
  return true;
};
var _t = (i5) => {
  let t8, e10;
  do {
    if (void 0 === (t8 = i5._$AM)) break;
    e10 = t8._$AN, e10.delete(i5), i5 = t8;
  } while (0 === e10?.size);
};
var wt = (i5) => {
  for (let t8; t8 = i5._$AM; i5 = t8) {
    let e10 = t8._$AN;
    if (void 0 === e10) t8._$AN = e10 = /* @__PURE__ */ new Set();
    else if (e10.has(i5)) break;
    e10.add(i5), gt(t8);
  }
};
function bt(i5) {
  void 0 !== this._$AN ? (_t(this), this._$AM = i5, wt(this)) : this._$AM = i5;
}
function yt(i5, t8 = false, e10 = 0) {
  const s6 = this._$AH, o7 = this._$AN;
  if (void 0 !== o7 && 0 !== o7.size) if (t8) if (Array.isArray(s6)) for (let i6 = e10; i6 < s6.length; i6++) mt(s6[i6], false), _t(s6[i6]);
  else null != s6 && (mt(s6, false), _t(s6));
  else mt(this, i5);
}
var gt = (i5) => {
  i5.type == t6.CHILD && (i5._$AP ??= yt, i5._$AQ ??= bt);
};
var $t = class extends i4 {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(i5, t8, e10) {
    super._$AT(i5, t8, e10), wt(this), this.isConnected = i5._$AU;
  }
  _$AO(i5, t8 = true) {
    i5 !== this.isConnected && (this.isConnected = i5, i5 ? this.reconnected?.() : this.disconnected?.()), t8 && (mt(this, i5), _t(this));
  }
  setValue(i5) {
    if (rt(this.t)) this.t._$AI(i5, this);
    else {
      const t8 = [...this.t._$AH];
      t8[this.i] = i5, this.t._$AI(t8, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};

// src/node_modules/lit-html/directives/ref.js
var ii = () => new Zt();
var Zt = class {
};
var qt = /* @__PURE__ */ new WeakMap();
var Kt = e9(class extends $t {
  render(t8) {
    return D;
  }
  update(t8, [i5]) {
    const s6 = i5 !== this.Y;
    return s6 && void 0 !== this.Y && this.rt(void 0), (s6 || this.lt !== this.ct) && (this.Y = i5, this.ht = t8.options?.host, this.rt(this.ct = t8.element)), D;
  }
  rt(t8) {
    if (this.isConnected || (t8 = void 0), "function" == typeof this.Y) {
      const i5 = this.ht ?? globalThis;
      let s6 = qt.get(i5);
      void 0 === s6 && (s6 = /* @__PURE__ */ new WeakMap(), qt.set(i5, s6)), void 0 !== s6.get(this.Y) && this.Y.call(this.ht, void 0), s6.set(this.Y, t8), void 0 !== t8 && this.Y.call(this.ht, t8);
    } else this.Y.value = t8;
  }
  get lt() {
    return "function" == typeof this.Y ? qt.get(this.ht ?? globalThis)?.get(this.Y) : this.Y?.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2F4HXDFL.js
var SubmenuController = class {
  constructor(host, hasSlotController, localize) {
    this.popupRef = ii();
    this.enableSubmenuTimer = -1;
    this.isConnected = false;
    this.isPopupConnected = false;
    this.skidding = 0;
    this.submenuOpenDelay = 100;
    this.handleMouseMove = (event) => {
      this.host.style.setProperty("--safe-triangle-cursor-x", `${event.clientX}px`);
      this.host.style.setProperty("--safe-triangle-cursor-y", `${event.clientY}px`);
    };
    this.handleMouseOver = () => {
      if (this.hasSlotController.test("submenu")) {
        this.enableSubmenu();
      }
    };
    this.handleKeyDown = (event) => {
      switch (event.key) {
        case "Escape":
        case "Tab":
          this.disableSubmenu();
          break;
        case "ArrowLeft":
          if (event.target !== this.host) {
            event.preventDefault();
            event.stopPropagation();
            this.host.focus();
            this.disableSubmenu();
          }
          break;
        case "ArrowRight":
        case "Enter":
        case " ":
          this.handleSubmenuEntry(event);
          break;
        default:
          break;
      }
    };
    this.handleClick = (event) => {
      var _a24;
      if (event.target === this.host) {
        event.preventDefault();
        event.stopPropagation();
      } else if (event.target instanceof Element && (event.target.tagName === "sl-menu-item" || ((_a24 = event.target.role) == null ? void 0 : _a24.startsWith("menuitem")))) {
        this.disableSubmenu();
      }
    };
    this.handleFocusOut = (event) => {
      if (event.relatedTarget && event.relatedTarget instanceof Element && this.host.contains(event.relatedTarget)) {
        return;
      }
      this.disableSubmenu();
    };
    this.handlePopupMouseover = (event) => {
      event.stopPropagation();
    };
    this.handlePopupReposition = () => {
      const submenuSlot = this.host.renderRoot.querySelector("slot[name='submenu']");
      const menu = submenuSlot == null ? void 0 : submenuSlot.assignedElements({ flatten: true }).filter((el) => el.localName === "sl-menu")[0];
      const isRtl = this.localize.dir() === "rtl";
      if (!menu) {
        return;
      }
      const { left, top, width, height } = menu.getBoundingClientRect();
      this.host.style.setProperty("--safe-triangle-submenu-start-x", `${isRtl ? left + width : left}px`);
      this.host.style.setProperty("--safe-triangle-submenu-start-y", `${top}px`);
      this.host.style.setProperty("--safe-triangle-submenu-end-x", `${isRtl ? left + width : left}px`);
      this.host.style.setProperty("--safe-triangle-submenu-end-y", `${top + height}px`);
    };
    (this.host = host).addController(this);
    this.hasSlotController = hasSlotController;
    this.localize = localize;
  }
  hostConnected() {
    if (this.hasSlotController.test("submenu") && !this.host.disabled) {
      this.addListeners();
    }
  }
  hostDisconnected() {
    this.removeListeners();
  }
  hostUpdated() {
    if (this.hasSlotController.test("submenu") && !this.host.disabled) {
      this.addListeners();
      this.updateSkidding();
    } else {
      this.removeListeners();
    }
  }
  addListeners() {
    if (!this.isConnected) {
      this.host.addEventListener("mousemove", this.handleMouseMove);
      this.host.addEventListener("mouseover", this.handleMouseOver);
      this.host.addEventListener("keydown", this.handleKeyDown);
      this.host.addEventListener("click", this.handleClick);
      this.host.addEventListener("focusout", this.handleFocusOut);
      this.isConnected = true;
    }
    if (!this.isPopupConnected) {
      if (this.popupRef.value) {
        this.popupRef.value.addEventListener("mouseover", this.handlePopupMouseover);
        this.popupRef.value.addEventListener("sl-reposition", this.handlePopupReposition);
        this.isPopupConnected = true;
      }
    }
  }
  removeListeners() {
    if (this.isConnected) {
      this.host.removeEventListener("mousemove", this.handleMouseMove);
      this.host.removeEventListener("mouseover", this.handleMouseOver);
      this.host.removeEventListener("keydown", this.handleKeyDown);
      this.host.removeEventListener("click", this.handleClick);
      this.host.removeEventListener("focusout", this.handleFocusOut);
      this.isConnected = false;
    }
    if (this.isPopupConnected) {
      if (this.popupRef.value) {
        this.popupRef.value.removeEventListener("mouseover", this.handlePopupMouseover);
        this.popupRef.value.removeEventListener("sl-reposition", this.handlePopupReposition);
        this.isPopupConnected = false;
      }
    }
  }
  handleSubmenuEntry(event) {
    const submenuSlot = this.host.renderRoot.querySelector("slot[name='submenu']");
    if (!submenuSlot) {
      console.error("Cannot activate a submenu if no corresponding menuitem can be found.", this);
      return;
    }
    let menuItems = null;
    for (const elt of submenuSlot.assignedElements()) {
      menuItems = elt.querySelectorAll("sl-menu-item, [role^='menuitem']");
      if (menuItems.length !== 0) {
        break;
      }
    }
    if (!menuItems || menuItems.length === 0) {
      return;
    }
    menuItems[0].setAttribute("tabindex", "0");
    for (let i5 = 1; i5 !== menuItems.length; ++i5) {
      menuItems[i5].setAttribute("tabindex", "-1");
    }
    if (this.popupRef.value) {
      event.preventDefault();
      event.stopPropagation();
      if (this.popupRef.value.active) {
        if (menuItems[0] instanceof HTMLElement) {
          menuItems[0].focus();
        }
      } else {
        this.enableSubmenu(false);
        this.host.updateComplete.then(() => {
          if (menuItems[0] instanceof HTMLElement) {
            menuItems[0].focus();
          }
        });
        this.host.requestUpdate();
      }
    }
  }
  setSubmenuState(state6) {
    if (this.popupRef.value) {
      if (this.popupRef.value.active !== state6) {
        this.popupRef.value.active = state6;
        this.host.requestUpdate();
      }
    }
  }
  // Shows the submenu. Supports disabling the opening delay, e.g. for keyboard events that want to set the focus to the
  // newly opened menu.
  enableSubmenu(delay = true) {
    if (delay) {
      window.clearTimeout(this.enableSubmenuTimer);
      this.enableSubmenuTimer = window.setTimeout(() => {
        this.setSubmenuState(true);
      }, this.submenuOpenDelay);
    } else {
      this.setSubmenuState(true);
    }
  }
  disableSubmenu() {
    window.clearTimeout(this.enableSubmenuTimer);
    this.setSubmenuState(false);
  }
  // Calculate the space the top of a menu takes-up, for aligning the popup menu-item with the activating element.
  updateSkidding() {
    var _a24;
    if (!((_a24 = this.host.parentElement) == null ? void 0 : _a24.computedStyleMap)) {
      return;
    }
    const styleMap = this.host.parentElement.computedStyleMap();
    const attrs = ["padding-top", "border-top-width", "margin-top"];
    const skidding = attrs.reduce((accumulator, attr) => {
      var _a25;
      const styleValue = (_a25 = styleMap.get(attr)) != null ? _a25 : new CSSUnitValue(0, "px");
      const unitValue = styleValue instanceof CSSUnitValue ? styleValue : new CSSUnitValue(0, "px");
      const pxValue = unitValue.to("px");
      return accumulator - pxValue.value;
    }, 0);
    this.skidding = skidding;
  }
  isExpanded() {
    return this.popupRef.value ? this.popupRef.value.active : false;
  }
  renderSubmenu() {
    const isLtr = this.localize.dir() === "ltr";
    if (!this.isConnected) {
      return ke` <slot name="submenu" hidden></slot> `;
    }
    return ke`
      <sl-popup
        ${Kt(this.popupRef)}
        placement=${isLtr ? "right-start" : "left-start"}
        anchor="anchor"
        flip
        flip-fallback-strategy="best-fit"
        skidding="${this.skidding}"
        strategy="fixed"
      >
        <slot name="submenu"></slot>
      </sl-popup>
    `;
  }
};

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.CQPYPOEP.js
var SlMenuItem = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.type = "normal";
    this.checked = false;
    this.value = "";
    this.loading = false;
    this.disabled = false;
    this.localize = new LocalizeController2(this);
    this.hasSlotController = new HasSlotController(this, "submenu");
    this.submenuController = new SubmenuController(this, this.hasSlotController, this.localize);
    this.handleHostClick = (event) => {
      if (this.disabled) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
    this.handleMouseOver = (event) => {
      this.focus();
      event.stopPropagation();
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("click", this.handleHostClick);
    this.addEventListener("mouseover", this.handleMouseOver);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener("click", this.handleHostClick);
    this.removeEventListener("mouseover", this.handleMouseOver);
  }
  handleDefaultSlotChange() {
    const textLabel = this.getTextLabel();
    if (typeof this.cachedTextLabel === "undefined") {
      this.cachedTextLabel = textLabel;
      return;
    }
    if (textLabel !== this.cachedTextLabel) {
      this.cachedTextLabel = textLabel;
      this.emit("slotchange", { bubbles: true, composed: false, cancelable: false });
    }
  }
  handleCheckedChange() {
    if (this.checked && this.type !== "checkbox") {
      this.checked = false;
      console.error('The checked attribute can only be used on menu items with type="checkbox"', this);
      return;
    }
    if (this.type === "checkbox") {
      this.setAttribute("aria-checked", this.checked ? "true" : "false");
    } else {
      this.removeAttribute("aria-checked");
    }
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleTypeChange() {
    if (this.type === "checkbox") {
      this.setAttribute("role", "menuitemcheckbox");
      this.setAttribute("aria-checked", this.checked ? "true" : "false");
    } else {
      this.setAttribute("role", "menuitem");
      this.removeAttribute("aria-checked");
    }
  }
  /** Returns a text label based on the contents of the menu item's default slot. */
  getTextLabel() {
    return getTextContent(this.defaultSlot);
  }
  isSubmenu() {
    return this.hasSlotController.test("submenu");
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    const isSubmenuExpanded = this.submenuController.isExpanded();
    return ke`
      <div
        id="anchor"
        part="base"
        class=${Rt({
      "menu-item": true,
      "menu-item--rtl": isRtl,
      "menu-item--checked": this.checked,
      "menu-item--disabled": this.disabled,
      "menu-item--loading": this.loading,
      "menu-item--has-submenu": this.isSubmenu(),
      "menu-item--submenu-expanded": isSubmenuExpanded
    })}
        ?aria-haspopup="${this.isSubmenu()}"
        ?aria-expanded="${isSubmenuExpanded ? true : false}"
      >
        <span part="checked-icon" class="menu-item__check">
          <sl-icon name="check" library="system" aria-hidden="true"></sl-icon>
        </span>

        <slot name="prefix" part="prefix" class="menu-item__prefix"></slot>

        <slot part="label" class="menu-item__label" @slotchange=${this.handleDefaultSlotChange}></slot>

        <slot name="suffix" part="suffix" class="menu-item__suffix"></slot>

        <span part="submenu-icon" class="menu-item__chevron">
          <sl-icon name=${isRtl ? "chevron-left" : "chevron-right"} library="system" aria-hidden="true"></sl-icon>
        </span>

        ${this.submenuController.renderSubmenu()}
        ${this.loading ? ke` <sl-spinner part="spinner" exportparts="base:spinner__base"></sl-spinner> ` : ""}
      </div>
    `;
  }
};
SlMenuItem.styles = [component_styles_default, menu_item_styles_default];
SlMenuItem.dependencies = {
  "sl-icon": SlIcon,
  "sl-popup": SlPopup,
  "sl-spinner": SlSpinner
};
__decorateClass([
  e7("slot:not([name])")
], SlMenuItem.prototype, "defaultSlot", 2);
__decorateClass([
  e7(".menu-item")
], SlMenuItem.prototype, "menuItem", 2);
__decorateClass([
  n6()
], SlMenuItem.prototype, "type", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlMenuItem.prototype, "checked", 2);
__decorateClass([
  n6()
], SlMenuItem.prototype, "value", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlMenuItem.prototype, "loading", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlMenuItem.prototype, "disabled", 2);
__decorateClass([
  watch("checked")
], SlMenuItem.prototype, "handleCheckedChange", 1);
__decorateClass([
  watch("disabled")
], SlMenuItem.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("type")
], SlMenuItem.prototype, "handleTypeChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SDZSSFN3.js
var menu_item_default = SlMenuItem;
SlMenuItem.define("sl-menu-item");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GGT72J62.js
var input_styles_default = i`
  :host {
    display: block;
  }

  .input {
    flex: 1 1 auto;
    display: inline-flex;
    align-items: stretch;
    justify-content: start;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: text;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  /* Standard inputs */
  .input--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .input--standard:hover:not(.input--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }

  .input--standard.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .input--standard.input--focused:not(.input--disabled) .input__control {
    color: var(--sl-input-color-focus);
  }

  .input--standard.input--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input--standard.input--disabled .input__control {
    color: var(--sl-input-color-disabled);
  }

  .input--standard.input--disabled .input__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled inputs */
  .input--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .input--filled:hover:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .input--filled.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .input--filled.input--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    min-width: 0;
    height: 100%;
    color: var(--sl-input-color);
    border: none;
    background: inherit;
    box-shadow: none;
    padding: 0;
    margin: 0;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .input__control::-webkit-search-decoration,
  .input__control::-webkit-search-cancel-button,
  .input__control::-webkit-search-results-button,
  .input__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .input__control:-webkit-autofill,
  .input__control:-webkit-autofill:hover,
  .input__control:-webkit-autofill:focus,
  .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-background-color-hover) inset !important;
    -webkit-text-fill-color: var(--sl-color-primary-500);
    caret-color: var(--sl-input-color);
  }

  .input--filled .input__control:-webkit-autofill,
  .input--filled .input__control:-webkit-autofill:hover,
  .input--filled .input__control:-webkit-autofill:focus,
  .input--filled .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-filled-background-color) inset !important;
  }

  .input__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
    -webkit-user-select: none;
  }

  .input:hover:not(.input--disabled) .input__control {
    color: var(--sl-input-color-hover);
  }

  .input__control:focus {
    outline: none;
  }

  .input__prefix,
  .input__suffix {
    display: inline-flex;
    flex: 0 0 auto;
    align-items: center;
    cursor: default;
  }

  .input__prefix ::slotted(sl-icon),
  .input__suffix ::slotted(sl-icon) {
    color: var(--sl-input-icon-color);
  }

  /*
   * Size modifiers
   */

  .input--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    height: var(--sl-input-height-small);
  }

  .input--small .input__control {
    height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-small);
  }

  .input--small .input__clear,
  .input--small .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-small) * 2);
  }

  .input--small .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .input--small .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .input--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    height: var(--sl-input-height-medium);
  }

  .input--medium .input__control {
    height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-medium);
  }

  .input--medium .input__clear,
  .input--medium .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-medium) * 2);
  }

  .input--medium .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .input--medium .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .input--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    height: var(--sl-input-height-large);
  }

  .input--large .input__control {
    height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-large);
  }

  .input--large .input__clear,
  .input--large .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-large) * 2);
  }

  .input--large .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .input--large .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  /*
   * Pill modifier
   */

  .input--pill.input--small {
    border-radius: var(--sl-input-height-small);
  }

  .input--pill.input--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .input--pill.input--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Clearable + Password Toggle
   */

  .input__clear,
  .input__password-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .input__clear:hover,
  .input__password-toggle:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .input__clear:focus,
  .input__password-toggle:focus {
    outline: none;
  }

  /* Don't show the browser's password toggle in Edge */
  ::-ms-reveal {
    display: none;
  }

  /* Hide the built-in number spinner */
  .input--no-spin-buttons input[type='number']::-webkit-outer-spin-button,
  .input--no-spin-buttons input[type='number']::-webkit-inner-spin-button {
    -webkit-appearance: none;
    display: none;
  }

  .input--no-spin-buttons input[type='number'] {
    -moz-appearance: textfield;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.PSMXIF2T.js
var SlInput = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    });
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.title = "";
    this.__numberInput = Object.assign(document.createElement("input"), { type: "number" });
    this.__dateInput = Object.assign(document.createElement("input"), { type: "date" });
    this.type = "text";
    this.name = "";
    this.value = "";
    this.defaultValue = "";
    this.size = "medium";
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.helpText = "";
    this.clearable = false;
    this.disabled = false;
    this.placeholder = "";
    this.readonly = false;
    this.passwordToggle = false;
    this.passwordVisible = false;
    this.noSpinButtons = false;
    this.form = "";
    this.required = false;
    this.spellcheck = true;
  }
  //
  // NOTE: We use an in-memory input for these getters/setters instead of the one in the template because the properties
  // can be set before the component is rendered.
  //
  /**
   * Gets or sets the current value as a `Date` object. Returns `null` if the value can't be converted. This will use the native `<input type="{{type}}">` implementation and may result in an error.
   */
  get valueAsDate() {
    var _a24;
    this.__dateInput.type = this.type;
    this.__dateInput.value = this.value;
    return ((_a24 = this.input) == null ? void 0 : _a24.valueAsDate) || this.__dateInput.valueAsDate;
  }
  set valueAsDate(newValue) {
    this.__dateInput.type = this.type;
    this.__dateInput.valueAsDate = newValue;
    this.value = this.__dateInput.value;
  }
  /** Gets or sets the current value as a number. Returns `NaN` if the value can't be converted. */
  get valueAsNumber() {
    var _a24;
    this.__numberInput.value = this.value;
    return ((_a24 = this.input) == null ? void 0 : _a24.valueAsNumber) || this.__numberInput.valueAsNumber;
  }
  set valueAsNumber(newValue) {
    this.__numberInput.valueAsNumber = newValue;
    this.value = this.__numberInput.value;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleChange() {
    this.value = this.input.value;
    this.emit("sl-change");
  }
  handleClearClick(event) {
    event.preventDefault();
    if (this.value !== "") {
      this.value = "";
      this.emit("sl-clear");
      this.emit("sl-input");
      this.emit("sl-change");
    }
    this.input.focus();
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleInput() {
    this.value = this.input.value;
    this.formControlController.updateValidity();
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleKeyDown(event) {
    const hasModifier = event.metaKey || event.ctrlKey || event.shiftKey || event.altKey;
    if (event.key === "Enter" && !hasModifier) {
      setTimeout(() => {
        if (!event.defaultPrevented && !event.isComposing) {
          this.formControlController.submit();
        }
      });
    }
  }
  handlePasswordToggle() {
    this.passwordVisible = !this.passwordVisible;
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStepChange() {
    this.input.step = String(this.step);
    this.formControlController.updateValidity();
  }
  async handleValueChange() {
    await this.updateComplete;
    this.formControlController.updateValidity();
  }
  /** Sets focus on the input. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the input. */
  blur() {
    this.input.blur();
  }
  /** Selects all the text in the input. */
  select() {
    this.input.select();
  }
  /** Sets the start and end positions of the text selection (0-based). */
  setSelectionRange(selectionStart, selectionEnd, selectionDirection = "none") {
    this.input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
  }
  /** Replaces a range of text with a new string. */
  setRangeText(replacement, start, end, selectMode = "preserve") {
    const selectionStart = start != null ? start : this.input.selectionStart;
    const selectionEnd = end != null ? end : this.input.selectionEnd;
    this.input.setRangeText(replacement, selectionStart, selectionEnd, selectMode);
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Displays the browser picker for an input element (only works if the browser supports it for the input type). */
  showPicker() {
    if ("showPicker" in HTMLInputElement.prototype) {
      this.input.showPicker();
    }
  }
  /** Increments the value of a numeric input type by the value of the step attribute. */
  stepUp() {
    this.input.stepUp();
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Decrements the value of a numeric input type by the value of the step attribute. */
  stepDown() {
    this.input.stepDown();
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const hasClearIcon = this.clearable && !this.disabled && !this.readonly;
    const isClearIconVisible = hasClearIcon && (typeof this.value === "number" || this.value.length > 0);
    return ke`
      <div
        part="form-control"
        class=${Rt({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${Rt({
      input: true,
      // Sizes
      "input--small": this.size === "small",
      "input--medium": this.size === "medium",
      "input--large": this.size === "large",
      // States
      "input--pill": this.pill,
      "input--standard": !this.filled,
      "input--filled": this.filled,
      "input--disabled": this.disabled,
      "input--focused": this.hasFocus,
      "input--empty": !this.value,
      "input--no-spin-buttons": this.noSpinButtons
    })}
          >
            <span part="prefix" class="input__prefix">
              <slot name="prefix"></slot>
            </span>

            <input
              part="input"
              id="input"
              class="input__control"
              type=${this.type === "password" && this.passwordVisible ? "text" : this.type}
              title=${this.title}
              name=${to(this.name)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${to(this.placeholder)}
              minlength=${to(this.minlength)}
              maxlength=${to(this.maxlength)}
              min=${to(this.min)}
              max=${to(this.max)}
              step=${to(this.step)}
              .value=${Ft(this.value)}
              autocapitalize=${to(this.autocapitalize)}
              autocomplete=${to(this.autocomplete)}
              autocorrect=${to(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${this.spellcheck}
              pattern=${to(this.pattern)}
              enterkeyhint=${to(this.enterkeyhint)}
              inputmode=${to(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @keydown=${this.handleKeyDown}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            />

            ${isClearIconVisible ? ke`
                  <button
                    part="clear-button"
                    class="input__clear"
                    type="button"
                    aria-label=${this.localize.term("clearEntry")}
                    @click=${this.handleClearClick}
                    tabindex="-1"
                  >
                    <slot name="clear-icon">
                      <sl-icon name="x-circle-fill" library="system"></sl-icon>
                    </slot>
                  </button>
                ` : ""}
            ${this.passwordToggle && !this.disabled ? ke`
                  <button
                    part="password-toggle-button"
                    class="input__password-toggle"
                    type="button"
                    aria-label=${this.localize.term(this.passwordVisible ? "hidePassword" : "showPassword")}
                    @click=${this.handlePasswordToggle}
                    tabindex="-1"
                  >
                    ${this.passwordVisible ? ke`
                          <slot name="show-password-icon">
                            <sl-icon name="eye-slash" library="system"></sl-icon>
                          </slot>
                        ` : ke`
                          <slot name="hide-password-icon">
                            <sl-icon name="eye" library="system"></sl-icon>
                          </slot>
                        `}
                  </button>
                ` : ""}

            <span part="suffix" class="input__suffix">
              <slot name="suffix"></slot>
            </span>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlInput.styles = [component_styles_default, form_control_styles_default, input_styles_default];
SlInput.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e7(".input__control")
], SlInput.prototype, "input", 2);
__decorateClass([
  r5()
], SlInput.prototype, "hasFocus", 2);
__decorateClass([
  n6()
], SlInput.prototype, "title", 2);
__decorateClass([
  n6({ reflect: true })
], SlInput.prototype, "type", 2);
__decorateClass([
  n6()
], SlInput.prototype, "name", 2);
__decorateClass([
  n6()
], SlInput.prototype, "value", 2);
__decorateClass([
  defaultValue()
], SlInput.prototype, "defaultValue", 2);
__decorateClass([
  n6({ reflect: true })
], SlInput.prototype, "size", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlInput.prototype, "filled", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlInput.prototype, "pill", 2);
__decorateClass([
  n6()
], SlInput.prototype, "label", 2);
__decorateClass([
  n6({ attribute: "help-text" })
], SlInput.prototype, "helpText", 2);
__decorateClass([
  n6({ type: Boolean })
], SlInput.prototype, "clearable", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlInput.prototype, "disabled", 2);
__decorateClass([
  n6()
], SlInput.prototype, "placeholder", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlInput.prototype, "readonly", 2);
__decorateClass([
  n6({ attribute: "password-toggle", type: Boolean })
], SlInput.prototype, "passwordToggle", 2);
__decorateClass([
  n6({ attribute: "password-visible", type: Boolean })
], SlInput.prototype, "passwordVisible", 2);
__decorateClass([
  n6({ attribute: "no-spin-buttons", type: Boolean })
], SlInput.prototype, "noSpinButtons", 2);
__decorateClass([
  n6({ reflect: true })
], SlInput.prototype, "form", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlInput.prototype, "required", 2);
__decorateClass([
  n6()
], SlInput.prototype, "pattern", 2);
__decorateClass([
  n6({ type: Number })
], SlInput.prototype, "minlength", 2);
__decorateClass([
  n6({ type: Number })
], SlInput.prototype, "maxlength", 2);
__decorateClass([
  n6()
], SlInput.prototype, "min", 2);
__decorateClass([
  n6()
], SlInput.prototype, "max", 2);
__decorateClass([
  n6()
], SlInput.prototype, "step", 2);
__decorateClass([
  n6()
], SlInput.prototype, "autocapitalize", 2);
__decorateClass([
  n6()
], SlInput.prototype, "autocorrect", 2);
__decorateClass([
  n6()
], SlInput.prototype, "autocomplete", 2);
__decorateClass([
  n6({ type: Boolean })
], SlInput.prototype, "autofocus", 2);
__decorateClass([
  n6()
], SlInput.prototype, "enterkeyhint", 2);
__decorateClass([
  n6({
    type: Boolean,
    converter: {
      // Allow "true|false" attribute values but keep the property boolean
      fromAttribute: (value) => !value || value === "false" ? false : true,
      toAttribute: (value) => value ? "true" : "false"
    }
  })
], SlInput.prototype, "spellcheck", 2);
__decorateClass([
  n6()
], SlInput.prototype, "inputmode", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("step", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleStepChange", 1);
__decorateClass([
  watch("value", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleValueChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3MM6BATO.js
var input_default = SlInput;
SlInput.define("sl-input");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.VVA35HTY.js
var menu_styles_default = i`
  :host {
    display: block;
    position: relative;
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding: var(--sl-spacing-x-small) 0;
    overflow: auto;
    overscroll-behavior: none;
  }

  ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.F2NECMQL.js
var SlMenu = class extends ShoelaceElement {
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "menu");
  }
  handleClick(event) {
    const menuItemTypes = ["menuitem", "menuitemcheckbox"];
    const target = event.composedPath().find((el) => {
      var _a24;
      return menuItemTypes.includes(((_a24 = el == null ? void 0 : el.getAttribute) == null ? void 0 : _a24.call(el, "role")) || "");
    });
    if (!target)
      return;
    const item = target;
    if (item.type === "checkbox") {
      item.checked = !item.checked;
    }
    this.emit("sl-select", { detail: { item } });
  }
  handleKeyDown(event) {
    if (event.key === "Enter" || event.key === " ") {
      const item = this.getCurrentItem();
      event.preventDefault();
      event.stopPropagation();
      item == null ? void 0 : item.click();
    } else if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event.key)) {
      const items = this.getAllItems();
      const activeItem = this.getCurrentItem();
      let index = activeItem ? items.indexOf(activeItem) : 0;
      if (items.length > 0) {
        event.preventDefault();
        event.stopPropagation();
        if (event.key === "ArrowDown") {
          index++;
        } else if (event.key === "ArrowUp") {
          index--;
        } else if (event.key === "Home") {
          index = 0;
        } else if (event.key === "End") {
          index = items.length - 1;
        }
        if (index < 0) {
          index = items.length - 1;
        }
        if (index > items.length - 1) {
          index = 0;
        }
        this.setCurrentItem(items[index]);
        items[index].focus();
      }
    }
  }
  handleMouseDown(event) {
    const target = event.target;
    if (this.isMenuItem(target)) {
      this.setCurrentItem(target);
    }
  }
  handleSlotChange() {
    const items = this.getAllItems();
    if (items.length > 0) {
      this.setCurrentItem(items[0]);
    }
  }
  isMenuItem(item) {
    var _a24;
    return item.tagName.toLowerCase() === "sl-menu-item" || ["menuitem", "menuitemcheckbox", "menuitemradio"].includes((_a24 = item.getAttribute("role")) != null ? _a24 : "");
  }
  /** @internal Gets all slotted menu items, ignoring dividers, headers, and other elements. */
  getAllItems() {
    return [...this.defaultSlot.assignedElements({ flatten: true })].filter((el) => {
      if (el.inert || !this.isMenuItem(el)) {
        return false;
      }
      return true;
    });
  }
  /**
   * @internal Gets the current menu item, which is the menu item that has `tabindex="0"` within the roving tab index.
   * The menu item may or may not have focus, but for keyboard interaction purposes it's considered the "active" item.
   */
  getCurrentItem() {
    return this.getAllItems().find((i5) => i5.getAttribute("tabindex") === "0");
  }
  /**
   * @internal Sets the current menu item to the specified element. This sets `tabindex="0"` on the target element and
   * `tabindex="-1"` to all other items. This method must be called prior to setting focus on a menu item.
   */
  setCurrentItem(item) {
    const items = this.getAllItems();
    items.forEach((i5) => {
      i5.setAttribute("tabindex", i5 === item ? "0" : "-1");
    });
  }
  render() {
    return ke`
      <slot
        @slotchange=${this.handleSlotChange}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleMouseDown}
      ></slot>
    `;
  }
};
SlMenu.styles = [component_styles_default, menu_styles_default];
__decorateClass([
  e7("slot")
], SlMenu.prototype, "defaultSlot", 2);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.RPIO5J3V.js
var menu_default = SlMenu;
SlMenu.define("sl-menu");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ORTZCIID.js
var menu_label_styles_default = i`
  :host {
    display: block;
  }

  .menu-label {
    display: inline-block;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-500);
    padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-large);
    user-select: none;
    -webkit-user-select: none;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.APNS3BEQ.js
var SlMenuLabel = class extends ShoelaceElement {
  render() {
    return ke` <slot part="base" class="menu-label"></slot> `;
  }
};
SlMenuLabel.styles = [component_styles_default, menu_label_styles_default];

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2OK5PRR2.js
var menu_label_default = SlMenuLabel;
SlMenuLabel.define("sl-menu-label");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.FY7IKLNL.js
var include_styles_default = i`
  :host {
    display: block;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.XNEONNEJ.js
var includeFiles = /* @__PURE__ */ new Map();
function requestInclude(src, mode = "cors") {
  const prev = includeFiles.get(src);
  if (prev !== void 0) {
    return Promise.resolve(prev);
  }
  const fileDataPromise = fetch(src, { mode }).then(async (response) => {
    const res = {
      ok: response.ok,
      status: response.status,
      html: await response.text()
    };
    includeFiles.set(src, res);
    return res;
  });
  includeFiles.set(src, fileDataPromise);
  return fileDataPromise;
}

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.CX2PXEGI.js
var SlInclude = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.mode = "cors";
    this.allowScripts = false;
  }
  executeScript(script) {
    const newScript = document.createElement("script");
    [...script.attributes].forEach((attr) => newScript.setAttribute(attr.name, attr.value));
    newScript.textContent = script.textContent;
    script.parentNode.replaceChild(newScript, script);
  }
  async handleSrcChange() {
    try {
      const src = this.src;
      const file = await requestInclude(src, this.mode);
      if (src !== this.src) {
        return;
      }
      if (!file.ok) {
        this.emit("sl-error", { detail: { status: file.status } });
        return;
      }
      this.innerHTML = file.html;
      if (this.allowScripts) {
        [...this.querySelectorAll("script")].forEach((script) => this.executeScript(script));
      }
      this.emit("sl-load");
    } catch (e10) {
      this.emit("sl-error", { detail: { status: -1 } });
    }
  }
  render() {
    return ke`<slot></slot>`;
  }
};
SlInclude.styles = [component_styles_default, include_styles_default];
__decorateClass([
  n6()
], SlInclude.prototype, "src", 2);
__decorateClass([
  n6()
], SlInclude.prototype, "mode", 2);
__decorateClass([
  n6({ attribute: "allow-scripts", type: Boolean })
], SlInclude.prototype, "allowScripts", 2);
__decorateClass([
  watch("src")
], SlInclude.prototype, "handleSrcChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ZUPX6PYK.js
SlInclude.define("sl-include");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.RCGFCKTU.js
var image_comparer_styles_default = i`
  :host {
    --divider-width: 2px;
    --handle-size: 2.5rem;

    display: inline-block;
    position: relative;
  }

  .image-comparer {
    max-width: 100%;
    max-height: 100%;
    overflow: hidden;
  }

  .image-comparer__before,
  .image-comparer__after {
    display: block;
    pointer-events: none;
  }

  .image-comparer__before::slotted(img),
  .image-comparer__after::slotted(img),
  .image-comparer__before::slotted(svg),
  .image-comparer__after::slotted(svg) {
    display: block;
    max-width: 100% !important;
    height: auto;
  }

  .image-comparer__after {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
  }

  .image-comparer__divider {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    width: var(--divider-width);
    height: 100%;
    background-color: var(--sl-color-neutral-0);
    translate: calc(var(--divider-width) / -2);
    cursor: ew-resize;
  }

  .image-comparer__handle {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: calc(50% - (var(--handle-size) / 2));
    width: var(--handle-size);
    height: var(--handle-size);
    background-color: var(--sl-color-neutral-0);
    border-radius: var(--sl-border-radius-circle);
    font-size: calc(var(--handle-size) * 0.5);
    color: var(--sl-color-neutral-700);
    cursor: inherit;
    z-index: 10;
  }

  .image-comparer__handle:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.FQKUK5KT.js
var SlImageComparer = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.position = 50;
  }
  handleDrag(event) {
    const { width } = this.base.getBoundingClientRect();
    const isRtl = this.localize.dir() === "rtl";
    event.preventDefault();
    drag(this.base, {
      onMove: (x4) => {
        this.position = parseFloat(clamp2(x4 / width * 100, 0, 100).toFixed(2));
        if (isRtl)
          this.position = 100 - this.position;
      },
      initialEvent: event
    });
  }
  handleKeyDown(event) {
    const isLtr = this.localize.dir() === "ltr";
    const isRtl = this.localize.dir() === "rtl";
    if (["ArrowLeft", "ArrowRight", "Home", "End"].includes(event.key)) {
      const incr = event.shiftKey ? 10 : 1;
      let newPosition = this.position;
      event.preventDefault();
      if (isLtr && event.key === "ArrowLeft" || isRtl && event.key === "ArrowRight") {
        newPosition -= incr;
      }
      if (isLtr && event.key === "ArrowRight" || isRtl && event.key === "ArrowLeft") {
        newPosition += incr;
      }
      if (event.key === "Home") {
        newPosition = 0;
      }
      if (event.key === "End") {
        newPosition = 100;
      }
      newPosition = clamp2(newPosition, 0, 100);
      this.position = newPosition;
    }
  }
  handlePositionChange() {
    this.emit("sl-change");
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    return ke`
      <div
        part="base"
        id="image-comparer"
        class=${Rt({
      "image-comparer": true,
      "image-comparer--rtl": isRtl
    })}
        @keydown=${this.handleKeyDown}
      >
        <div class="image-comparer__image">
          <div part="before" class="image-comparer__before">
            <slot name="before"></slot>
          </div>

          <div
            part="after"
            class="image-comparer__after"
            style=${se({
      clipPath: isRtl ? `inset(0 0 0 ${100 - this.position}%)` : `inset(0 ${100 - this.position}% 0 0)`
    })}
          >
            <slot name="after"></slot>
          </div>
        </div>

        <div
          part="divider"
          class="image-comparer__divider"
          style=${se({
      left: isRtl ? `${100 - this.position}%` : `${this.position}%`
    })}
          @mousedown=${this.handleDrag}
          @touchstart=${this.handleDrag}
        >
          <div
            part="handle"
            class="image-comparer__handle"
            role="scrollbar"
            aria-valuenow=${this.position}
            aria-valuemin="0"
            aria-valuemax="100"
            aria-controls="image-comparer"
            tabindex="0"
          >
            <slot name="handle">
              <sl-icon library="system" name="grip-vertical"></sl-icon>
            </slot>
          </div>
        </div>
      </div>
    `;
  }
};
SlImageComparer.styles = [component_styles_default, image_comparer_styles_default];
SlImageComparer.scopedElement = { "sl-icon": SlIcon };
__decorateClass([
  e7(".image-comparer")
], SlImageComparer.prototype, "base", 2);
__decorateClass([
  e7(".image-comparer__handle")
], SlImageComparer.prototype, "handle", 2);
__decorateClass([
  n6({ type: Number, reflect: true })
], SlImageComparer.prototype, "position", 2);
__decorateClass([
  watch("position", { waitUntilFirstUpdate: true })
], SlImageComparer.prototype, "handlePositionChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SWQHKKEH.js
SlImageComparer.define("sl-image-comparer");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.22M42QYS.js
var icon_default = SlIcon;
SlIcon.define("sl-icon");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.VFX5UTJA.js
var icon_button_default = SlIconButton;
SlIconButton.define("sl-icon-button");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.DPTPJGPJ.js
var SlFormatBytes = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.value = 0;
    this.unit = "byte";
    this.display = "short";
  }
  render() {
    if (isNaN(this.value)) {
      return "";
    }
    const bitPrefixes = ["", "kilo", "mega", "giga", "tera"];
    const bytePrefixes = ["", "kilo", "mega", "giga", "tera", "peta"];
    const prefix = this.unit === "bit" ? bitPrefixes : bytePrefixes;
    const index = Math.max(0, Math.min(Math.floor(Math.log10(this.value) / 3), prefix.length - 1));
    const unit = prefix[index] + this.unit;
    const valueToFormat = parseFloat((this.value / Math.pow(1e3, index)).toPrecision(3));
    return this.localize.number(valueToFormat, {
      style: "unit",
      unit,
      unitDisplay: this.display
    });
  }
};
__decorateClass([
  n6({ type: Number })
], SlFormatBytes.prototype, "value", 2);
__decorateClass([
  n6()
], SlFormatBytes.prototype, "unit", 2);
__decorateClass([
  n6()
], SlFormatBytes.prototype, "display", 2);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.DOGX3IXE.js
SlFormatBytes.define("sl-format-bytes");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.BIUZLYP7.js
var SlFormatDate = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.date = /* @__PURE__ */ new Date();
    this.hourFormat = "auto";
  }
  render() {
    const date = new Date(this.date);
    const hour12 = this.hourFormat === "auto" ? void 0 : this.hourFormat === "12";
    if (isNaN(date.getMilliseconds())) {
      return void 0;
    }
    return ke`
      <time datetime=${date.toISOString()}>
        ${this.localize.date(date, {
      weekday: this.weekday,
      era: this.era,
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second,
      timeZoneName: this.timeZoneName,
      timeZone: this.timeZone,
      hour12
    })}
      </time>
    `;
  }
};
__decorateClass([
  n6()
], SlFormatDate.prototype, "date", 2);
__decorateClass([
  n6()
], SlFormatDate.prototype, "weekday", 2);
__decorateClass([
  n6()
], SlFormatDate.prototype, "era", 2);
__decorateClass([
  n6()
], SlFormatDate.prototype, "year", 2);
__decorateClass([
  n6()
], SlFormatDate.prototype, "month", 2);
__decorateClass([
  n6()
], SlFormatDate.prototype, "day", 2);
__decorateClass([
  n6()
], SlFormatDate.prototype, "hour", 2);
__decorateClass([
  n6()
], SlFormatDate.prototype, "minute", 2);
__decorateClass([
  n6()
], SlFormatDate.prototype, "second", 2);
__decorateClass([
  n6({ attribute: "time-zone-name" })
], SlFormatDate.prototype, "timeZoneName", 2);
__decorateClass([
  n6({ attribute: "time-zone" })
], SlFormatDate.prototype, "timeZone", 2);
__decorateClass([
  n6({ attribute: "hour-format" })
], SlFormatDate.prototype, "hourFormat", 2);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TMVK4IAN.js
SlFormatDate.define("sl-format-date");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.BUXG6X3I.js
var SlFormatNumber = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.value = 0;
    this.type = "decimal";
    this.noGrouping = false;
    this.currency = "USD";
    this.currencyDisplay = "symbol";
  }
  render() {
    if (isNaN(this.value)) {
      return "";
    }
    return this.localize.number(this.value, {
      style: this.type,
      currency: this.currency,
      currencyDisplay: this.currencyDisplay,
      useGrouping: !this.noGrouping,
      minimumIntegerDigits: this.minimumIntegerDigits,
      minimumFractionDigits: this.minimumFractionDigits,
      maximumFractionDigits: this.maximumFractionDigits,
      minimumSignificantDigits: this.minimumSignificantDigits,
      maximumSignificantDigits: this.maximumSignificantDigits
    });
  }
};
__decorateClass([
  n6({ type: Number })
], SlFormatNumber.prototype, "value", 2);
__decorateClass([
  n6()
], SlFormatNumber.prototype, "type", 2);
__decorateClass([
  n6({ attribute: "no-grouping", type: Boolean })
], SlFormatNumber.prototype, "noGrouping", 2);
__decorateClass([
  n6()
], SlFormatNumber.prototype, "currency", 2);
__decorateClass([
  n6({ attribute: "currency-display" })
], SlFormatNumber.prototype, "currencyDisplay", 2);
__decorateClass([
  n6({ attribute: "minimum-integer-digits", type: Number })
], SlFormatNumber.prototype, "minimumIntegerDigits", 2);
__decorateClass([
  n6({ attribute: "minimum-fraction-digits", type: Number })
], SlFormatNumber.prototype, "minimumFractionDigits", 2);
__decorateClass([
  n6({ attribute: "maximum-fraction-digits", type: Number })
], SlFormatNumber.prototype, "maximumFractionDigits", 2);
__decorateClass([
  n6({ attribute: "minimum-significant-digits", type: Number })
], SlFormatNumber.prototype, "minimumSignificantDigits", 2);
__decorateClass([
  n6({ attribute: "maximum-significant-digits", type: Number })
], SlFormatNumber.prototype, "maximumSignificantDigits", 2);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7EOXTNR2.js
SlFormatNumber.define("sl-format-number");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SUSCR7CI.js
var divider_styles_default = i`
  :host {
    --color: var(--sl-panel-border-color);
    --width: var(--sl-panel-border-width);
    --spacing: var(--sl-spacing-medium);
  }

  :host(:not([vertical])) {
    display: block;
    border-top: solid var(--width) var(--color);
    margin: var(--spacing) 0;
  }

  :host([vertical]) {
    display: inline-block;
    height: 100%;
    border-left: solid var(--width) var(--color);
    margin: 0 var(--spacing);
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.5FAOWXFW.js
var SlDivider = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.vertical = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "separator");
  }
  handleVerticalChange() {
    this.setAttribute("aria-orientation", this.vertical ? "vertical" : "horizontal");
  }
};
SlDivider.styles = [component_styles_default, divider_styles_default];
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlDivider.prototype, "vertical", 2);
__decorateClass([
  watch("vertical")
], SlDivider.prototype, "handleVerticalChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.XCI26NND.js
var divider_default = SlDivider;
SlDivider.define("sl-divider");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.BRQKZQRB.js
var drawer_styles_default = i`
  :host {
    --size: 25rem;
    --header-spacing: var(--sl-spacing-large);
    --body-spacing: var(--sl-spacing-large);
    --footer-spacing: var(--sl-spacing-large);

    display: contents;
  }

  .drawer {
    top: 0;
    inset-inline-start: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: hidden;
  }

  .drawer--contained {
    position: absolute;
    z-index: initial;
  }

  .drawer--fixed {
    position: fixed;
    z-index: var(--sl-z-index-drawer);
  }

  .drawer__panel {
    position: absolute;
    display: flex;
    flex-direction: column;
    z-index: 2;
    max-width: 100%;
    max-height: 100%;
    background-color: var(--sl-panel-background-color);
    box-shadow: var(--sl-shadow-x-large);
    overflow: auto;
    pointer-events: all;
  }

  .drawer__panel:focus {
    outline: none;
  }

  .drawer--top .drawer__panel {
    top: 0;
    inset-inline-end: auto;
    bottom: auto;
    inset-inline-start: 0;
    width: 100%;
    height: var(--size);
  }

  .drawer--end .drawer__panel {
    top: 0;
    inset-inline-end: 0;
    bottom: auto;
    inset-inline-start: auto;
    width: var(--size);
    height: 100%;
  }

  .drawer--bottom .drawer__panel {
    top: auto;
    inset-inline-end: auto;
    bottom: 0;
    inset-inline-start: 0;
    width: 100%;
    height: var(--size);
  }

  .drawer--start .drawer__panel {
    top: 0;
    inset-inline-end: auto;
    bottom: auto;
    inset-inline-start: 0;
    width: var(--size);
    height: 100%;
  }

  .drawer__header {
    display: flex;
  }

  .drawer__title {
    flex: 1 1 auto;
    font: inherit;
    font-size: var(--sl-font-size-large);
    line-height: var(--sl-line-height-dense);
    padding: var(--header-spacing);
    margin: 0;
  }

  .drawer__header-actions {
    flex-shrink: 0;
    display: flex;
    flex-wrap: wrap;
    justify-content: end;
    gap: var(--sl-spacing-2x-small);
    padding: 0 var(--header-spacing);
  }

  .drawer__header-actions sl-icon-button,
  .drawer__header-actions ::slotted(sl-icon-button) {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-medium);
  }

  .drawer__body {
    flex: 1 1 auto;
    display: block;
    padding: var(--body-spacing);
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  .drawer__footer {
    text-align: right;
    padding: var(--footer-spacing);
  }

  .drawer__footer ::slotted(sl-button:not(:last-of-type)) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .drawer:not(.drawer--has-footer) .drawer__footer {
    display: none;
  }

  .drawer__overlay {
    display: block;
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: var(--sl-overlay-background-color);
    pointer-events: all;
  }

  .drawer--contained .drawer__overlay {
    display: none;
  }

  @media (forced-colors: active) {
    .drawer__panel {
      border: solid 1px var(--sl-color-neutral-0);
    }
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LXDTFLWU.js
var computedStyleMap = /* @__PURE__ */ new WeakMap();
function getCachedComputedStyle(el) {
  let computedStyle = computedStyleMap.get(el);
  if (!computedStyle) {
    computedStyle = window.getComputedStyle(el, null);
    computedStyleMap.set(el, computedStyle);
  }
  return computedStyle;
}
function isVisible(el) {
  if (typeof el.checkVisibility === "function") {
    return el.checkVisibility({ checkOpacity: false, checkVisibilityCSS: true });
  }
  const computedStyle = getCachedComputedStyle(el);
  return computedStyle.visibility !== "hidden" && computedStyle.display !== "none";
}
function isOverflowingAndTabbable(el) {
  const computedStyle = getCachedComputedStyle(el);
  const { overflowY, overflowX } = computedStyle;
  if (overflowY === "scroll" || overflowX === "scroll") {
    return true;
  }
  if (overflowY !== "auto" || overflowX !== "auto") {
    return false;
  }
  const isOverflowingY = el.scrollHeight > el.clientHeight;
  if (isOverflowingY && overflowY === "auto") {
    return true;
  }
  const isOverflowingX = el.scrollWidth > el.clientWidth;
  if (isOverflowingX && overflowX === "auto") {
    return true;
  }
  return false;
}
function isTabbable(el) {
  const tag = el.tagName.toLowerCase();
  const tabindex = Number(el.getAttribute("tabindex"));
  const hasTabindex = el.hasAttribute("tabindex");
  if (hasTabindex && (isNaN(tabindex) || tabindex <= -1)) {
    return false;
  }
  if (el.hasAttribute("disabled")) {
    return false;
  }
  if (el.closest("[inert]")) {
    return false;
  }
  if (tag === "input" && el.getAttribute("type") === "radio" && !el.hasAttribute("checked")) {
    return false;
  }
  if (!isVisible(el)) {
    return false;
  }
  if ((tag === "audio" || tag === "video") && el.hasAttribute("controls")) {
    return true;
  }
  if (el.hasAttribute("tabindex")) {
    return true;
  }
  if (el.hasAttribute("contenteditable") && el.getAttribute("contenteditable") !== "false") {
    return true;
  }
  const isNativelyTabbable = [
    "button",
    "input",
    "select",
    "textarea",
    "a",
    "audio",
    "video",
    "summary",
    "iframe"
  ].includes(tag);
  if (isNativelyTabbable) {
    return true;
  }
  return isOverflowingAndTabbable(el);
}
function getTabbableBoundary(root) {
  var _a24, _b;
  const tabbableElements = getTabbableElements(root);
  const start = (_a24 = tabbableElements[0]) != null ? _a24 : null;
  const end = (_b = tabbableElements[tabbableElements.length - 1]) != null ? _b : null;
  return { start, end };
}
function getSlottedChildrenOutsideRootElement(slotElement, root) {
  var _a24;
  return ((_a24 = slotElement.getRootNode({ composed: true })) == null ? void 0 : _a24.host) !== root;
}
function getTabbableElements(root) {
  const walkedEls = /* @__PURE__ */ new WeakMap();
  const tabbableElements = [];
  function walk(el) {
    if (el instanceof Element) {
      if (el.hasAttribute("inert") || el.closest("[inert]")) {
        return;
      }
      if (walkedEls.has(el)) {
        return;
      }
      walkedEls.set(el, true);
      if (!tabbableElements.includes(el) && isTabbable(el)) {
        tabbableElements.push(el);
      }
      if (el instanceof HTMLSlotElement && getSlottedChildrenOutsideRootElement(el, root)) {
        el.assignedElements({ flatten: true }).forEach((assignedEl) => {
          walk(assignedEl);
        });
      }
      if (el.shadowRoot !== null && el.shadowRoot.mode === "open") {
        walk(el.shadowRoot);
      }
    }
    for (const e10 of el.children) {
      walk(e10);
    }
  }
  walk(root);
  return tabbableElements.sort((a3, b3) => {
    const aTabindex = Number(a3.getAttribute("tabindex")) || 0;
    const bTabindex = Number(b3.getAttribute("tabindex")) || 0;
    return bTabindex - aTabindex;
  });
}

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ODFLWOL6.js
function* activeElements(activeElement = document.activeElement) {
  if (activeElement === null || activeElement === void 0)
    return;
  yield activeElement;
  if ("shadowRoot" in activeElement && activeElement.shadowRoot && activeElement.shadowRoot.mode !== "closed") {
    yield* __yieldStar(activeElements(activeElement.shadowRoot.activeElement));
  }
}
function getDeepestActiveElement() {
  return [...activeElements()].pop();
}
var activeModals = [];
var Modal = class {
  constructor(element) {
    this.tabDirection = "forward";
    this.handleFocusIn = () => {
      if (!this.isActive())
        return;
      this.checkFocus();
    };
    this.handleKeyDown = (event) => {
      var _a24;
      if (event.key !== "Tab" || this.isExternalActivated)
        return;
      if (!this.isActive())
        return;
      const currentActiveElement = getDeepestActiveElement();
      this.previousFocus = currentActiveElement;
      if (this.previousFocus && this.possiblyHasTabbableChildren(this.previousFocus)) {
        return;
      }
      if (event.shiftKey) {
        this.tabDirection = "backward";
      } else {
        this.tabDirection = "forward";
      }
      const tabbableElements = getTabbableElements(this.element);
      let currentFocusIndex = tabbableElements.findIndex((el) => el === currentActiveElement);
      this.previousFocus = this.currentFocus;
      const addition = this.tabDirection === "forward" ? 1 : -1;
      while (true) {
        if (currentFocusIndex + addition >= tabbableElements.length) {
          currentFocusIndex = 0;
        } else if (currentFocusIndex + addition < 0) {
          currentFocusIndex = tabbableElements.length - 1;
        } else {
          currentFocusIndex += addition;
        }
        this.previousFocus = this.currentFocus;
        const nextFocus = (
          /** @type {HTMLElement} */
          tabbableElements[currentFocusIndex]
        );
        if (this.tabDirection === "backward") {
          if (this.previousFocus && this.possiblyHasTabbableChildren(this.previousFocus)) {
            return;
          }
        }
        if (nextFocus && this.possiblyHasTabbableChildren(nextFocus)) {
          return;
        }
        event.preventDefault();
        this.currentFocus = nextFocus;
        (_a24 = this.currentFocus) == null ? void 0 : _a24.focus({ preventScroll: false });
        const allActiveElements = [...activeElements()];
        if (allActiveElements.includes(this.currentFocus) || !allActiveElements.includes(this.previousFocus)) {
          break;
        }
      }
      setTimeout(() => this.checkFocus());
    };
    this.handleKeyUp = () => {
      this.tabDirection = "forward";
    };
    this.element = element;
    this.elementsWithTabbableControls = ["iframe"];
  }
  /** Activates focus trapping. */
  activate() {
    activeModals.push(this.element);
    document.addEventListener("focusin", this.handleFocusIn);
    document.addEventListener("keydown", this.handleKeyDown);
    document.addEventListener("keyup", this.handleKeyUp);
  }
  /** Deactivates focus trapping. */
  deactivate() {
    activeModals = activeModals.filter((modal) => modal !== this.element);
    this.currentFocus = null;
    document.removeEventListener("focusin", this.handleFocusIn);
    document.removeEventListener("keydown", this.handleKeyDown);
    document.removeEventListener("keyup", this.handleKeyUp);
  }
  /** Determines if this modal element is currently active or not. */
  isActive() {
    return activeModals[activeModals.length - 1] === this.element;
  }
  /** Activates external modal behavior and temporarily disables focus trapping. */
  activateExternal() {
    this.isExternalActivated = true;
  }
  /** Deactivates external modal behavior and re-enables focus trapping. */
  deactivateExternal() {
    this.isExternalActivated = false;
  }
  checkFocus() {
    if (this.isActive() && !this.isExternalActivated) {
      const tabbableElements = getTabbableElements(this.element);
      if (!this.element.matches(":focus-within")) {
        const start = tabbableElements[0];
        const end = tabbableElements[tabbableElements.length - 1];
        const target = this.tabDirection === "forward" ? start : end;
        if (typeof (target == null ? void 0 : target.focus) === "function") {
          this.currentFocus = target;
          target.focus({ preventScroll: false });
        }
      }
    }
  }
  possiblyHasTabbableChildren(element) {
    return this.elementsWithTabbableControls.includes(element.tagName.toLowerCase()) || element.hasAttribute("controls");
  }
};

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GWXFL5AT.js
function uppercaseFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
var SlDrawer = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "footer");
    this.localize = new LocalizeController2(this);
    this.modal = new Modal(this);
    this.open = false;
    this.label = "";
    this.placement = "end";
    this.contained = false;
    this.noHeader = false;
    this.handleDocumentKeyDown = (event) => {
      if (this.contained) {
        return;
      }
      if (event.key === "Escape" && this.modal.isActive() && this.open) {
        event.stopImmediatePropagation();
        this.requestClose("keyboard");
      }
    };
  }
  firstUpdated() {
    this.drawer.hidden = !this.open;
    if (this.open) {
      this.addOpenListeners();
      if (!this.contained) {
        this.modal.activate();
        lockBodyScrolling(this);
      }
    }
  }
  disconnectedCallback() {
    var _a24;
    super.disconnectedCallback();
    unlockBodyScrolling(this);
    (_a24 = this.closeWatcher) == null ? void 0 : _a24.destroy();
  }
  requestClose(source) {
    const slRequestClose = this.emit("sl-request-close", {
      cancelable: true,
      detail: { source }
    });
    if (slRequestClose.defaultPrevented) {
      const animation = getAnimation(this, "drawer.denyClose", { dir: this.localize.dir() });
      animateTo(this.panel, animation.keyframes, animation.options);
      return;
    }
    this.hide();
  }
  addOpenListeners() {
    var _a24;
    if ("CloseWatcher" in window) {
      (_a24 = this.closeWatcher) == null ? void 0 : _a24.destroy();
      if (!this.contained) {
        this.closeWatcher = new CloseWatcher();
        this.closeWatcher.onclose = () => this.requestClose("keyboard");
      }
    } else {
      document.addEventListener("keydown", this.handleDocumentKeyDown);
    }
  }
  removeOpenListeners() {
    var _a24;
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
    (_a24 = this.closeWatcher) == null ? void 0 : _a24.destroy();
  }
  async handleOpenChange() {
    if (this.open) {
      this.emit("sl-show");
      this.addOpenListeners();
      this.originalTrigger = document.activeElement;
      if (!this.contained) {
        this.modal.activate();
        lockBodyScrolling(this);
      }
      const autoFocusTarget = this.querySelector("[autofocus]");
      if (autoFocusTarget) {
        autoFocusTarget.removeAttribute("autofocus");
      }
      await Promise.all([stopAnimations(this.drawer), stopAnimations(this.overlay)]);
      this.drawer.hidden = false;
      requestAnimationFrame(() => {
        const slInitialFocus = this.emit("sl-initial-focus", { cancelable: true });
        if (!slInitialFocus.defaultPrevented) {
          if (autoFocusTarget) {
            autoFocusTarget.focus({ preventScroll: true });
          } else {
            this.panel.focus({ preventScroll: true });
          }
        }
        if (autoFocusTarget) {
          autoFocusTarget.setAttribute("autofocus", "");
        }
      });
      const panelAnimation = getAnimation(this, `drawer.show${uppercaseFirstLetter(this.placement)}`, {
        dir: this.localize.dir()
      });
      const overlayAnimation = getAnimation(this, "drawer.overlay.show", { dir: this.localize.dir() });
      await Promise.all([
        animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options),
        animateTo(this.overlay, overlayAnimation.keyframes, overlayAnimation.options)
      ]);
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      if (!this.contained) {
        this.modal.deactivate();
        unlockBodyScrolling(this);
      }
      await Promise.all([stopAnimations(this.drawer), stopAnimations(this.overlay)]);
      const panelAnimation = getAnimation(this, `drawer.hide${uppercaseFirstLetter(this.placement)}`, {
        dir: this.localize.dir()
      });
      const overlayAnimation = getAnimation(this, "drawer.overlay.hide", { dir: this.localize.dir() });
      await Promise.all([
        animateTo(this.overlay, overlayAnimation.keyframes, overlayAnimation.options).then(() => {
          this.overlay.hidden = true;
        }),
        animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options).then(() => {
          this.panel.hidden = true;
        })
      ]);
      this.drawer.hidden = true;
      this.overlay.hidden = false;
      this.panel.hidden = false;
      const trigger = this.originalTrigger;
      if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
        setTimeout(() => trigger.focus());
      }
      this.emit("sl-after-hide");
    }
  }
  handleNoModalChange() {
    if (this.open && !this.contained) {
      this.modal.activate();
      lockBodyScrolling(this);
    }
    if (this.open && this.contained) {
      this.modal.deactivate();
      unlockBodyScrolling(this);
    }
  }
  /** Shows the drawer. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the drawer */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  render() {
    return ke`
      <div
        part="base"
        class=${Rt({
      drawer: true,
      "drawer--open": this.open,
      "drawer--top": this.placement === "top",
      "drawer--end": this.placement === "end",
      "drawer--bottom": this.placement === "bottom",
      "drawer--start": this.placement === "start",
      "drawer--contained": this.contained,
      "drawer--fixed": !this.contained,
      "drawer--rtl": this.localize.dir() === "rtl",
      "drawer--has-footer": this.hasSlotController.test("footer")
    })}
      >
        <div part="overlay" class="drawer__overlay" @click=${() => this.requestClose("overlay")} tabindex="-1"></div>

        <div
          part="panel"
          class="drawer__panel"
          role="dialog"
          aria-modal="true"
          aria-hidden=${this.open ? "false" : "true"}
          aria-label=${to(this.noHeader ? this.label : void 0)}
          aria-labelledby=${to(!this.noHeader ? "title" : void 0)}
          tabindex="0"
        >
          ${!this.noHeader ? ke`
                <header part="header" class="drawer__header">
                  <h2 part="title" class="drawer__title" id="title">
                    <!-- If there's no label, use an invisible character to prevent the header from collapsing -->
                    <slot name="label"> ${this.label.length > 0 ? this.label : String.fromCharCode(65279)} </slot>
                  </h2>
                  <div part="header-actions" class="drawer__header-actions">
                    <slot name="header-actions"></slot>
                    <sl-icon-button
                      part="close-button"
                      exportparts="base:close-button__base"
                      class="drawer__close"
                      name="x-lg"
                      label=${this.localize.term("close")}
                      library="system"
                      @click=${() => this.requestClose("close-button")}
                    ></sl-icon-button>
                  </div>
                </header>
              ` : ""}

          <slot part="body" class="drawer__body"></slot>

          <footer part="footer" class="drawer__footer">
            <slot name="footer"></slot>
          </footer>
        </div>
      </div>
    `;
  }
};
SlDrawer.styles = [component_styles_default, drawer_styles_default];
SlDrawer.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass([
  e7(".drawer")
], SlDrawer.prototype, "drawer", 2);
__decorateClass([
  e7(".drawer__panel")
], SlDrawer.prototype, "panel", 2);
__decorateClass([
  e7(".drawer__overlay")
], SlDrawer.prototype, "overlay", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlDrawer.prototype, "open", 2);
__decorateClass([
  n6({ reflect: true })
], SlDrawer.prototype, "label", 2);
__decorateClass([
  n6({ reflect: true })
], SlDrawer.prototype, "placement", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlDrawer.prototype, "contained", 2);
__decorateClass([
  n6({ attribute: "no-header", type: Boolean, reflect: true })
], SlDrawer.prototype, "noHeader", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: true })
], SlDrawer.prototype, "handleOpenChange", 1);
__decorateClass([
  watch("contained", { waitUntilFirstUpdate: true })
], SlDrawer.prototype, "handleNoModalChange", 1);
setDefaultAnimation("drawer.showTop", {
  keyframes: [
    { opacity: 0, translate: "0 -100%" },
    { opacity: 1, translate: "0 0" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.hideTop", {
  keyframes: [
    { opacity: 1, translate: "0 0" },
    { opacity: 0, translate: "0 -100%" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.showEnd", {
  keyframes: [
    { opacity: 0, translate: "100%" },
    { opacity: 1, translate: "0" }
  ],
  rtlKeyframes: [
    { opacity: 0, translate: "-100%" },
    { opacity: 1, translate: "0" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.hideEnd", {
  keyframes: [
    { opacity: 1, translate: "0" },
    { opacity: 0, translate: "100%" }
  ],
  rtlKeyframes: [
    { opacity: 1, translate: "0" },
    { opacity: 0, translate: "-100%" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.showBottom", {
  keyframes: [
    { opacity: 0, translate: "0 100%" },
    { opacity: 1, translate: "0 0" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.hideBottom", {
  keyframes: [
    { opacity: 1, translate: "0 0" },
    { opacity: 0, translate: "0 100%" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.showStart", {
  keyframes: [
    { opacity: 0, translate: "-100%" },
    { opacity: 1, translate: "0" }
  ],
  rtlKeyframes: [
    { opacity: 0, translate: "100%" },
    { opacity: 1, translate: "0" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.hideStart", {
  keyframes: [
    { opacity: 1, translate: "0" },
    { opacity: 0, translate: "-100%" }
  ],
  rtlKeyframes: [
    { opacity: 1, translate: "0" },
    { opacity: 0, translate: "100%" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.denyClose", {
  keyframes: [{ scale: 1 }, { scale: 1.01 }, { scale: 1 }],
  options: { duration: 250 }
});
setDefaultAnimation("drawer.overlay.show", {
  keyframes: [{ opacity: 0 }, { opacity: 1 }],
  options: { duration: 250 }
});
setDefaultAnimation("drawer.overlay.hide", {
  keyframes: [{ opacity: 1 }, { opacity: 0 }],
  options: { duration: 250 }
});

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.KDSR4IRB.js
SlDrawer.define("sl-drawer");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LXP7GVU3.js
var dropdown_styles_default = i`
  :host {
    display: inline-block;
  }

  .dropdown::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .dropdown[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .dropdown[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .dropdown[data-current-placement^='left']::part(popup) {
    transform-origin: right;
  }

  .dropdown[data-current-placement^='right']::part(popup) {
    transform-origin: left;
  }

  .dropdown__trigger {
    display: block;
  }

  .dropdown__panel {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    border-radius: var(--sl-border-radius-medium);
    pointer-events: none;
  }

  .dropdown--open .dropdown__panel {
    display: block;
    pointer-events: all;
  }

  /* When users slot a menu, make sure it conforms to the popup's auto-size */
  ::slotted(sl-menu) {
    max-width: var(--auto-size-available-width) !important;
    max-height: var(--auto-size-available-height) !important;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.FLYTFYGC.js
var SlDropdown = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.open = false;
    this.placement = "bottom-start";
    this.disabled = false;
    this.stayOpenOnSelect = false;
    this.distance = 0;
    this.skidding = 0;
    this.hoist = false;
    this.sync = void 0;
    this.handleKeyDown = (event) => {
      if (this.open && event.key === "Escape") {
        event.stopPropagation();
        this.hide();
        this.focusOnTrigger();
      }
    };
    this.handleDocumentKeyDown = (event) => {
      var _a24;
      if (event.key === "Escape" && this.open && !this.closeWatcher) {
        event.stopPropagation();
        this.focusOnTrigger();
        this.hide();
        return;
      }
      if (event.key === "Tab") {
        if (this.open && ((_a24 = document.activeElement) == null ? void 0 : _a24.tagName.toLowerCase()) === "sl-menu-item") {
          event.preventDefault();
          this.hide();
          this.focusOnTrigger();
          return;
        }
        setTimeout(() => {
          var _a25, _b, _c;
          const activeElement = ((_a25 = this.containingElement) == null ? void 0 : _a25.getRootNode()) instanceof ShadowRoot ? (_c = (_b = document.activeElement) == null ? void 0 : _b.shadowRoot) == null ? void 0 : _c.activeElement : document.activeElement;
          if (!this.containingElement || (activeElement == null ? void 0 : activeElement.closest(this.containingElement.tagName.toLowerCase())) !== this.containingElement) {
            this.hide();
          }
        });
      }
    };
    this.handleDocumentMouseDown = (event) => {
      const path = event.composedPath();
      if (this.containingElement && !path.includes(this.containingElement)) {
        this.hide();
      }
    };
    this.handlePanelSelect = (event) => {
      const target = event.target;
      if (!this.stayOpenOnSelect && target.tagName.toLowerCase() === "sl-menu") {
        this.hide();
        this.focusOnTrigger();
      }
    };
  }
  connectedCallback() {
    super.connectedCallback();
    if (!this.containingElement) {
      this.containingElement = this;
    }
  }
  firstUpdated() {
    this.panel.hidden = !this.open;
    if (this.open) {
      this.addOpenListeners();
      this.popup.active = true;
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeOpenListeners();
    this.hide();
  }
  focusOnTrigger() {
    const trigger = this.trigger.assignedElements({ flatten: true })[0];
    if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
      trigger.focus();
    }
  }
  getMenu() {
    return this.panel.assignedElements({ flatten: true }).find((el) => el.tagName.toLowerCase() === "sl-menu");
  }
  handleTriggerClick() {
    if (this.open) {
      this.hide();
    } else {
      this.show();
      this.focusOnTrigger();
    }
  }
  async handleTriggerKeyDown(event) {
    if ([" ", "Enter"].includes(event.key)) {
      event.preventDefault();
      this.handleTriggerClick();
      return;
    }
    const menu = this.getMenu();
    if (menu) {
      const menuItems = menu.getAllItems();
      const firstMenuItem = menuItems[0];
      const lastMenuItem = menuItems[menuItems.length - 1];
      if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event.key)) {
        event.preventDefault();
        if (!this.open) {
          this.show();
          await this.updateComplete;
        }
        if (menuItems.length > 0) {
          this.updateComplete.then(() => {
            if (event.key === "ArrowDown" || event.key === "Home") {
              menu.setCurrentItem(firstMenuItem);
              firstMenuItem.focus();
            }
            if (event.key === "ArrowUp" || event.key === "End") {
              menu.setCurrentItem(lastMenuItem);
              lastMenuItem.focus();
            }
          });
        }
      }
    }
  }
  handleTriggerKeyUp(event) {
    if (event.key === " ") {
      event.preventDefault();
    }
  }
  handleTriggerSlotChange() {
    this.updateAccessibleTrigger();
  }
  //
  // Slotted triggers can be arbitrary content, but we need to link them to the dropdown panel with `aria-haspopup` and
  // `aria-expanded`. These must be applied to the "accessible trigger" (the tabbable portion of the trigger element
  // that gets slotted in) so screen readers will understand them. The accessible trigger could be the slotted element,
  // a child of the slotted element, or an element in the slotted element's shadow root.
  //
  // For example, the accessible trigger of an <sl-button> is a <button> located inside its shadow root.
  //
  // To determine this, we assume the first tabbable element in the trigger slot is the "accessible trigger."
  //
  updateAccessibleTrigger() {
    const assignedElements = this.trigger.assignedElements({ flatten: true });
    const accessibleTrigger = assignedElements.find((el) => getTabbableBoundary(el).start);
    let target;
    if (accessibleTrigger) {
      switch (accessibleTrigger.tagName.toLowerCase()) {
        case "sl-button":
        case "sl-icon-button":
          target = accessibleTrigger.button;
          break;
        default:
          target = accessibleTrigger;
      }
      target.setAttribute("aria-haspopup", "true");
      target.setAttribute("aria-expanded", this.open ? "true" : "false");
    }
  }
  /** Shows the dropdown panel. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the dropdown panel */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  /**
   * Instructs the dropdown menu to reposition. Useful when the position or size of the trigger changes when the menu
   * is activated.
   */
  reposition() {
    this.popup.reposition();
  }
  addOpenListeners() {
    var _a24;
    this.panel.addEventListener("sl-select", this.handlePanelSelect);
    if ("CloseWatcher" in window) {
      (_a24 = this.closeWatcher) == null ? void 0 : _a24.destroy();
      this.closeWatcher = new CloseWatcher();
      this.closeWatcher.onclose = () => {
        this.hide();
        this.focusOnTrigger();
      };
    } else {
      this.panel.addEventListener("keydown", this.handleKeyDown);
    }
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
  }
  removeOpenListeners() {
    var _a24;
    if (this.panel) {
      this.panel.removeEventListener("sl-select", this.handlePanelSelect);
      this.panel.removeEventListener("keydown", this.handleKeyDown);
    }
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
    (_a24 = this.closeWatcher) == null ? void 0 : _a24.destroy();
  }
  async handleOpenChange() {
    if (this.disabled) {
      this.open = false;
      return;
    }
    this.updateAccessibleTrigger();
    if (this.open) {
      this.emit("sl-show");
      this.addOpenListeners();
      await stopAnimations(this);
      this.panel.hidden = false;
      this.popup.active = true;
      const { keyframes, options } = getAnimation(this, "dropdown.show", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      await stopAnimations(this);
      const { keyframes, options } = getAnimation(this, "dropdown.hide", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      this.panel.hidden = true;
      this.popup.active = false;
      this.emit("sl-after-hide");
    }
  }
  render() {
    return ke`
      <sl-popup
        part="base"
        id="dropdown"
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        auto-size="vertical"
        auto-size-padding="10"
        sync=${to(this.sync ? this.sync : void 0)}
        class=${Rt({
      dropdown: true,
      "dropdown--open": this.open
    })}
      >
        <slot
          name="trigger"
          slot="anchor"
          part="trigger"
          class="dropdown__trigger"
          @click=${this.handleTriggerClick}
          @keydown=${this.handleTriggerKeyDown}
          @keyup=${this.handleTriggerKeyUp}
          @slotchange=${this.handleTriggerSlotChange}
        ></slot>

        <div aria-hidden=${this.open ? "false" : "true"} aria-labelledby="dropdown">
          <slot part="panel" class="dropdown__panel"></slot>
        </div>
      </sl-popup>
    `;
  }
};
SlDropdown.styles = [component_styles_default, dropdown_styles_default];
SlDropdown.dependencies = { "sl-popup": SlPopup };
__decorateClass([
  e7(".dropdown")
], SlDropdown.prototype, "popup", 2);
__decorateClass([
  e7(".dropdown__trigger")
], SlDropdown.prototype, "trigger", 2);
__decorateClass([
  e7(".dropdown__panel")
], SlDropdown.prototype, "panel", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlDropdown.prototype, "open", 2);
__decorateClass([
  n6({ reflect: true })
], SlDropdown.prototype, "placement", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlDropdown.prototype, "disabled", 2);
__decorateClass([
  n6({ attribute: "stay-open-on-select", type: Boolean, reflect: true })
], SlDropdown.prototype, "stayOpenOnSelect", 2);
__decorateClass([
  n6({ attribute: false })
], SlDropdown.prototype, "containingElement", 2);
__decorateClass([
  n6({ type: Number })
], SlDropdown.prototype, "distance", 2);
__decorateClass([
  n6({ type: Number })
], SlDropdown.prototype, "skidding", 2);
__decorateClass([
  n6({ type: Boolean })
], SlDropdown.prototype, "hoist", 2);
__decorateClass([
  n6({ reflect: true })
], SlDropdown.prototype, "sync", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: true })
], SlDropdown.prototype, "handleOpenChange", 1);
setDefaultAnimation("dropdown.show", {
  keyframes: [
    { opacity: 0, scale: 0.9 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 100, easing: "ease" }
});
setDefaultAnimation("dropdown.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.9 }
  ],
  options: { duration: 100, easing: "ease" }
});

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.OJFFDYG4.js
var dropdown_default = SlDropdown;
SlDropdown.define("sl-dropdown");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.WSSNCNLM.js
var copy_button_styles_default = i`
  :host {
    --error-color: var(--sl-color-danger-600);
    --success-color: var(--sl-color-success-600);

    display: inline-block;
  }

  .copy-button__button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
  }

  .copy-button--success .copy-button__button {
    color: var(--success-color);
  }

  .copy-button--error .copy-button__button {
    color: var(--error-color);
  }

  .copy-button__button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .copy-button__button[disabled] {
    opacity: 0.5;
    cursor: not-allowed !important;
  }

  slot {
    display: inline-flex;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.K62PGRE5.js
var SlCopyButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.isCopying = false;
    this.status = "rest";
    this.value = "";
    this.from = "";
    this.disabled = false;
    this.copyLabel = "";
    this.successLabel = "";
    this.errorLabel = "";
    this.feedbackDuration = 1e3;
    this.tooltipPlacement = "top";
    this.hoist = false;
  }
  async handleCopy() {
    if (this.disabled || this.isCopying) {
      return;
    }
    this.isCopying = true;
    let valueToCopy = this.value;
    if (this.from) {
      const root = this.getRootNode();
      const isProperty = this.from.includes(".");
      const isAttribute = this.from.includes("[") && this.from.includes("]");
      let id3 = this.from;
      let field = "";
      if (isProperty) {
        [id3, field] = this.from.trim().split(".");
      } else if (isAttribute) {
        [id3, field] = this.from.trim().replace(/\]$/, "").split("[");
      }
      const target = "getElementById" in root ? root.getElementById(id3) : null;
      if (target) {
        if (isAttribute) {
          valueToCopy = target.getAttribute(field) || "";
        } else if (isProperty) {
          valueToCopy = target[field] || "";
        } else {
          valueToCopy = target.textContent || "";
        }
      } else {
        this.showStatus("error");
        this.emit("sl-error");
      }
    }
    if (!valueToCopy) {
      this.showStatus("error");
      this.emit("sl-error");
    } else {
      try {
        await navigator.clipboard.writeText(valueToCopy);
        this.showStatus("success");
        this.emit("sl-copy", {
          detail: {
            value: valueToCopy
          }
        });
      } catch (error) {
        this.showStatus("error");
        this.emit("sl-error");
      }
    }
  }
  async showStatus(status) {
    const copyLabel = this.copyLabel || this.localize.term("copy");
    const successLabel = this.successLabel || this.localize.term("copied");
    const errorLabel = this.errorLabel || this.localize.term("error");
    const iconToShow = status === "success" ? this.successIcon : this.errorIcon;
    const showAnimation = getAnimation(this, "copy.in", { dir: "ltr" });
    const hideAnimation = getAnimation(this, "copy.out", { dir: "ltr" });
    this.tooltip.content = status === "success" ? successLabel : errorLabel;
    await this.copyIcon.animate(hideAnimation.keyframes, hideAnimation.options).finished;
    this.copyIcon.hidden = true;
    this.status = status;
    iconToShow.hidden = false;
    await iconToShow.animate(showAnimation.keyframes, showAnimation.options).finished;
    setTimeout(async () => {
      await iconToShow.animate(hideAnimation.keyframes, hideAnimation.options).finished;
      iconToShow.hidden = true;
      this.status = "rest";
      this.copyIcon.hidden = false;
      await this.copyIcon.animate(showAnimation.keyframes, showAnimation.options).finished;
      this.tooltip.content = copyLabel;
      this.isCopying = false;
    }, this.feedbackDuration);
  }
  render() {
    const copyLabel = this.copyLabel || this.localize.term("copy");
    return ke`
      <sl-tooltip
        class=${Rt({
      "copy-button": true,
      "copy-button--success": this.status === "success",
      "copy-button--error": this.status === "error"
    })}
        content=${copyLabel}
        placement=${this.tooltipPlacement}
        ?disabled=${this.disabled}
        ?hoist=${this.hoist}
        exportparts="
          base:tooltip__base,
          base__popup:tooltip__base__popup,
          base__arrow:tooltip__base__arrow,
          body:tooltip__body
        "
      >
        <button
          class="copy-button__button"
          part="button"
          type="button"
          ?disabled=${this.disabled}
          @click=${this.handleCopy}
        >
          <slot part="copy-icon" name="copy-icon">
            <sl-icon library="system" name="copy"></sl-icon>
          </slot>
          <slot part="success-icon" name="success-icon" hidden>
            <sl-icon library="system" name="check"></sl-icon>
          </slot>
          <slot part="error-icon" name="error-icon" hidden>
            <sl-icon library="system" name="x-lg"></sl-icon>
          </slot>
        </button>
      </sl-tooltip>
    `;
  }
};
SlCopyButton.styles = [component_styles_default, copy_button_styles_default];
SlCopyButton.dependencies = {
  "sl-icon": SlIcon,
  "sl-tooltip": SlTooltip
};
__decorateClass([
  e7('slot[name="copy-icon"]')
], SlCopyButton.prototype, "copyIcon", 2);
__decorateClass([
  e7('slot[name="success-icon"]')
], SlCopyButton.prototype, "successIcon", 2);
__decorateClass([
  e7('slot[name="error-icon"]')
], SlCopyButton.prototype, "errorIcon", 2);
__decorateClass([
  e7("sl-tooltip")
], SlCopyButton.prototype, "tooltip", 2);
__decorateClass([
  r5()
], SlCopyButton.prototype, "isCopying", 2);
__decorateClass([
  r5()
], SlCopyButton.prototype, "status", 2);
__decorateClass([
  n6()
], SlCopyButton.prototype, "value", 2);
__decorateClass([
  n6()
], SlCopyButton.prototype, "from", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlCopyButton.prototype, "disabled", 2);
__decorateClass([
  n6({ attribute: "copy-label" })
], SlCopyButton.prototype, "copyLabel", 2);
__decorateClass([
  n6({ attribute: "success-label" })
], SlCopyButton.prototype, "successLabel", 2);
__decorateClass([
  n6({ attribute: "error-label" })
], SlCopyButton.prototype, "errorLabel", 2);
__decorateClass([
  n6({ attribute: "feedback-duration", type: Number })
], SlCopyButton.prototype, "feedbackDuration", 2);
__decorateClass([
  n6({ attribute: "tooltip-placement" })
], SlCopyButton.prototype, "tooltipPlacement", 2);
__decorateClass([
  n6({ type: Boolean })
], SlCopyButton.prototype, "hoist", 2);
setDefaultAnimation("copy.in", {
  keyframes: [
    { scale: ".25", opacity: ".25" },
    { scale: "1", opacity: "1" }
  ],
  options: { duration: 100 }
});
setDefaultAnimation("copy.out", {
  keyframes: [
    { scale: "1", opacity: "1" },
    { scale: ".25", opacity: "0" }
  ],
  options: { duration: 100 }
});

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2NBLLECC.js
SlCopyButton.define("sl-copy-button");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.J7PLVEQM.js
var details_styles_default = i`
  :host {
    display: block;
  }

  .details {
    border: solid 1px var(--sl-color-neutral-200);
    border-radius: var(--sl-border-radius-medium);
    background-color: var(--sl-color-neutral-0);
    overflow-anchor: none;
  }

  .details--disabled {
    opacity: 0.5;
  }

  .details__header {
    display: flex;
    align-items: center;
    border-radius: inherit;
    padding: var(--sl-spacing-medium);
    user-select: none;
    -webkit-user-select: none;
    cursor: pointer;
  }

  .details__header::-webkit-details-marker {
    display: none;
  }

  .details__header:focus {
    outline: none;
  }

  .details__header:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: calc(1px + var(--sl-focus-ring-offset));
  }

  .details--disabled .details__header {
    cursor: not-allowed;
  }

  .details--disabled .details__header:focus-visible {
    outline: none;
    box-shadow: none;
  }

  .details__summary {
    flex: 1 1 auto;
    display: flex;
    align-items: center;
  }

  .details__summary-icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    transition: var(--sl-transition-medium) rotate ease;
  }

  .details--open .details__summary-icon {
    rotate: 90deg;
  }

  .details--open.details--rtl .details__summary-icon {
    rotate: -90deg;
  }

  .details--open slot[name='expand-icon'],
  .details:not(.details--open) slot[name='collapse-icon'] {
    display: none;
  }

  .details__body {
    overflow: hidden;
  }

  .details__content {
    display: block;
    padding: var(--sl-spacing-medium);
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.NTUEQTVT.js
var SlDetails = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.open = false;
    this.disabled = false;
  }
  firstUpdated() {
    this.body.style.height = this.open ? "auto" : "0";
    if (this.open) {
      this.details.open = true;
    }
    this.detailsObserver = new MutationObserver((changes) => {
      for (const change of changes) {
        if (change.type === "attributes" && change.attributeName === "open") {
          if (this.details.open) {
            this.show();
          } else {
            this.hide();
          }
        }
      }
    });
    this.detailsObserver.observe(this.details, { attributes: true });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.detailsObserver.disconnect();
  }
  handleSummaryClick(event) {
    event.preventDefault();
    if (!this.disabled) {
      if (this.open) {
        this.hide();
      } else {
        this.show();
      }
      this.header.focus();
    }
  }
  handleSummaryKeyDown(event) {
    if (event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      if (this.open) {
        this.hide();
      } else {
        this.show();
      }
    }
    if (event.key === "ArrowUp" || event.key === "ArrowLeft") {
      event.preventDefault();
      this.hide();
    }
    if (event.key === "ArrowDown" || event.key === "ArrowRight") {
      event.preventDefault();
      this.show();
    }
  }
  async handleOpenChange() {
    if (this.open) {
      this.details.open = true;
      const slShow = this.emit("sl-show", { cancelable: true });
      if (slShow.defaultPrevented) {
        this.open = false;
        this.details.open = false;
        return;
      }
      await stopAnimations(this.body);
      const { keyframes, options } = getAnimation(this, "details.show", { dir: this.localize.dir() });
      await animateTo(this.body, shimKeyframesHeightAuto(keyframes, this.body.scrollHeight), options);
      this.body.style.height = "auto";
      this.emit("sl-after-show");
    } else {
      const slHide = this.emit("sl-hide", { cancelable: true });
      if (slHide.defaultPrevented) {
        this.details.open = true;
        this.open = true;
        return;
      }
      await stopAnimations(this.body);
      const { keyframes, options } = getAnimation(this, "details.hide", { dir: this.localize.dir() });
      await animateTo(this.body, shimKeyframesHeightAuto(keyframes, this.body.scrollHeight), options);
      this.body.style.height = "auto";
      this.details.open = false;
      this.emit("sl-after-hide");
    }
  }
  /** Shows the details. */
  async show() {
    if (this.open || this.disabled) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the details */
  async hide() {
    if (!this.open || this.disabled) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    return ke`
      <details
        part="base"
        class=${Rt({
      details: true,
      "details--open": this.open,
      "details--disabled": this.disabled,
      "details--rtl": isRtl
    })}
      >
        <summary
          part="header"
          id="header"
          class="details__header"
          role="button"
          aria-expanded=${this.open ? "true" : "false"}
          aria-controls="content"
          aria-disabled=${this.disabled ? "true" : "false"}
          tabindex=${this.disabled ? "-1" : "0"}
          @click=${this.handleSummaryClick}
          @keydown=${this.handleSummaryKeyDown}
        >
          <slot name="summary" part="summary" class="details__summary">${this.summary}</slot>

          <span part="summary-icon" class="details__summary-icon">
            <slot name="expand-icon">
              <sl-icon library="system" name=${isRtl ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
            <slot name="collapse-icon">
              <sl-icon library="system" name=${isRtl ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
          </span>
        </summary>

        <div class="details__body" role="region" aria-labelledby="header">
          <slot part="content" id="content" class="details__content"></slot>
        </div>
      </details>
    `;
  }
};
SlDetails.styles = [component_styles_default, details_styles_default];
SlDetails.dependencies = {
  "sl-icon": SlIcon
};
__decorateClass([
  e7(".details")
], SlDetails.prototype, "details", 2);
__decorateClass([
  e7(".details__header")
], SlDetails.prototype, "header", 2);
__decorateClass([
  e7(".details__body")
], SlDetails.prototype, "body", 2);
__decorateClass([
  e7(".details__expand-icon-slot")
], SlDetails.prototype, "expandIconSlot", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlDetails.prototype, "open", 2);
__decorateClass([
  n6()
], SlDetails.prototype, "summary", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlDetails.prototype, "disabled", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: true })
], SlDetails.prototype, "handleOpenChange", 1);
setDefaultAnimation("details.show", {
  keyframes: [
    { height: "0", opacity: "0" },
    { height: "auto", opacity: "1" }
  ],
  options: { duration: 250, easing: "linear" }
});
setDefaultAnimation("details.hide", {
  keyframes: [
    { height: "auto", opacity: "1" },
    { height: "0", opacity: "0" }
  ],
  options: { duration: 250, easing: "linear" }
});

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.MU3U6YPN.js
SlDetails.define("sl-details");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.G5RKA5HF.js
var dialog_styles_default = i`
  :host {
    --width: 31rem;
    --header-spacing: var(--sl-spacing-large);
    --body-spacing: var(--sl-spacing-large);
    --footer-spacing: var(--sl-spacing-large);

    display: contents;
  }

  .dialog {
    display: flex;
    align-items: center;
    justify-content: center;
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    z-index: var(--sl-z-index-dialog);
  }

  .dialog__panel {
    display: flex;
    flex-direction: column;
    z-index: 2;
    width: var(--width);
    max-width: calc(100% - var(--sl-spacing-2x-large));
    max-height: calc(100% - var(--sl-spacing-2x-large));
    background-color: var(--sl-panel-background-color);
    border-radius: var(--sl-border-radius-medium);
    box-shadow: var(--sl-shadow-x-large);
  }

  .dialog__panel:focus {
    outline: none;
  }

  /* Ensure there's enough vertical padding for phones that don't update vh when chrome appears (e.g. iPhone) */
  @media screen and (max-width: 420px) {
    .dialog__panel {
      max-height: 80vh;
    }
  }

  .dialog--open .dialog__panel {
    display: flex;
    opacity: 1;
  }

  .dialog__header {
    flex: 0 0 auto;
    display: flex;
  }

  .dialog__title {
    flex: 1 1 auto;
    font: inherit;
    font-size: var(--sl-font-size-large);
    line-height: var(--sl-line-height-dense);
    padding: var(--header-spacing);
    margin: 0;
  }

  .dialog__header-actions {
    flex-shrink: 0;
    display: flex;
    flex-wrap: wrap;
    justify-content: end;
    gap: var(--sl-spacing-2x-small);
    padding: 0 var(--header-spacing);
  }

  .dialog__header-actions sl-icon-button,
  .dialog__header-actions ::slotted(sl-icon-button) {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-medium);
  }

  .dialog__body {
    flex: 1 1 auto;
    display: block;
    padding: var(--body-spacing);
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  .dialog__footer {
    flex: 0 0 auto;
    text-align: right;
    padding: var(--footer-spacing);
  }

  .dialog__footer ::slotted(sl-button:not(:first-of-type)) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  .dialog:not(.dialog--has-footer) .dialog__footer {
    display: none;
  }

  .dialog__overlay {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: var(--sl-overlay-background-color);
  }

  @media (forced-colors: active) {
    .dialog__panel {
      border: solid 1px var(--sl-color-neutral-0);
    }
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.UE77SM53.js
var SlDialog = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "footer");
    this.localize = new LocalizeController2(this);
    this.modal = new Modal(this);
    this.open = false;
    this.label = "";
    this.noHeader = false;
    this.handleDocumentKeyDown = (event) => {
      if (event.key === "Escape" && this.modal.isActive() && this.open) {
        event.stopPropagation();
        this.requestClose("keyboard");
      }
    };
  }
  firstUpdated() {
    this.dialog.hidden = !this.open;
    if (this.open) {
      this.addOpenListeners();
      this.modal.activate();
      lockBodyScrolling(this);
    }
  }
  disconnectedCallback() {
    var _a24;
    super.disconnectedCallback();
    this.modal.deactivate();
    unlockBodyScrolling(this);
    (_a24 = this.closeWatcher) == null ? void 0 : _a24.destroy();
  }
  requestClose(source) {
    const slRequestClose = this.emit("sl-request-close", {
      cancelable: true,
      detail: { source }
    });
    if (slRequestClose.defaultPrevented) {
      const animation = getAnimation(this, "dialog.denyClose", { dir: this.localize.dir() });
      animateTo(this.panel, animation.keyframes, animation.options);
      return;
    }
    this.hide();
  }
  addOpenListeners() {
    var _a24;
    if ("CloseWatcher" in window) {
      (_a24 = this.closeWatcher) == null ? void 0 : _a24.destroy();
      this.closeWatcher = new CloseWatcher();
      this.closeWatcher.onclose = () => this.requestClose("keyboard");
    } else {
      document.addEventListener("keydown", this.handleDocumentKeyDown);
    }
  }
  removeOpenListeners() {
    var _a24;
    (_a24 = this.closeWatcher) == null ? void 0 : _a24.destroy();
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  async handleOpenChange() {
    if (this.open) {
      this.emit("sl-show");
      this.addOpenListeners();
      this.originalTrigger = document.activeElement;
      this.modal.activate();
      lockBodyScrolling(this);
      const autoFocusTarget = this.querySelector("[autofocus]");
      if (autoFocusTarget) {
        autoFocusTarget.removeAttribute("autofocus");
      }
      await Promise.all([stopAnimations(this.dialog), stopAnimations(this.overlay)]);
      this.dialog.hidden = false;
      requestAnimationFrame(() => {
        const slInitialFocus = this.emit("sl-initial-focus", { cancelable: true });
        if (!slInitialFocus.defaultPrevented) {
          if (autoFocusTarget) {
            autoFocusTarget.focus({ preventScroll: true });
          } else {
            this.panel.focus({ preventScroll: true });
          }
        }
        if (autoFocusTarget) {
          autoFocusTarget.setAttribute("autofocus", "");
        }
      });
      const panelAnimation = getAnimation(this, "dialog.show", { dir: this.localize.dir() });
      const overlayAnimation = getAnimation(this, "dialog.overlay.show", { dir: this.localize.dir() });
      await Promise.all([
        animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options),
        animateTo(this.overlay, overlayAnimation.keyframes, overlayAnimation.options)
      ]);
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      this.modal.deactivate();
      await Promise.all([stopAnimations(this.dialog), stopAnimations(this.overlay)]);
      const panelAnimation = getAnimation(this, "dialog.hide", { dir: this.localize.dir() });
      const overlayAnimation = getAnimation(this, "dialog.overlay.hide", { dir: this.localize.dir() });
      await Promise.all([
        animateTo(this.overlay, overlayAnimation.keyframes, overlayAnimation.options).then(() => {
          this.overlay.hidden = true;
        }),
        animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options).then(() => {
          this.panel.hidden = true;
        })
      ]);
      this.dialog.hidden = true;
      this.overlay.hidden = false;
      this.panel.hidden = false;
      unlockBodyScrolling(this);
      const trigger = this.originalTrigger;
      if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
        setTimeout(() => trigger.focus());
      }
      this.emit("sl-after-hide");
    }
  }
  /** Shows the dialog. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the dialog */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  render() {
    return ke`
      <div
        part="base"
        class=${Rt({
      dialog: true,
      "dialog--open": this.open,
      "dialog--has-footer": this.hasSlotController.test("footer")
    })}
      >
        <div part="overlay" class="dialog__overlay" @click=${() => this.requestClose("overlay")} tabindex="-1"></div>

        <div
          part="panel"
          class="dialog__panel"
          role="dialog"
          aria-modal="true"
          aria-hidden=${this.open ? "false" : "true"}
          aria-label=${to(this.noHeader ? this.label : void 0)}
          aria-labelledby=${to(!this.noHeader ? "title" : void 0)}
          tabindex="-1"
        >
          ${!this.noHeader ? ke`
                <header part="header" class="dialog__header">
                  <h2 part="title" class="dialog__title" id="title">
                    <slot name="label"> ${this.label.length > 0 ? this.label : String.fromCharCode(65279)} </slot>
                  </h2>
                  <div part="header-actions" class="dialog__header-actions">
                    <slot name="header-actions"></slot>
                    <sl-icon-button
                      part="close-button"
                      exportparts="base:close-button__base"
                      class="dialog__close"
                      name="x-lg"
                      label=${this.localize.term("close")}
                      library="system"
                      @click="${() => this.requestClose("close-button")}"
                    ></sl-icon-button>
                  </div>
                </header>
              ` : ""}
          ${""}
          <div part="body" class="dialog__body" tabindex="-1"><slot></slot></div>

          <footer part="footer" class="dialog__footer">
            <slot name="footer"></slot>
          </footer>
        </div>
      </div>
    `;
  }
};
SlDialog.styles = [component_styles_default, dialog_styles_default];
SlDialog.dependencies = {
  "sl-icon-button": SlIconButton
};
__decorateClass([
  e7(".dialog")
], SlDialog.prototype, "dialog", 2);
__decorateClass([
  e7(".dialog__panel")
], SlDialog.prototype, "panel", 2);
__decorateClass([
  e7(".dialog__overlay")
], SlDialog.prototype, "overlay", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlDialog.prototype, "open", 2);
__decorateClass([
  n6({ reflect: true })
], SlDialog.prototype, "label", 2);
__decorateClass([
  n6({ attribute: "no-header", type: Boolean, reflect: true })
], SlDialog.prototype, "noHeader", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: true })
], SlDialog.prototype, "handleOpenChange", 1);
setDefaultAnimation("dialog.show", {
  keyframes: [
    { opacity: 0, scale: 0.8 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("dialog.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.8 }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("dialog.denyClose", {
  keyframes: [{ scale: 1 }, { scale: 1.02 }, { scale: 1 }],
  options: { duration: 250 }
});
setDefaultAnimation("dialog.overlay.show", {
  keyframes: [{ opacity: 0 }, { opacity: 1 }],
  options: { duration: 250 }
});
setDefaultAnimation("dialog.overlay.hide", {
  keyframes: [{ opacity: 1 }, { opacity: 0 }],
  options: { duration: 250 }
});

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.545BWSIV.js
var dialog_default = SlDialog;
SlDialog.define("sl-dialog");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3DLLDGMJ.js
var checkbox_default = SlCheckbox;
SlCheckbox.define("sl-checkbox");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.O6CEROC7.js
var color_picker_styles_default = i`
  :host {
    --grid-width: 280px;
    --grid-height: 200px;
    --grid-handle-size: 16px;
    --slider-height: 15px;
    --slider-handle-size: 17px;
    --swatch-size: 25px;

    display: inline-block;
  }

  .color-picker {
    width: var(--grid-width);
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    color: var(--color);
    background-color: var(--sl-panel-background-color);
    border-radius: var(--sl-border-radius-medium);
    user-select: none;
    -webkit-user-select: none;
  }

  .color-picker--inline {
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
  }

  .color-picker--inline:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__grid {
    position: relative;
    height: var(--grid-height);
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 1) 100%),
      linear-gradient(to right, #fff 0%, rgba(255, 255, 255, 0) 100%);
    border-top-left-radius: var(--sl-border-radius-medium);
    border-top-right-radius: var(--sl-border-radius-medium);
    cursor: crosshair;
    forced-color-adjust: none;
  }

  .color-picker__grid-handle {
    position: absolute;
    width: var(--grid-handle-size);
    height: var(--grid-handle-size);
    border-radius: 50%;
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
    border: solid 2px white;
    margin-top: calc(var(--grid-handle-size) / -2);
    margin-left: calc(var(--grid-handle-size) / -2);
    transition: var(--sl-transition-fast) scale;
  }

  .color-picker__grid-handle--dragging {
    cursor: none;
    scale: 1.5;
  }

  .color-picker__grid-handle:focus-visible {
    outline: var(--sl-focus-ring);
  }

  .color-picker__controls {
    padding: var(--sl-spacing-small);
    display: flex;
    align-items: center;
  }

  .color-picker__sliders {
    flex: 1 1 auto;
  }

  .color-picker__slider {
    position: relative;
    height: var(--slider-height);
    border-radius: var(--sl-border-radius-pill);
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.2);
    forced-color-adjust: none;
  }

  .color-picker__slider:not(:last-of-type) {
    margin-bottom: var(--sl-spacing-small);
  }

  .color-picker__slider-handle {
    position: absolute;
    top: calc(50% - var(--slider-handle-size) / 2);
    width: var(--slider-handle-size);
    height: var(--slider-handle-size);
    background-color: white;
    border-radius: 50%;
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
    margin-left: calc(var(--slider-handle-size) / -2);
  }

  .color-picker__slider-handle:focus-visible {
    outline: var(--sl-focus-ring);
  }

  .color-picker__hue {
    background-image: linear-gradient(
      to right,
      rgb(255, 0, 0) 0%,
      rgb(255, 255, 0) 17%,
      rgb(0, 255, 0) 33%,
      rgb(0, 255, 255) 50%,
      rgb(0, 0, 255) 67%,
      rgb(255, 0, 255) 83%,
      rgb(255, 0, 0) 100%
    );
  }

  .color-picker__alpha .color-picker__alpha-gradient {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
  }

  .color-picker__preview {
    flex: 0 0 auto;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
    width: 2.25rem;
    height: 2.25rem;
    border: none;
    border-radius: var(--sl-border-radius-circle);
    background: none;
    margin-left: var(--sl-spacing-small);
    cursor: copy;
    forced-color-adjust: none;
  }

  .color-picker__preview:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.2);

    /* We use a custom property in lieu of currentColor because of https://bugs.webkit.org/show_bug.cgi?id=216780 */
    background-color: var(--preview-color);
  }

  .color-picker__preview:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__preview-color {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: solid 1px rgba(0, 0, 0, 0.125);
  }

  .color-picker__preview-color--copied {
    animation: pulse 0.75s;
  }

  @keyframes pulse {
    0% {
      box-shadow: 0 0 0 0 var(--sl-color-primary-500);
    }
    70% {
      box-shadow: 0 0 0 0.5rem transparent;
    }
    100% {
      box-shadow: 0 0 0 0 transparent;
    }
  }

  .color-picker__user-input {
    display: flex;
    padding: 0 var(--sl-spacing-small) var(--sl-spacing-small) var(--sl-spacing-small);
  }

  .color-picker__user-input sl-input {
    min-width: 0; /* fix input width in Safari */
    flex: 1 1 auto;
  }

  .color-picker__user-input sl-button-group {
    margin-left: var(--sl-spacing-small);
  }

  .color-picker__user-input sl-button {
    min-width: 3.25rem;
    max-width: 3.25rem;
    font-size: 1rem;
  }

  .color-picker__swatches {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-gap: 0.5rem;
    justify-items: center;
    border-top: solid 1px var(--sl-color-neutral-200);
    padding: var(--sl-spacing-small);
    forced-color-adjust: none;
  }

  .color-picker__swatch {
    position: relative;
    width: var(--swatch-size);
    height: var(--swatch-size);
    border-radius: var(--sl-border-radius-small);
  }

  .color-picker__swatch .color-picker__swatch-color {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: solid 1px rgba(0, 0, 0, 0.125);
    border-radius: inherit;
    cursor: pointer;
  }

  .color-picker__swatch:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__transparent-bg {
    background-image: linear-gradient(45deg, var(--sl-color-neutral-300) 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, var(--sl-color-neutral-300) 75%),
      linear-gradient(45deg, transparent 75%, var(--sl-color-neutral-300) 75%),
      linear-gradient(45deg, var(--sl-color-neutral-300) 25%, transparent 25%);
    background-size: 10px 10px;
    background-position:
      0 0,
      0 0,
      -5px -5px,
      5px 5px;
  }

  .color-picker--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .color-picker--disabled .color-picker__grid,
  .color-picker--disabled .color-picker__grid-handle,
  .color-picker--disabled .color-picker__slider,
  .color-picker--disabled .color-picker__slider-handle,
  .color-picker--disabled .color-picker__preview,
  .color-picker--disabled .color-picker__swatch,
  .color-picker--disabled .color-picker__swatch-color {
    pointer-events: none;
  }

  /*
   * Color dropdown
   */

  .color-dropdown::part(panel) {
    max-height: none;
    background-color: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    overflow: visible;
  }

  .color-dropdown__trigger {
    display: inline-block;
    position: relative;
    background-color: transparent;
    border: none;
    cursor: pointer;
    forced-color-adjust: none;
  }

  .color-dropdown__trigger.color-dropdown__trigger--small {
    width: var(--sl-input-height-small);
    height: var(--sl-input-height-small);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger.color-dropdown__trigger--medium {
    width: var(--sl-input-height-medium);
    height: var(--sl-input-height-medium);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger.color-dropdown__trigger--large {
    width: var(--sl-input-height-large);
    height: var(--sl-input-height-large);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
    background-color: currentColor;
    box-shadow:
      inset 0 0 0 2px var(--sl-input-border-color),
      inset 0 0 0 4px var(--sl-color-neutral-0);
  }

  .color-dropdown__trigger--empty:before {
    background-color: transparent;
  }

  .color-dropdown__trigger:focus-visible {
    outline: none;
  }

  .color-dropdown__trigger:focus-visible:not(.color-dropdown__trigger--disabled) {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-dropdown__trigger.color-dropdown__trigger--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.5SUGJ4EB.js
var SlButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["click"]
    });
    this.hasSlotController = new HasSlotController(this, "[default]", "prefix", "suffix");
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.invalid = false;
    this.title = "";
    this.variant = "default";
    this.size = "medium";
    this.caret = false;
    this.disabled = false;
    this.loading = false;
    this.outline = false;
    this.pill = false;
    this.circle = false;
    this.type = "button";
    this.name = "";
    this.value = "";
    this.href = "";
    this.rel = "noreferrer noopener";
  }
  /** Gets the validity state object */
  get validity() {
    if (this.isButton()) {
      return this.button.validity;
    }
    return validValidityState;
  }
  /** Gets the validation message */
  get validationMessage() {
    if (this.isButton()) {
      return this.button.validationMessage;
    }
    return "";
  }
  firstUpdated() {
    if (this.isButton()) {
      this.formControlController.updateValidity();
    }
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick() {
    if (this.type === "submit") {
      this.formControlController.submit(this);
    }
    if (this.type === "reset") {
      this.formControlController.reset(this);
    }
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  isButton() {
    return this.href ? false : true;
  }
  isLink() {
    return this.href ? true : false;
  }
  handleDisabledChange() {
    if (this.isButton()) {
      this.formControlController.setValidity(this.disabled);
    }
  }
  /** Simulates a click on the button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the button. */
  blur() {
    this.button.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    if (this.isButton()) {
      return this.button.checkValidity();
    }
    return true;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    if (this.isButton()) {
      return this.button.reportValidity();
    }
    return true;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    if (this.isButton()) {
      this.button.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
  }
  render() {
    const isLink = this.isLink();
    const tag = isLink ? er`a` : er`button`;
    return ke3`
      <${tag}
        part="base"
        class=${Rt({
      button: true,
      "button--default": this.variant === "default",
      "button--primary": this.variant === "primary",
      "button--success": this.variant === "success",
      "button--neutral": this.variant === "neutral",
      "button--warning": this.variant === "warning",
      "button--danger": this.variant === "danger",
      "button--text": this.variant === "text",
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--caret": this.caret,
      "button--circle": this.circle,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--loading": this.loading,
      "button--standard": !this.outline,
      "button--outline": this.outline,
      "button--pill": this.pill,
      "button--rtl": this.localize.dir() === "rtl",
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
        ?disabled=${to(isLink ? void 0 : this.disabled)}
        type=${to(isLink ? void 0 : this.type)}
        title=${this.title}
        name=${to(isLink ? void 0 : this.name)}
        value=${to(isLink ? void 0 : this.value)}
        href=${to(isLink ? this.href : void 0)}
        target=${to(isLink ? this.target : void 0)}
        download=${to(isLink ? this.download : void 0)}
        rel=${to(isLink ? this.rel : void 0)}
        role=${to(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @invalid=${this.isButton() ? this.handleInvalid : null}
        @click=${this.handleClick}
      >
        <slot name="prefix" part="prefix" class="button__prefix"></slot>
        <slot part="label" class="button__label"></slot>
        <slot name="suffix" part="suffix" class="button__suffix"></slot>
        ${this.caret ? ke3` <sl-icon part="caret" class="button__caret" library="system" name="caret"></sl-icon> ` : ""}
        ${this.loading ? ke3`<sl-spinner part="spinner"></sl-spinner>` : ""}
      </${tag}>
    `;
  }
};
SlButton.styles = [component_styles_default, button_styles_default];
SlButton.dependencies = {
  "sl-icon": SlIcon,
  "sl-spinner": SlSpinner
};
__decorateClass([
  e7(".button")
], SlButton.prototype, "button", 2);
__decorateClass([
  r5()
], SlButton.prototype, "hasFocus", 2);
__decorateClass([
  r5()
], SlButton.prototype, "invalid", 2);
__decorateClass([
  n6()
], SlButton.prototype, "title", 2);
__decorateClass([
  n6({ reflect: true })
], SlButton.prototype, "variant", 2);
__decorateClass([
  n6({ reflect: true })
], SlButton.prototype, "size", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlButton.prototype, "caret", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlButton.prototype, "disabled", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlButton.prototype, "loading", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlButton.prototype, "outline", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlButton.prototype, "pill", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlButton.prototype, "circle", 2);
__decorateClass([
  n6()
], SlButton.prototype, "type", 2);
__decorateClass([
  n6()
], SlButton.prototype, "name", 2);
__decorateClass([
  n6()
], SlButton.prototype, "value", 2);
__decorateClass([
  n6()
], SlButton.prototype, "href", 2);
__decorateClass([
  n6()
], SlButton.prototype, "target", 2);
__decorateClass([
  n6()
], SlButton.prototype, "rel", 2);
__decorateClass([
  n6()
], SlButton.prototype, "download", 2);
__decorateClass([
  n6()
], SlButton.prototype, "form", 2);
__decorateClass([
  n6({ attribute: "formaction" })
], SlButton.prototype, "formAction", 2);
__decorateClass([
  n6({ attribute: "formenctype" })
], SlButton.prototype, "formEnctype", 2);
__decorateClass([
  n6({ attribute: "formmethod" })
], SlButton.prototype, "formMethod", 2);
__decorateClass([
  n6({ attribute: "formnovalidate", type: Boolean })
], SlButton.prototype, "formNoValidate", 2);
__decorateClass([
  n6({ attribute: "formtarget" })
], SlButton.prototype, "formTarget", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlButton.prototype, "handleDisabledChange", 1);

// src/node_modules/@ctrl/tinycolor/dist/module/util.js
function bound01(n7, max2) {
  if (isOnePointZero(n7)) {
    n7 = "100%";
  }
  const isPercent = isPercentage(n7);
  n7 = max2 === 360 ? n7 : Math.min(max2, Math.max(0, parseFloat(n7)));
  if (isPercent) {
    n7 = parseInt(String(n7 * max2), 10) / 100;
  }
  if (Math.abs(n7 - max2) < 1e-6) {
    return 1;
  }
  if (max2 === 360) {
    n7 = (n7 < 0 ? n7 % max2 + max2 : n7 % max2) / parseFloat(String(max2));
  } else {
    n7 = n7 % max2 / parseFloat(String(max2));
  }
  return n7;
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n7) {
  return typeof n7 === "string" && n7.indexOf(".") !== -1 && parseFloat(n7) === 1;
}
function isPercentage(n7) {
  return typeof n7 === "string" && n7.indexOf("%") !== -1;
}
function boundAlpha(a3) {
  a3 = parseFloat(a3);
  if (isNaN(a3) || a3 < 0 || a3 > 1) {
    a3 = 1;
  }
  return a3;
}
function convertToPercentage(n7) {
  if (Number(n7) <= 1) {
    return `${Number(n7) * 100}%`;
  }
  return n7;
}
function pad2(c6) {
  return c6.length === 1 ? "0" + c6 : String(c6);
}

// src/node_modules/@ctrl/tinycolor/dist/module/conversion.js
function rgbToRgb(r9, g3, b3) {
  return {
    r: bound01(r9, 255) * 255,
    g: bound01(g3, 255) * 255,
    b: bound01(b3, 255) * 255
  };
}
function rgbToHsl(r9, g3, b3) {
  r9 = bound01(r9, 255);
  g3 = bound01(g3, 255);
  b3 = bound01(b3, 255);
  const max2 = Math.max(r9, g3, b3);
  const min2 = Math.min(r9, g3, b3);
  let h5 = 0;
  let s6 = 0;
  const l3 = (max2 + min2) / 2;
  if (max2 === min2) {
    s6 = 0;
    h5 = 0;
  } else {
    const d3 = max2 - min2;
    s6 = l3 > 0.5 ? d3 / (2 - max2 - min2) : d3 / (max2 + min2);
    switch (max2) {
      case r9:
        h5 = (g3 - b3) / d3 + (g3 < b3 ? 6 : 0);
        break;
      case g3:
        h5 = (b3 - r9) / d3 + 2;
        break;
      case b3:
        h5 = (r9 - g3) / d3 + 4;
        break;
      default:
        break;
    }
    h5 /= 6;
  }
  return { h: h5, s: s6, l: l3 };
}
function hue2rgb(p3, q3, t8) {
  if (t8 < 0) {
    t8 += 1;
  }
  if (t8 > 1) {
    t8 -= 1;
  }
  if (t8 < 1 / 6) {
    return p3 + (q3 - p3) * (6 * t8);
  }
  if (t8 < 1 / 2) {
    return q3;
  }
  if (t8 < 2 / 3) {
    return p3 + (q3 - p3) * (2 / 3 - t8) * 6;
  }
  return p3;
}
function hslToRgb(h5, s6, l3) {
  let r9;
  let g3;
  let b3;
  h5 = bound01(h5, 360);
  s6 = bound01(s6, 100);
  l3 = bound01(l3, 100);
  if (s6 === 0) {
    g3 = l3;
    b3 = l3;
    r9 = l3;
  } else {
    const q3 = l3 < 0.5 ? l3 * (1 + s6) : l3 + s6 - l3 * s6;
    const p3 = 2 * l3 - q3;
    r9 = hue2rgb(p3, q3, h5 + 1 / 3);
    g3 = hue2rgb(p3, q3, h5);
    b3 = hue2rgb(p3, q3, h5 - 1 / 3);
  }
  return { r: r9 * 255, g: g3 * 255, b: b3 * 255 };
}
function rgbToHsv(r9, g3, b3) {
  r9 = bound01(r9, 255);
  g3 = bound01(g3, 255);
  b3 = bound01(b3, 255);
  const max2 = Math.max(r9, g3, b3);
  const min2 = Math.min(r9, g3, b3);
  let h5 = 0;
  const v3 = max2;
  const d3 = max2 - min2;
  const s6 = max2 === 0 ? 0 : d3 / max2;
  if (max2 === min2) {
    h5 = 0;
  } else {
    switch (max2) {
      case r9:
        h5 = (g3 - b3) / d3 + (g3 < b3 ? 6 : 0);
        break;
      case g3:
        h5 = (b3 - r9) / d3 + 2;
        break;
      case b3:
        h5 = (r9 - g3) / d3 + 4;
        break;
      default:
        break;
    }
    h5 /= 6;
  }
  return { h: h5, s: s6, v: v3 };
}
function hsvToRgb(h5, s6, v3) {
  h5 = bound01(h5, 360) * 6;
  s6 = bound01(s6, 100);
  v3 = bound01(v3, 100);
  const i5 = Math.floor(h5);
  const f5 = h5 - i5;
  const p3 = v3 * (1 - s6);
  const q3 = v3 * (1 - f5 * s6);
  const t8 = v3 * (1 - (1 - f5) * s6);
  const mod = i5 % 6;
  const r9 = [v3, q3, p3, p3, t8, v3][mod];
  const g3 = [t8, v3, v3, q3, p3, p3][mod];
  const b3 = [p3, p3, t8, v3, v3, q3][mod];
  return { r: r9 * 255, g: g3 * 255, b: b3 * 255 };
}
function rgbToHex(r9, g3, b3, allow3Char) {
  const hex = [
    pad2(Math.round(r9).toString(16)),
    pad2(Math.round(g3).toString(16)),
    pad2(Math.round(b3).toString(16))
  ];
  if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r9, g3, b3, a3, allow4Char) {
  const hex = [
    pad2(Math.round(r9).toString(16)),
    pad2(Math.round(g3).toString(16)),
    pad2(Math.round(b3).toString(16)),
    pad2(convertDecimalToHex(a3))
  ];
  if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function cmykToRgb(c6, m3, y3, k3) {
  const cConv = c6 / 100;
  const mConv = m3 / 100;
  const yConv = y3 / 100;
  const kConv = k3 / 100;
  const r9 = 255 * (1 - cConv) * (1 - kConv);
  const g3 = 255 * (1 - mConv) * (1 - kConv);
  const b3 = 255 * (1 - yConv) * (1 - kConv);
  return { r: r9, g: g3, b: b3 };
}
function rgbToCmyk(r9, g3, b3) {
  let c6 = 1 - r9 / 255;
  let m3 = 1 - g3 / 255;
  let y3 = 1 - b3 / 255;
  let k3 = Math.min(c6, m3, y3);
  if (k3 === 1) {
    c6 = 0;
    m3 = 0;
    y3 = 0;
  } else {
    c6 = (c6 - k3) / (1 - k3) * 100;
    m3 = (m3 - k3) / (1 - k3) * 100;
    y3 = (y3 - k3) / (1 - k3) * 100;
  }
  k3 *= 100;
  return {
    c: Math.round(c6),
    m: Math.round(m3),
    y: Math.round(y3),
    k: Math.round(k3)
  };
}
function convertDecimalToHex(d3) {
  return Math.round(parseFloat(d3) * 255).toString(16);
}
function convertHexToDecimal(h5) {
  return parseIntFromHex(h5) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color) {
  return {
    r: color >> 16,
    g: (color & 65280) >> 8,
    b: color & 255
  };
}

// src/node_modules/@ctrl/tinycolor/dist/module/css-color-names.js
var names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};

// src/node_modules/@ctrl/tinycolor/dist/module/format-input.js
function inputToRGB(color) {
  let rgb = { r: 0, g: 0, b: 0 };
  let a3 = 1;
  let s6 = null;
  let v3 = null;
  let l3 = null;
  let ok = false;
  let format = false;
  if (typeof color === "string") {
    color = stringInputToObject(color);
  }
  if (typeof color === "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s6 = convertToPercentage(color.s);
      v3 = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s6, v3);
      ok = true;
      format = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s6 = convertToPercentage(color.s);
      l3 = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s6, l3);
      ok = true;
      format = "hsl";
    } else if (isValidCSSUnit(color.c) && isValidCSSUnit(color.m) && isValidCSSUnit(color.y) && isValidCSSUnit(color.k)) {
      rgb = cmykToRgb(color.c, color.m, color.y, color.k);
      ok = true;
      format = "cmyk";
    }
    if (Object.prototype.hasOwnProperty.call(color, "a")) {
      a3 = color.a;
    }
  }
  a3 = boundAlpha(a3);
  return {
    ok,
    format: color.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a3
  };
}
var CSS_INTEGER = "[-\\+]?\\d+%?";
var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
var PERMISSIVE_MATCH4 = (
  // eslint-disable-next-line prettier/prettier
  "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?"
);
var matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  cmyk: new RegExp("cmyk" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color) {
  color = color.trim().toLowerCase();
  if (color.length === 0) {
    return false;
  }
  let named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  let match = matchers.rgb.exec(color);
  if (match) {
    return { r: match[1], g: match[2], b: match[3] };
  }
  match = matchers.rgba.exec(color);
  if (match) {
    return { r: match[1], g: match[2], b: match[3], a: match[4] };
  }
  match = matchers.hsl.exec(color);
  if (match) {
    return { h: match[1], s: match[2], l: match[3] };
  }
  match = matchers.hsla.exec(color);
  if (match) {
    return { h: match[1], s: match[2], l: match[3], a: match[4] };
  }
  match = matchers.hsv.exec(color);
  if (match) {
    return { h: match[1], s: match[2], v: match[3] };
  }
  match = matchers.hsva.exec(color);
  if (match) {
    return { h: match[1], s: match[2], v: match[3], a: match[4] };
  }
  match = matchers.cmyk.exec(color);
  if (match) {
    return {
      c: match[1],
      m: match[2],
      y: match[3],
      k: match[4]
    };
  }
  match = matchers.hex8.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex6.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  match = matchers.hex4.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      a: convertHexToDecimal(match[4] + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex3.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit(color) {
  if (typeof color === "number") {
    return !Number.isNaN(color);
  }
  return matchers.CSS_UNIT.test(color);
}

// src/node_modules/@ctrl/tinycolor/dist/module/index.js
var TinyColor = class _TinyColor {
  constructor(color = "", opts = {}) {
    if (color instanceof _TinyColor) {
      return color;
    }
    if (typeof color === "number") {
      color = numberInputToObject(color);
    }
    this.originalInput = color;
    const rgb = inputToRGB(color);
    this.originalInput = color;
    this.r = rgb.r;
    this.g = rgb.g;
    this.b = rgb.b;
    this.a = rgb.a;
    this.roundA = Math.round(100 * this.a) / 100;
    this.format = opts.format ?? rgb.format;
    this.gradientType = opts.gradientType;
    if (this.r < 1) {
      this.r = Math.round(this.r);
    }
    if (this.g < 1) {
      this.g = Math.round(this.g);
    }
    if (this.b < 1) {
      this.b = Math.round(this.b);
    }
    this.isValid = rgb.ok;
  }
  isDark() {
    return this.getBrightness() < 128;
  }
  isLight() {
    return !this.isDark();
  }
  /**
   * Returns the perceived brightness of the color, from 0-255.
   */
  getBrightness() {
    const rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  }
  /**
   * Returns the perceived luminance of a color, from 0-1.
   */
  getLuminance() {
    const rgb = this.toRgb();
    let R3;
    let G4;
    let B3;
    const RsRGB = rgb.r / 255;
    const GsRGB = rgb.g / 255;
    const BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) {
      R3 = RsRGB / 12.92;
    } else {
      R3 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    }
    if (GsRGB <= 0.03928) {
      G4 = GsRGB / 12.92;
    } else {
      G4 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    }
    if (BsRGB <= 0.03928) {
      B3 = BsRGB / 12.92;
    } else {
      B3 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    }
    return 0.2126 * R3 + 0.7152 * G4 + 0.0722 * B3;
  }
  /**
   * Returns the alpha value of a color, from 0-1.
   */
  getAlpha() {
    return this.a;
  }
  /**
   * Sets the alpha value on the current color.
   *
   * @param alpha - The new alpha value. The accepted range is 0-1.
   */
  setAlpha(alpha) {
    this.a = boundAlpha(alpha);
    this.roundA = Math.round(100 * this.a) / 100;
    return this;
  }
  /**
   * Returns whether the color is monochrome.
   */
  isMonochrome() {
    const { s: s6 } = this.toHsl();
    return s6 === 0;
  }
  /**
   * Returns the object as a HSVA object.
   */
  toHsv() {
    const hsv = rgbToHsv(this.r, this.g, this.b);
    return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
  }
  /**
   * Returns the hsva values interpolated into a string with the following format:
   * "hsva(xxx, xxx, xxx, xx)".
   */
  toHsvString() {
    const hsv = rgbToHsv(this.r, this.g, this.b);
    const h5 = Math.round(hsv.h * 360);
    const s6 = Math.round(hsv.s * 100);
    const v3 = Math.round(hsv.v * 100);
    return this.a === 1 ? `hsv(${h5}, ${s6}%, ${v3}%)` : `hsva(${h5}, ${s6}%, ${v3}%, ${this.roundA})`;
  }
  /**
   * Returns the object as a HSLA object.
   */
  toHsl() {
    const hsl = rgbToHsl(this.r, this.g, this.b);
    return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
  }
  /**
   * Returns the hsla values interpolated into a string with the following format:
   * "hsla(xxx, xxx, xxx, xx)".
   */
  toHslString() {
    const hsl = rgbToHsl(this.r, this.g, this.b);
    const h5 = Math.round(hsl.h * 360);
    const s6 = Math.round(hsl.s * 100);
    const l3 = Math.round(hsl.l * 100);
    return this.a === 1 ? `hsl(${h5}, ${s6}%, ${l3}%)` : `hsla(${h5}, ${s6}%, ${l3}%, ${this.roundA})`;
  }
  /**
   * Returns the hex value of the color.
   * @param allow3Char will shorten hex value to 3 char if possible
   */
  toHex(allow3Char = false) {
    return rgbToHex(this.r, this.g, this.b, allow3Char);
  }
  /**
   * Returns the hex value of the color -with a # prefixed.
   * @param allow3Char will shorten hex value to 3 char if possible
   */
  toHexString(allow3Char = false) {
    return "#" + this.toHex(allow3Char);
  }
  /**
   * Returns the hex 8 value of the color.
   * @param allow4Char will shorten hex value to 4 char if possible
   */
  toHex8(allow4Char = false) {
    return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
  }
  /**
   * Returns the hex 8 value of the color -with a # prefixed.
   * @param allow4Char will shorten hex value to 4 char if possible
   */
  toHex8String(allow4Char = false) {
    return "#" + this.toHex8(allow4Char);
  }
  /**
   * Returns the shorter hex value of the color depends on its alpha -with a # prefixed.
   * @param allowShortChar will shorten hex value to 3 or 4 char if possible
   */
  toHexShortString(allowShortChar = false) {
    return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
  }
  /**
   * Returns the object as a RGBA object.
   */
  toRgb() {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a
    };
  }
  /**
   * Returns the RGBA values interpolated into a string with the following format:
   * "RGBA(xxx, xxx, xxx, xx)".
   */
  toRgbString() {
    const r9 = Math.round(this.r);
    const g3 = Math.round(this.g);
    const b3 = Math.round(this.b);
    return this.a === 1 ? `rgb(${r9}, ${g3}, ${b3})` : `rgba(${r9}, ${g3}, ${b3}, ${this.roundA})`;
  }
  /**
   * Returns the object as a RGBA object.
   */
  toPercentageRgb() {
    const fmt = (x4) => `${Math.round(bound01(x4, 255) * 100)}%`;
    return {
      r: fmt(this.r),
      g: fmt(this.g),
      b: fmt(this.b),
      a: this.a
    };
  }
  /**
   * Returns the RGBA relative values interpolated into a string
   */
  toPercentageRgbString() {
    const rnd = (x4) => Math.round(bound01(x4, 255) * 100);
    return this.a === 1 ? `rgb(${rnd(this.r)}%, ${rnd(this.g)}%, ${rnd(this.b)}%)` : `rgba(${rnd(this.r)}%, ${rnd(this.g)}%, ${rnd(this.b)}%, ${this.roundA})`;
  }
  toCmyk() {
    return {
      ...rgbToCmyk(this.r, this.g, this.b)
    };
  }
  toCmykString() {
    const { c: c6, m: m3, y: y3, k: k3 } = rgbToCmyk(this.r, this.g, this.b);
    return `cmyk(${c6}, ${m3}, ${y3}, ${k3})`;
  }
  /**
   * The 'real' name of the color -if there is one.
   */
  toName() {
    if (this.a === 0) {
      return "transparent";
    }
    if (this.a < 1) {
      return false;
    }
    const hex = "#" + rgbToHex(this.r, this.g, this.b, false);
    for (const [key, value] of Object.entries(names)) {
      if (hex === value) {
        return key;
      }
    }
    return false;
  }
  toString(format) {
    const formatSet = Boolean(format);
    format = format ?? this.format;
    let formattedString = false;
    const hasAlpha = this.a < 1 && this.a >= 0;
    const needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith("hex") || format === "name");
    if (needsAlphaFormat) {
      if (format === "name" && this.a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format === "hex" || format === "hex6") {
      formattedString = this.toHexString();
    }
    if (format === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format === "name") {
      formattedString = this.toName();
    }
    if (format === "hsl") {
      formattedString = this.toHslString();
    }
    if (format === "hsv") {
      formattedString = this.toHsvString();
    }
    if (format === "cmyk") {
      formattedString = this.toCmykString();
    }
    return formattedString || this.toHexString();
  }
  toNumber() {
    return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
  }
  clone() {
    return new _TinyColor(this.toString());
  }
  /**
   * Lighten the color a given amount. Providing 100 will always return white.
   * @param amount - valid between 1-100
   */
  lighten(amount = 10) {
    const hsl = this.toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return new _TinyColor(hsl);
  }
  /**
   * Brighten the color a given amount, from 0 to 100.
   * @param amount - valid between 1-100
   */
  brighten(amount = 10) {
    const rgb = this.toRgb();
    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
    return new _TinyColor(rgb);
  }
  /**
   * Darken the color a given amount, from 0 to 100.
   * Providing 100 will always return black.
   * @param amount - valid between 1-100
   */
  darken(amount = 10) {
    const hsl = this.toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return new _TinyColor(hsl);
  }
  /**
   * Mix the color with pure white, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return white.
   * @param amount - valid between 1-100
   */
  tint(amount = 10) {
    return this.mix("white", amount);
  }
  /**
   * Mix the color with pure black, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return black.
   * @param amount - valid between 1-100
   */
  shade(amount = 10) {
    return this.mix("black", amount);
  }
  /**
   * Desaturate the color a given amount, from 0 to 100.
   * Providing 100 will is the same as calling greyscale
   * @param amount - valid between 1-100
   */
  desaturate(amount = 10) {
    const hsl = this.toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return new _TinyColor(hsl);
  }
  /**
   * Saturate the color a given amount, from 0 to 100.
   * @param amount - valid between 1-100
   */
  saturate(amount = 10) {
    const hsl = this.toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return new _TinyColor(hsl);
  }
  /**
   * Completely desaturates a color into greyscale.
   * Same as calling `desaturate(100)`
   */
  greyscale() {
    return this.desaturate(100);
  }
  /**
   * Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
   * Values outside of this range will be wrapped into this range.
   */
  spin(amount) {
    const hsl = this.toHsl();
    const hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return new _TinyColor(hsl);
  }
  /**
   * Mix the current color a given amount with another color, from 0 to 100.
   * 0 means no mixing (return current color).
   */
  mix(color, amount = 50) {
    const rgb1 = this.toRgb();
    const rgb2 = new _TinyColor(color).toRgb();
    const p3 = amount / 100;
    const rgba = {
      r: (rgb2.r - rgb1.r) * p3 + rgb1.r,
      g: (rgb2.g - rgb1.g) * p3 + rgb1.g,
      b: (rgb2.b - rgb1.b) * p3 + rgb1.b,
      a: (rgb2.a - rgb1.a) * p3 + rgb1.a
    };
    return new _TinyColor(rgba);
  }
  analogous(results = 6, slices = 30) {
    const hsl = this.toHsl();
    const part = 360 / slices;
    const ret = [this];
    for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
      hsl.h = (hsl.h + part) % 360;
      ret.push(new _TinyColor(hsl));
    }
    return ret;
  }
  /**
   * taken from https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js
   */
  complement() {
    const hsl = this.toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return new _TinyColor(hsl);
  }
  monochromatic(results = 6) {
    const hsv = this.toHsv();
    const { h: h5 } = hsv;
    const { s: s6 } = hsv;
    let { v: v3 } = hsv;
    const res = [];
    const modification = 1 / results;
    while (results--) {
      res.push(new _TinyColor({ h: h5, s: s6, v: v3 }));
      v3 = (v3 + modification) % 1;
    }
    return res;
  }
  splitcomplement() {
    const hsl = this.toHsl();
    const { h: h5 } = hsl;
    return [
      this,
      new _TinyColor({ h: (h5 + 72) % 360, s: hsl.s, l: hsl.l }),
      new _TinyColor({ h: (h5 + 216) % 360, s: hsl.s, l: hsl.l })
    ];
  }
  /**
   * Compute how the color would appear on a background
   */
  onBackground(background) {
    const fg = this.toRgb();
    const bg = new _TinyColor(background).toRgb();
    const alpha = fg.a + bg.a * (1 - fg.a);
    return new _TinyColor({
      r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
      g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
      b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
      a: alpha
    });
  }
  /**
   * Alias for `polyad(3)`
   */
  triad() {
    return this.polyad(3);
  }
  /**
   * Alias for `polyad(4)`
   */
  tetrad() {
    return this.polyad(4);
  }
  /**
   * Get polyad colors, like (for 1, 2, 3, 4, 5, 6, 7, 8, etc...)
   * monad, dyad, triad, tetrad, pentad, hexad, heptad, octad, etc...
   */
  polyad(n7) {
    const hsl = this.toHsl();
    const { h: h5 } = hsl;
    const result = [this];
    const increment = 360 / n7;
    for (let i5 = 1; i5 < n7; i5++) {
      result.push(new _TinyColor({ h: (h5 + i5 * increment) % 360, s: hsl.s, l: hsl.l }));
    }
    return result;
  }
  /**
   * compare color vs current color
   */
  equals(color) {
    const comparedColor = new _TinyColor(color);
    if (this.format === "cmyk" || comparedColor.format === "cmyk") {
      return this.toCmykString() === comparedColor.toCmykString();
    }
    return this.toRgbString() === comparedColor.toRgbString();
  }
};

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LEM2USYI.js
var hasEyeDropper = "EyeDropper" in window;
var SlColorPicker = class extends ShoelaceElement {
  constructor() {
    super();
    this.formControlController = new FormControlController(this);
    this.isSafeValue = false;
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.isDraggingGridHandle = false;
    this.isEmpty = false;
    this.inputValue = "";
    this.hue = 0;
    this.saturation = 100;
    this.brightness = 100;
    this.alpha = 100;
    this.value = "";
    this.defaultValue = "";
    this.label = "";
    this.format = "hex";
    this.inline = false;
    this.size = "medium";
    this.noFormatToggle = false;
    this.name = "";
    this.disabled = false;
    this.hoist = false;
    this.opacity = false;
    this.uppercase = false;
    this.swatches = "";
    this.form = "";
    this.required = false;
    this.handleFocusIn = () => {
      this.hasFocus = true;
      this.emit("sl-focus");
    };
    this.handleFocusOut = () => {
      this.hasFocus = false;
      this.emit("sl-blur");
    };
    this.addEventListener("focusin", this.handleFocusIn);
    this.addEventListener("focusout", this.handleFocusOut);
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.input.updateComplete.then(() => {
      this.formControlController.updateValidity();
    });
  }
  handleCopy() {
    this.input.select();
    document.execCommand("copy");
    this.previewButton.focus();
    this.previewButton.classList.add("color-picker__preview-color--copied");
    this.previewButton.addEventListener("animationend", () => {
      this.previewButton.classList.remove("color-picker__preview-color--copied");
    });
  }
  handleFormatToggle() {
    const formats = ["hex", "rgb", "hsl", "hsv"];
    const nextIndex = (formats.indexOf(this.format) + 1) % formats.length;
    this.format = formats[nextIndex];
    this.setColor(this.value);
    this.emit("sl-change");
    this.emit("sl-input");
  }
  handleAlphaDrag(event) {
    const container = this.shadowRoot.querySelector(".color-picker__slider.color-picker__alpha");
    const handle = container.querySelector(".color-picker__slider-handle");
    const { width } = container.getBoundingClientRect();
    let initialValue = this.value;
    let currentValue = this.value;
    handle.focus();
    event.preventDefault();
    drag(container, {
      onMove: (x4) => {
        this.alpha = clamp2(x4 / width * 100, 0, 100);
        this.syncValues();
        if (this.value !== currentValue) {
          currentValue = this.value;
          this.emit("sl-input");
        }
      },
      onStop: () => {
        if (this.value !== initialValue) {
          initialValue = this.value;
          this.emit("sl-change");
        }
      },
      initialEvent: event
    });
  }
  handleHueDrag(event) {
    const container = this.shadowRoot.querySelector(".color-picker__slider.color-picker__hue");
    const handle = container.querySelector(".color-picker__slider-handle");
    const { width } = container.getBoundingClientRect();
    let initialValue = this.value;
    let currentValue = this.value;
    handle.focus();
    event.preventDefault();
    drag(container, {
      onMove: (x4) => {
        this.hue = clamp2(x4 / width * 360, 0, 360);
        this.syncValues();
        if (this.value !== currentValue) {
          currentValue = this.value;
          this.emit("sl-input");
        }
      },
      onStop: () => {
        if (this.value !== initialValue) {
          initialValue = this.value;
          this.emit("sl-change");
        }
      },
      initialEvent: event
    });
  }
  handleGridDrag(event) {
    const grid = this.shadowRoot.querySelector(".color-picker__grid");
    const handle = grid.querySelector(".color-picker__grid-handle");
    const { width, height } = grid.getBoundingClientRect();
    let initialValue = this.value;
    let currentValue = this.value;
    handle.focus();
    event.preventDefault();
    this.isDraggingGridHandle = true;
    drag(grid, {
      onMove: (x4, y3) => {
        this.saturation = clamp2(x4 / width * 100, 0, 100);
        this.brightness = clamp2(100 - y3 / height * 100, 0, 100);
        this.syncValues();
        if (this.value !== currentValue) {
          currentValue = this.value;
          this.emit("sl-input");
        }
      },
      onStop: () => {
        this.isDraggingGridHandle = false;
        if (this.value !== initialValue) {
          initialValue = this.value;
          this.emit("sl-change");
        }
      },
      initialEvent: event
    });
  }
  handleAlphaKeyDown(event) {
    const increment = event.shiftKey ? 10 : 1;
    const oldValue = this.value;
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      this.alpha = clamp2(this.alpha - increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      this.alpha = clamp2(this.alpha + increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "Home") {
      event.preventDefault();
      this.alpha = 0;
      this.syncValues();
    }
    if (event.key === "End") {
      event.preventDefault();
      this.alpha = 100;
      this.syncValues();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleHueKeyDown(event) {
    const increment = event.shiftKey ? 10 : 1;
    const oldValue = this.value;
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      this.hue = clamp2(this.hue - increment, 0, 360);
      this.syncValues();
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      this.hue = clamp2(this.hue + increment, 0, 360);
      this.syncValues();
    }
    if (event.key === "Home") {
      event.preventDefault();
      this.hue = 0;
      this.syncValues();
    }
    if (event.key === "End") {
      event.preventDefault();
      this.hue = 360;
      this.syncValues();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleGridKeyDown(event) {
    const increment = event.shiftKey ? 10 : 1;
    const oldValue = this.value;
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      this.saturation = clamp2(this.saturation - increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      this.saturation = clamp2(this.saturation + increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      this.brightness = clamp2(this.brightness + increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "ArrowDown") {
      event.preventDefault();
      this.brightness = clamp2(this.brightness - increment, 0, 100);
      this.syncValues();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleInputChange(event) {
    const target = event.target;
    const oldValue = this.value;
    event.stopPropagation();
    if (this.input.value) {
      this.setColor(target.value);
      target.value = this.value;
    } else {
      this.value = "";
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleInputInput(event) {
    this.formControlController.updateValidity();
    event.stopPropagation();
  }
  handleInputKeyDown(event) {
    if (event.key === "Enter") {
      const oldValue = this.value;
      if (this.input.value) {
        this.setColor(this.input.value);
        this.input.value = this.value;
        if (this.value !== oldValue) {
          this.emit("sl-change");
          this.emit("sl-input");
        }
        setTimeout(() => this.input.select());
      } else {
        this.hue = 0;
      }
    }
  }
  handleInputInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleTouchMove(event) {
    event.preventDefault();
  }
  parseColor(colorString) {
    const color = new TinyColor(colorString);
    if (!color.isValid) {
      return null;
    }
    const hslColor = color.toHsl();
    const hsl = {
      h: hslColor.h,
      s: hslColor.s * 100,
      l: hslColor.l * 100,
      a: hslColor.a
    };
    const rgb = color.toRgb();
    const hex = color.toHexString();
    const hexa = color.toHex8String();
    const hsvColor = color.toHsv();
    const hsv = {
      h: hsvColor.h,
      s: hsvColor.s * 100,
      v: hsvColor.v * 100,
      a: hsvColor.a
    };
    return {
      hsl: {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        string: this.setLetterCase(`hsl(${Math.round(hsl.h)}, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%)`)
      },
      hsla: {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: hsl.a,
        string: this.setLetterCase(
          `hsla(${Math.round(hsl.h)}, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%, ${hsl.a.toFixed(2).toString()})`
        )
      },
      hsv: {
        h: hsv.h,
        s: hsv.s,
        v: hsv.v,
        string: this.setLetterCase(`hsv(${Math.round(hsv.h)}, ${Math.round(hsv.s)}%, ${Math.round(hsv.v)}%)`)
      },
      hsva: {
        h: hsv.h,
        s: hsv.s,
        v: hsv.v,
        a: hsv.a,
        string: this.setLetterCase(
          `hsva(${Math.round(hsv.h)}, ${Math.round(hsv.s)}%, ${Math.round(hsv.v)}%, ${hsv.a.toFixed(2).toString()})`
        )
      },
      rgb: {
        r: rgb.r,
        g: rgb.g,
        b: rgb.b,
        string: this.setLetterCase(`rgb(${Math.round(rgb.r)}, ${Math.round(rgb.g)}, ${Math.round(rgb.b)})`)
      },
      rgba: {
        r: rgb.r,
        g: rgb.g,
        b: rgb.b,
        a: rgb.a,
        string: this.setLetterCase(
          `rgba(${Math.round(rgb.r)}, ${Math.round(rgb.g)}, ${Math.round(rgb.b)}, ${rgb.a.toFixed(2).toString()})`
        )
      },
      hex: this.setLetterCase(hex),
      hexa: this.setLetterCase(hexa)
    };
  }
  setColor(colorString) {
    const newColor = this.parseColor(colorString);
    if (newColor === null) {
      return false;
    }
    this.hue = newColor.hsva.h;
    this.saturation = newColor.hsva.s;
    this.brightness = newColor.hsva.v;
    this.alpha = this.opacity ? newColor.hsva.a * 100 : 100;
    this.syncValues();
    return true;
  }
  setLetterCase(string) {
    if (typeof string !== "string") {
      return "";
    }
    return this.uppercase ? string.toUpperCase() : string.toLowerCase();
  }
  async syncValues() {
    const currentColor = this.parseColor(
      `hsva(${this.hue}, ${this.saturation}%, ${this.brightness}%, ${this.alpha / 100})`
    );
    if (currentColor === null) {
      return;
    }
    if (this.format === "hsl") {
      this.inputValue = this.opacity ? currentColor.hsla.string : currentColor.hsl.string;
    } else if (this.format === "rgb") {
      this.inputValue = this.opacity ? currentColor.rgba.string : currentColor.rgb.string;
    } else if (this.format === "hsv") {
      this.inputValue = this.opacity ? currentColor.hsva.string : currentColor.hsv.string;
    } else {
      this.inputValue = this.opacity ? currentColor.hexa : currentColor.hex;
    }
    this.isSafeValue = true;
    this.value = this.inputValue;
    await this.updateComplete;
    this.isSafeValue = false;
  }
  handleAfterHide() {
    this.previewButton.classList.remove("color-picker__preview-color--copied");
  }
  handleEyeDropper() {
    if (!hasEyeDropper) {
      return;
    }
    const eyeDropper = new EyeDropper();
    eyeDropper.open().then((colorSelectionResult) => {
      const oldValue = this.value;
      this.setColor(colorSelectionResult.sRGBHex);
      if (this.value !== oldValue) {
        this.emit("sl-change");
        this.emit("sl-input");
      }
    }).catch(() => {
    });
  }
  selectSwatch(color) {
    const oldValue = this.value;
    if (!this.disabled) {
      this.setColor(color);
      if (this.value !== oldValue) {
        this.emit("sl-change");
        this.emit("sl-input");
      }
    }
  }
  /** Generates a hex string from HSV values. Hue must be 0-360. All other arguments must be 0-100. */
  getHexString(hue, saturation, brightness, alpha = 100) {
    const color = new TinyColor(`hsva(${hue}, ${saturation}%, ${brightness}%, ${alpha / 100})`);
    if (!color.isValid) {
      return "";
    }
    return color.toHex8String();
  }
  // Prevents nested components from leaking events
  stopNestedEventPropagation(event) {
    event.stopImmediatePropagation();
  }
  handleFormatChange() {
    this.syncValues();
  }
  handleOpacityChange() {
    this.alpha = 100;
  }
  handleValueChange(oldValue, newValue) {
    this.isEmpty = !newValue;
    if (!newValue) {
      this.hue = 0;
      this.saturation = 0;
      this.brightness = 100;
      this.alpha = 100;
    }
    if (!this.isSafeValue) {
      const newColor = this.parseColor(newValue);
      if (newColor !== null) {
        this.inputValue = this.value;
        this.hue = newColor.hsva.h;
        this.saturation = newColor.hsva.s;
        this.brightness = newColor.hsva.v;
        this.alpha = newColor.hsva.a * 100;
        this.syncValues();
      } else {
        this.inputValue = oldValue != null ? oldValue : "";
      }
    }
  }
  /** Sets focus on the color picker. */
  focus(options) {
    if (this.inline) {
      this.base.focus(options);
    } else {
      this.trigger.focus(options);
    }
  }
  /** Removes focus from the color picker. */
  blur() {
    var _a24;
    const elementToBlur = this.inline ? this.base : this.trigger;
    if (this.hasFocus) {
      elementToBlur.focus({ preventScroll: true });
      elementToBlur.blur();
    }
    if ((_a24 = this.dropdown) == null ? void 0 : _a24.open) {
      this.dropdown.hide();
    }
  }
  /** Returns the current value as a string in the specified format. */
  getFormattedValue(format = "hex") {
    const currentColor = this.parseColor(
      `hsva(${this.hue}, ${this.saturation}%, ${this.brightness}%, ${this.alpha / 100})`
    );
    if (currentColor === null) {
      return "";
    }
    switch (format) {
      case "hex":
        return currentColor.hex;
      case "hexa":
        return currentColor.hexa;
      case "rgb":
        return currentColor.rgb.string;
      case "rgba":
        return currentColor.rgba.string;
      case "hsl":
        return currentColor.hsl.string;
      case "hsla":
        return currentColor.hsla.string;
      case "hsv":
        return currentColor.hsv.string;
      case "hsva":
        return currentColor.hsva.string;
      default:
        return "";
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    if (!this.inline && !this.validity.valid) {
      this.dropdown.show();
      this.addEventListener("sl-after-show", () => this.input.reportValidity(), { once: true });
      if (!this.disabled) {
        this.formControlController.emitInvalidEvent();
      }
      return false;
    }
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const gridHandleX = this.saturation;
    const gridHandleY = 100 - this.brightness;
    const swatches = Array.isArray(this.swatches) ? this.swatches : this.swatches.split(";").filter((color) => color.trim() !== "");
    const colorPicker = ke`
      <div
        part="base"
        class=${Rt({
      "color-picker": true,
      "color-picker--inline": this.inline,
      "color-picker--disabled": this.disabled,
      "color-picker--focused": this.hasFocus
    })}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-labelledby="label"
        tabindex=${this.inline ? "0" : "-1"}
      >
        ${this.inline ? ke`
              <sl-visually-hidden id="label">
                <slot name="label">${this.label}</slot>
              </sl-visually-hidden>
            ` : null}

        <div
          part="grid"
          class="color-picker__grid"
          style=${se({ backgroundColor: this.getHexString(this.hue, 100, 100) })}
          @pointerdown=${this.handleGridDrag}
          @touchmove=${this.handleTouchMove}
        >
          <span
            part="grid-handle"
            class=${Rt({
      "color-picker__grid-handle": true,
      "color-picker__grid-handle--dragging": this.isDraggingGridHandle
    })}
            style=${se({
      top: `${gridHandleY}%`,
      left: `${gridHandleX}%`,
      backgroundColor: this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
    })}
            role="application"
            aria-label="HSV"
            tabindex=${to(this.disabled ? void 0 : "0")}
            @keydown=${this.handleGridKeyDown}
          ></span>
        </div>

        <div class="color-picker__controls">
          <div class="color-picker__sliders">
            <div
              part="slider hue-slider"
              class="color-picker__hue color-picker__slider"
              @pointerdown=${this.handleHueDrag}
              @touchmove=${this.handleTouchMove}
            >
              <span
                part="slider-handle hue-slider-handle"
                class="color-picker__slider-handle"
                style=${se({
      left: `${this.hue === 0 ? 0 : 100 / (360 / this.hue)}%`
    })}
                role="slider"
                aria-label="hue"
                aria-orientation="horizontal"
                aria-valuemin="0"
                aria-valuemax="360"
                aria-valuenow=${`${Math.round(this.hue)}`}
                tabindex=${to(this.disabled ? void 0 : "0")}
                @keydown=${this.handleHueKeyDown}
              ></span>
            </div>

            ${this.opacity ? ke`
                  <div
                    part="slider opacity-slider"
                    class="color-picker__alpha color-picker__slider color-picker__transparent-bg"
                    @pointerdown="${this.handleAlphaDrag}"
                    @touchmove=${this.handleTouchMove}
                  >
                    <div
                      class="color-picker__alpha-gradient"
                      style=${se({
      backgroundImage: `linear-gradient(
                          to right,
                          ${this.getHexString(this.hue, this.saturation, this.brightness, 0)} 0%,
                          ${this.getHexString(this.hue, this.saturation, this.brightness, 100)} 100%
                        )`
    })}
                    ></div>
                    <span
                      part="slider-handle opacity-slider-handle"
                      class="color-picker__slider-handle"
                      style=${se({
      left: `${this.alpha}%`
    })}
                      role="slider"
                      aria-label="alpha"
                      aria-orientation="horizontal"
                      aria-valuemin="0"
                      aria-valuemax="100"
                      aria-valuenow=${Math.round(this.alpha)}
                      tabindex=${to(this.disabled ? void 0 : "0")}
                      @keydown=${this.handleAlphaKeyDown}
                    ></span>
                  </div>
                ` : ""}
          </div>

          <button
            type="button"
            part="preview"
            class="color-picker__preview color-picker__transparent-bg"
            aria-label=${this.localize.term("copy")}
            style=${se({
      "--preview-color": this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
    })}
            @click=${this.handleCopy}
          ></button>
        </div>

        <div class="color-picker__user-input" aria-live="polite">
          <sl-input
            part="input"
            type="text"
            name=${this.name}
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
            value=${this.isEmpty ? "" : this.inputValue}
            ?required=${this.required}
            ?disabled=${this.disabled}
            aria-label=${this.localize.term("currentValue")}
            @keydown=${this.handleInputKeyDown}
            @sl-change=${this.handleInputChange}
            @sl-input=${this.handleInputInput}
            @sl-invalid=${this.handleInputInvalid}
            @sl-blur=${this.stopNestedEventPropagation}
            @sl-focus=${this.stopNestedEventPropagation}
          ></sl-input>

          <sl-button-group>
            ${!this.noFormatToggle ? ke`
                  <sl-button
                    part="format-button"
                    aria-label=${this.localize.term("toggleColorFormat")}
                    exportparts="
                      base:format-button__base,
                      prefix:format-button__prefix,
                      label:format-button__label,
                      suffix:format-button__suffix,
                      caret:format-button__caret
                    "
                    @click=${this.handleFormatToggle}
                    @sl-blur=${this.stopNestedEventPropagation}
                    @sl-focus=${this.stopNestedEventPropagation}
                  >
                    ${this.setLetterCase(this.format)}
                  </sl-button>
                ` : ""}
            ${hasEyeDropper ? ke`
                  <sl-button
                    part="eye-dropper-button"
                    exportparts="
                      base:eye-dropper-button__base,
                      prefix:eye-dropper-button__prefix,
                      label:eye-dropper-button__label,
                      suffix:eye-dropper-button__suffix,
                      caret:eye-dropper-button__caret
                    "
                    @click=${this.handleEyeDropper}
                    @sl-blur=${this.stopNestedEventPropagation}
                    @sl-focus=${this.stopNestedEventPropagation}
                  >
                    <sl-icon
                      library="system"
                      name="eyedropper"
                      label=${this.localize.term("selectAColorFromTheScreen")}
                    ></sl-icon>
                  </sl-button>
                ` : ""}
          </sl-button-group>
        </div>

        ${swatches.length > 0 ? ke`
              <div part="swatches" class="color-picker__swatches">
                ${swatches.map((swatch) => {
      const parsedColor = this.parseColor(swatch);
      if (!parsedColor) {
        console.error(`Unable to parse swatch color: "${swatch}"`, this);
        return "";
      }
      return ke`
                    <div
                      part="swatch"
                      class="color-picker__swatch color-picker__transparent-bg"
                      tabindex=${to(this.disabled ? void 0 : "0")}
                      role="button"
                      aria-label=${swatch}
                      @click=${() => this.selectSwatch(swatch)}
                      @keydown=${(event) => !this.disabled && event.key === "Enter" && this.setColor(parsedColor.hexa)}
                    >
                      <div
                        class="color-picker__swatch-color"
                        style=${se({ backgroundColor: parsedColor.hexa })}
                      ></div>
                    </div>
                  `;
    })}
              </div>
            ` : ""}
      </div>
    `;
    if (this.inline) {
      return colorPicker;
    }
    return ke`
      <sl-dropdown
        class="color-dropdown"
        aria-disabled=${this.disabled ? "true" : "false"}
        .containing-element=${this}
        ?disabled=${this.disabled}
        ?hoist=${this.hoist}
        @sl-after-hide=${this.handleAfterHide}
      >
        <button
          part="trigger"
          slot="trigger"
          class=${Rt({
      "color-dropdown__trigger": true,
      "color-dropdown__trigger--disabled": this.disabled,
      "color-dropdown__trigger--small": this.size === "small",
      "color-dropdown__trigger--medium": this.size === "medium",
      "color-dropdown__trigger--large": this.size === "large",
      "color-dropdown__trigger--empty": this.isEmpty,
      "color-dropdown__trigger--focused": this.hasFocus,
      "color-picker__transparent-bg": true
    })}
          style=${se({
      color: this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
    })}
          type="button"
        >
          <sl-visually-hidden>
            <slot name="label">${this.label}</slot>
          </sl-visually-hidden>
        </button>
        ${colorPicker}
      </sl-dropdown>
    `;
  }
};
SlColorPicker.styles = [component_styles_default, color_picker_styles_default];
SlColorPicker.dependencies = {
  "sl-button-group": SlButtonGroup,
  "sl-button": SlButton,
  "sl-dropdown": SlDropdown,
  "sl-icon": SlIcon,
  "sl-input": SlInput,
  "sl-visually-hidden": SlVisuallyHidden
};
__decorateClass([
  e7('[part~="base"]')
], SlColorPicker.prototype, "base", 2);
__decorateClass([
  e7('[part~="input"]')
], SlColorPicker.prototype, "input", 2);
__decorateClass([
  e7(".color-dropdown")
], SlColorPicker.prototype, "dropdown", 2);
__decorateClass([
  e7('[part~="preview"]')
], SlColorPicker.prototype, "previewButton", 2);
__decorateClass([
  e7('[part~="trigger"]')
], SlColorPicker.prototype, "trigger", 2);
__decorateClass([
  r5()
], SlColorPicker.prototype, "hasFocus", 2);
__decorateClass([
  r5()
], SlColorPicker.prototype, "isDraggingGridHandle", 2);
__decorateClass([
  r5()
], SlColorPicker.prototype, "isEmpty", 2);
__decorateClass([
  r5()
], SlColorPicker.prototype, "inputValue", 2);
__decorateClass([
  r5()
], SlColorPicker.prototype, "hue", 2);
__decorateClass([
  r5()
], SlColorPicker.prototype, "saturation", 2);
__decorateClass([
  r5()
], SlColorPicker.prototype, "brightness", 2);
__decorateClass([
  r5()
], SlColorPicker.prototype, "alpha", 2);
__decorateClass([
  n6()
], SlColorPicker.prototype, "value", 2);
__decorateClass([
  defaultValue()
], SlColorPicker.prototype, "defaultValue", 2);
__decorateClass([
  n6()
], SlColorPicker.prototype, "label", 2);
__decorateClass([
  n6()
], SlColorPicker.prototype, "format", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlColorPicker.prototype, "inline", 2);
__decorateClass([
  n6({ reflect: true })
], SlColorPicker.prototype, "size", 2);
__decorateClass([
  n6({ attribute: "no-format-toggle", type: Boolean })
], SlColorPicker.prototype, "noFormatToggle", 2);
__decorateClass([
  n6()
], SlColorPicker.prototype, "name", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlColorPicker.prototype, "disabled", 2);
__decorateClass([
  n6({ type: Boolean })
], SlColorPicker.prototype, "hoist", 2);
__decorateClass([
  n6({ type: Boolean })
], SlColorPicker.prototype, "opacity", 2);
__decorateClass([
  n6({ type: Boolean })
], SlColorPicker.prototype, "uppercase", 2);
__decorateClass([
  n6()
], SlColorPicker.prototype, "swatches", 2);
__decorateClass([
  n6({ reflect: true })
], SlColorPicker.prototype, "form", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlColorPicker.prototype, "required", 2);
__decorateClass([
  watch("format", { waitUntilFirstUpdate: true })
], SlColorPicker.prototype, "handleFormatChange", 1);
__decorateClass([
  watch("opacity", { waitUntilFirstUpdate: true })
], SlColorPicker.prototype, "handleOpacityChange", 1);
__decorateClass([
  watch("value")
], SlColorPicker.prototype, "handleValueChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.PITOWMX7.js
var color_picker_default = SlColorPicker;
SlColorPicker.define("sl-color-picker");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.A5D6FTFY.js
var card_styles_default = i`
  :host {
    --border-color: var(--sl-color-neutral-200);
    --border-radius: var(--sl-border-radius-medium);
    --border-width: 1px;
    --padding: var(--sl-spacing-large);

    display: inline-block;
  }

  .card {
    display: flex;
    flex-direction: column;
    background-color: var(--sl-panel-background-color);
    box-shadow: var(--sl-shadow-x-small);
    border: solid var(--border-width) var(--border-color);
    border-radius: var(--border-radius);
  }

  .card__image {
    display: flex;
    border-top-left-radius: var(--border-radius);
    border-top-right-radius: var(--border-radius);
    margin: calc(-1 * var(--border-width));
    overflow: hidden;
  }

  .card__image::slotted(img) {
    display: block;
    width: 100%;
  }

  .card:not(.card--has-image) .card__image {
    display: none;
  }

  .card__header {
    display: block;
    border-bottom: solid var(--border-width) var(--border-color);
    padding: calc(var(--padding) / 2) var(--padding);
  }

  .card:not(.card--has-header) .card__header {
    display: none;
  }

  .card:not(.card--has-image) .card__header {
    border-top-left-radius: var(--border-radius);
    border-top-right-radius: var(--border-radius);
  }

  .card__body {
    display: block;
    padding: var(--padding);
  }

  .card--has-footer .card__footer {
    display: block;
    border-top: solid var(--border-width) var(--border-color);
    padding: var(--padding);
  }

  .card:not(.card--has-footer) .card__footer {
    display: none;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.R7FSHAR5.js
var SlCard = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "footer", "header", "image");
  }
  render() {
    return ke`
      <div
        part="base"
        class=${Rt({
      card: true,
      "card--has-footer": this.hasSlotController.test("footer"),
      "card--has-image": this.hasSlotController.test("image"),
      "card--has-header": this.hasSlotController.test("header")
    })}
      >
        <slot name="image" part="image" class="card__image"></slot>
        <slot name="header" part="header" class="card__header"></slot>
        <slot part="body" class="card__body"></slot>
        <slot name="footer" part="footer" class="card__footer"></slot>
      </div>
    `;
  }
};
SlCard.styles = [component_styles_default, card_styles_default];

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.QPAJFFLD.js
SlCard.define("sl-card");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.F4VGSDIW.js
var AutoplayController = class {
  constructor(host, tickCallback) {
    this.timerId = 0;
    this.activeInteractions = 0;
    this.paused = false;
    this.stopped = true;
    this.pause = () => {
      if (!this.activeInteractions++) {
        this.paused = true;
        this.host.requestUpdate();
      }
    };
    this.resume = () => {
      if (!--this.activeInteractions) {
        this.paused = false;
        this.host.requestUpdate();
      }
    };
    host.addController(this);
    this.host = host;
    this.tickCallback = tickCallback;
  }
  hostConnected() {
    this.host.addEventListener("mouseenter", this.pause);
    this.host.addEventListener("mouseleave", this.resume);
    this.host.addEventListener("focusin", this.pause);
    this.host.addEventListener("focusout", this.resume);
    this.host.addEventListener("touchstart", this.pause, { passive: true });
    this.host.addEventListener("touchend", this.resume);
  }
  hostDisconnected() {
    this.stop();
    this.host.removeEventListener("mouseenter", this.pause);
    this.host.removeEventListener("mouseleave", this.resume);
    this.host.removeEventListener("focusin", this.pause);
    this.host.removeEventListener("focusout", this.resume);
    this.host.removeEventListener("touchstart", this.pause);
    this.host.removeEventListener("touchend", this.resume);
  }
  start(interval) {
    this.stop();
    this.stopped = false;
    this.timerId = window.setInterval(() => {
      if (!this.paused) {
        this.tickCallback();
      }
    }, interval);
  }
  stop() {
    clearInterval(this.timerId);
    this.stopped = true;
    this.host.requestUpdate();
  }
};

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.BMOWACWC.js
var carousel_styles_default = i`
  :host {
    --slide-gap: var(--sl-spacing-medium, 1rem);
    --aspect-ratio: 16 / 9;
    --scroll-hint: 0px;

    display: flex;
  }

  .carousel {
    display: grid;
    grid-template-columns: min-content 1fr min-content;
    grid-template-rows: 1fr min-content;
    grid-template-areas:
      '. slides .'
      '. pagination .';
    gap: var(--sl-spacing-medium);
    align-items: center;
    min-height: 100%;
    min-width: 100%;
    position: relative;
  }

  .carousel__pagination {
    grid-area: pagination;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: var(--sl-spacing-small);
  }

  .carousel__slides {
    grid-area: slides;

    display: grid;
    height: 100%;
    width: 100%;
    align-items: center;
    justify-items: center;
    overflow: auto;
    overscroll-behavior-x: contain;
    scrollbar-width: none;
    aspect-ratio: calc(var(--aspect-ratio) * var(--slides-per-page));
    border-radius: var(--sl-border-radius-small);

    --slide-size: calc((100% - (var(--slides-per-page) - 1) * var(--slide-gap)) / var(--slides-per-page));
  }

  @media (prefers-reduced-motion) {
    :where(.carousel__slides) {
      scroll-behavior: auto;
    }
  }

  .carousel__slides--horizontal {
    grid-auto-flow: column;
    grid-auto-columns: var(--slide-size);
    grid-auto-rows: 100%;
    column-gap: var(--slide-gap);
    scroll-snap-type: x mandatory;
    scroll-padding-inline: var(--scroll-hint);
    padding-inline: var(--scroll-hint);
    overflow-y: hidden;
  }

  .carousel__slides--vertical {
    grid-auto-flow: row;
    grid-auto-columns: 100%;
    grid-auto-rows: var(--slide-size);
    row-gap: var(--slide-gap);
    scroll-snap-type: y mandatory;
    scroll-padding-block: var(--scroll-hint);
    padding-block: var(--scroll-hint);
    overflow-x: hidden;
  }

  .carousel__slides--dragging {
  }

  :host([vertical]) ::slotted(sl-carousel-item) {
    height: 100%;
  }

  .carousel__slides::-webkit-scrollbar {
    display: none;
  }

  .carousel__navigation {
    grid-area: navigation;
    display: contents;
    font-size: var(--sl-font-size-x-large);
  }

  .carousel__navigation-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-small);
    font-size: inherit;
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-medium) color;
    appearance: none;
  }

  .carousel__navigation-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .carousel__navigation-button--disabled::part(base) {
    pointer-events: none;
  }

  .carousel__navigation-button--previous {
    grid-column: 1;
    grid-row: 1;
  }

  .carousel__navigation-button--next {
    grid-column: 3;
    grid-row: 1;
  }

  .carousel__pagination-item {
    display: block;
    cursor: pointer;
    background: none;
    border: 0;
    border-radius: var(--sl-border-radius-circle);
    width: var(--sl-spacing-small);
    height: var(--sl-spacing-small);
    background-color: var(--sl-color-neutral-300);
    padding: 0;
    margin: 0;
  }

  .carousel__pagination-item--active {
    background-color: var(--sl-color-neutral-700);
    transform: scale(1.2);
  }

  /* Focus styles */
  .carousel__slides:focus-visible,
  .carousel__navigation-button:focus-visible,
  .carousel__pagination-item:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }
`;

// src/node_modules/lit-html/directives/map.js
function* oo(o7, f5) {
  if (void 0 !== o7) {
    let i5 = 0;
    for (const t8 of o7) yield f5(t8, i5++);
  }
}

// src/node_modules/lit-html/directives/range.js
function* oo2(o7, t8, e10 = 1) {
  const i5 = void 0 === t8 ? 0 : o7;
  t8 ??= o7;
  for (let o8 = i5; e10 > 0 ? o8 < t8 : t8 < o8; o8 += e10) yield o8;
}

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.OGQPJ5RG.js
var debounce = (fn, delay) => {
  let timerId = 0;
  return function(...args) {
    window.clearTimeout(timerId);
    timerId = window.setTimeout(() => {
      fn.call(this, ...args);
    }, delay);
  };
};
var decorate = (proto, method, decorateFn) => {
  const superFn = proto[method];
  proto[method] = function(...args) {
    superFn.call(this, ...args);
    decorateFn.call(this, superFn, ...args);
  };
};
var isSupported = "onscrollend" in window;
if (!isSupported) {
  const pointers = /* @__PURE__ */ new Set();
  const scrollHandlers = /* @__PURE__ */ new WeakMap();
  const handlePointerDown = (event) => {
    for (const touch of event.changedTouches) {
      pointers.add(touch.identifier);
    }
  };
  const handlePointerUp = (event) => {
    for (const touch of event.changedTouches) {
      pointers.delete(touch.identifier);
    }
  };
  document.addEventListener("touchstart", handlePointerDown, true);
  document.addEventListener("touchend", handlePointerUp, true);
  document.addEventListener("touchcancel", handlePointerUp, true);
  decorate(EventTarget.prototype, "addEventListener", function(addEventListener, type) {
    if (type !== "scrollend")
      return;
    const handleScrollEnd = debounce(() => {
      if (!pointers.size) {
        this.dispatchEvent(new Event("scrollend"));
      } else {
        handleScrollEnd();
      }
    }, 100);
    addEventListener.call(this, "scroll", handleScrollEnd, { passive: true });
    scrollHandlers.set(this, handleScrollEnd);
  });
  decorate(EventTarget.prototype, "removeEventListener", function(removeEventListener, type) {
    if (type !== "scrollend")
      return;
    const scrollHandler = scrollHandlers.get(this);
    if (scrollHandler) {
      removeEventListener.call(this, "scroll", scrollHandler, { passive: true });
    }
  });
}
var SlCarousel = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.loop = false;
    this.navigation = false;
    this.pagination = false;
    this.autoplay = false;
    this.autoplayInterval = 3e3;
    this.slidesPerPage = 1;
    this.slidesPerMove = 1;
    this.orientation = "horizontal";
    this.mouseDragging = false;
    this.activeSlide = 0;
    this.scrolling = false;
    this.dragging = false;
    this.autoplayController = new AutoplayController(this, () => this.next());
    this.localize = new LocalizeController2(this);
    this.handleMouseDrag = (event) => {
      if (!this.dragging) {
        this.scrollContainer.style.setProperty("scroll-snap-type", "none");
        this.dragging = true;
      }
      this.scrollContainer.scrollBy({
        left: -event.movementX,
        top: -event.movementY,
        behavior: "instant"
      });
    };
    this.handleMouseDragEnd = () => {
      const scrollContainer = this.scrollContainer;
      document.removeEventListener("pointermove", this.handleMouseDrag, { capture: true });
      const startLeft = scrollContainer.scrollLeft;
      const startTop = scrollContainer.scrollTop;
      scrollContainer.style.removeProperty("scroll-snap-type");
      scrollContainer.style.setProperty("overflow", "hidden");
      const finalLeft = scrollContainer.scrollLeft;
      const finalTop = scrollContainer.scrollTop;
      scrollContainer.style.removeProperty("overflow");
      scrollContainer.style.setProperty("scroll-snap-type", "none");
      scrollContainer.scrollTo({ left: startLeft, top: startTop, behavior: "instant" });
      requestAnimationFrame(async () => {
        if (startLeft !== finalLeft || startTop !== finalTop) {
          scrollContainer.scrollTo({
            left: finalLeft,
            top: finalTop,
            behavior: prefersReducedMotion() ? "auto" : "smooth"
          });
          await waitForEvent(scrollContainer, "scrollend");
        }
        scrollContainer.style.removeProperty("scroll-snap-type");
        this.dragging = false;
        this.handleScrollEnd();
      });
    };
    this.handleSlotChange = (mutations) => {
      const needsInitialization = mutations.some(
        (mutation) => [...mutation.addedNodes, ...mutation.removedNodes].some(
          (el) => this.isCarouselItem(el) && !el.hasAttribute("data-clone")
        )
      );
      if (needsInitialization) {
        this.initializeSlides();
      }
      this.requestUpdate();
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "region");
    this.setAttribute("aria-label", this.localize.term("carousel"));
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.mutationObserver.disconnect();
  }
  firstUpdated() {
    this.initializeSlides();
    this.mutationObserver = new MutationObserver(this.handleSlotChange);
    this.mutationObserver.observe(this, {
      childList: true,
      subtree: true
    });
  }
  willUpdate(changedProperties) {
    if (changedProperties.has("slidesPerMove") || changedProperties.has("slidesPerPage")) {
      this.slidesPerMove = Math.min(this.slidesPerMove, this.slidesPerPage);
    }
  }
  getPageCount() {
    const slidesCount = this.getSlides().length;
    const { slidesPerPage, slidesPerMove, loop } = this;
    const pages = loop ? slidesCount / slidesPerMove : (slidesCount - slidesPerPage) / slidesPerMove + 1;
    return Math.ceil(pages);
  }
  getCurrentPage() {
    return Math.ceil(this.activeSlide / this.slidesPerMove);
  }
  canScrollNext() {
    return this.loop || this.getCurrentPage() < this.getPageCount() - 1;
  }
  canScrollPrev() {
    return this.loop || this.getCurrentPage() > 0;
  }
  /** @internal Gets all carousel items. */
  getSlides({ excludeClones = true } = {}) {
    return [...this.children].filter(
      (el) => this.isCarouselItem(el) && (!excludeClones || !el.hasAttribute("data-clone"))
    );
  }
  handleKeyDown(event) {
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
      const target = event.target;
      const isRtl = this.localize.dir() === "rtl";
      const isFocusInPagination = target.closest('[part~="pagination-item"]') !== null;
      const isNext = event.key === "ArrowDown" || !isRtl && event.key === "ArrowRight" || isRtl && event.key === "ArrowLeft";
      const isPrevious = event.key === "ArrowUp" || !isRtl && event.key === "ArrowLeft" || isRtl && event.key === "ArrowRight";
      event.preventDefault();
      if (isPrevious) {
        this.previous();
      }
      if (isNext) {
        this.next();
      }
      if (event.key === "Home") {
        this.goToSlide(0);
      }
      if (event.key === "End") {
        this.goToSlide(this.getSlides().length - 1);
      }
      if (isFocusInPagination) {
        this.updateComplete.then(() => {
          var _a24;
          const activePaginationItem = (_a24 = this.shadowRoot) == null ? void 0 : _a24.querySelector(
            '[part~="pagination-item--active"]'
          );
          if (activePaginationItem) {
            activePaginationItem.focus();
          }
        });
      }
    }
  }
  handleMouseDragStart(event) {
    const canDrag = this.mouseDragging && event.button === 0;
    if (canDrag) {
      event.preventDefault();
      document.addEventListener("pointermove", this.handleMouseDrag, { capture: true, passive: true });
      document.addEventListener("pointerup", this.handleMouseDragEnd, { capture: true, once: true });
    }
  }
  handleScroll() {
    this.scrolling = true;
  }
  /** @internal Synchronizes the slides with the IntersectionObserver API. */
  synchronizeSlides() {
    const io = new IntersectionObserver(
      (entries) => {
        io.disconnect();
        for (const entry of entries) {
          const slide = entry.target;
          slide.toggleAttribute("inert", !entry.isIntersecting);
          slide.classList.toggle("--in-view", entry.isIntersecting);
          slide.setAttribute("aria-hidden", entry.isIntersecting ? "false" : "true");
        }
        const firstIntersecting = entries.find((entry) => entry.isIntersecting);
        if (firstIntersecting) {
          if (this.loop && firstIntersecting.target.hasAttribute("data-clone")) {
            const clonePosition = Number(firstIntersecting.target.getAttribute("data-clone"));
            this.goToSlide(clonePosition, "instant");
          } else {
            const slides = this.getSlides();
            const slideIndex = slides.indexOf(firstIntersecting.target);
            this.activeSlide = Math.ceil(slideIndex / this.slidesPerMove) * this.slidesPerMove;
          }
        }
      },
      {
        root: this.scrollContainer,
        threshold: 0.6
      }
    );
    this.getSlides({ excludeClones: false }).forEach((slide) => {
      io.observe(slide);
    });
  }
  handleScrollEnd() {
    if (!this.scrolling || this.dragging)
      return;
    this.synchronizeSlides();
    this.scrolling = false;
  }
  isCarouselItem(node) {
    return node instanceof Element && node.tagName.toLowerCase() === "sl-carousel-item";
  }
  initializeSlides() {
    this.getSlides({ excludeClones: false }).forEach((slide, index) => {
      slide.classList.remove("--in-view");
      slide.classList.remove("--is-active");
      slide.setAttribute("aria-label", this.localize.term("slideNum", index + 1));
      if (slide.hasAttribute("data-clone")) {
        slide.remove();
      }
    });
    this.updateSlidesSnap();
    if (this.loop) {
      this.createClones();
    }
    this.synchronizeSlides();
    this.goToSlide(this.activeSlide, "auto");
  }
  createClones() {
    const slides = this.getSlides();
    const slidesPerPage = this.slidesPerPage;
    const lastSlides = slides.slice(-slidesPerPage);
    const firstSlides = slides.slice(0, slidesPerPage);
    lastSlides.reverse().forEach((slide, i5) => {
      const clone = slide.cloneNode(true);
      clone.setAttribute("data-clone", String(slides.length - i5 - 1));
      this.prepend(clone);
    });
    firstSlides.forEach((slide, i5) => {
      const clone = slide.cloneNode(true);
      clone.setAttribute("data-clone", String(i5));
      this.append(clone);
    });
  }
  handelSlideChange() {
    const slides = this.getSlides();
    slides.forEach((slide, i5) => {
      slide.classList.toggle("--is-active", i5 === this.activeSlide);
    });
    if (this.hasUpdated) {
      this.emit("sl-slide-change", {
        detail: {
          index: this.activeSlide,
          slide: slides[this.activeSlide]
        }
      });
    }
  }
  updateSlidesSnap() {
    const slides = this.getSlides();
    const slidesPerMove = this.slidesPerMove;
    slides.forEach((slide, i5) => {
      const shouldSnap = (i5 + slidesPerMove) % slidesPerMove === 0;
      if (shouldSnap) {
        slide.style.removeProperty("scroll-snap-align");
      } else {
        slide.style.setProperty("scroll-snap-align", "none");
      }
    });
  }
  handleAutoplayChange() {
    this.autoplayController.stop();
    if (this.autoplay) {
      this.autoplayController.start(this.autoplayInterval);
    }
  }
  /**
   * Move the carousel backward by `slides-per-move` slides.
   *
   * @param behavior - The behavior used for scrolling.
   */
  previous(behavior = "smooth") {
    this.goToSlide(this.activeSlide - this.slidesPerMove, behavior);
  }
  /**
   * Move the carousel forward by `slides-per-move` slides.
   *
   * @param behavior - The behavior used for scrolling.
   */
  next(behavior = "smooth") {
    this.goToSlide(this.activeSlide + this.slidesPerMove, behavior);
  }
  /**
   * Scrolls the carousel to the slide specified by `index`.
   *
   * @param index - The slide index.
   * @param behavior - The behavior used for scrolling.
   */
  goToSlide(index, behavior = "smooth") {
    const { slidesPerPage, loop } = this;
    const slides = this.getSlides();
    const slidesWithClones = this.getSlides({ excludeClones: false });
    if (!slides.length) {
      return;
    }
    const newActiveSlide = loop ? (index + slides.length) % slides.length : clamp2(index, 0, slides.length - 1);
    this.activeSlide = newActiveSlide;
    const nextSlideIndex = clamp2(index + (loop ? slidesPerPage : 0), 0, slidesWithClones.length - 1);
    const nextSlide = slidesWithClones[nextSlideIndex];
    this.scrollToSlide(nextSlide, prefersReducedMotion() ? "auto" : behavior);
  }
  scrollToSlide(slide, behavior = "smooth") {
    const scrollContainer = this.scrollContainer;
    const scrollContainerRect = scrollContainer.getBoundingClientRect();
    const nextSlideRect = slide.getBoundingClientRect();
    const nextLeft = nextSlideRect.left - scrollContainerRect.left;
    const nextTop = nextSlideRect.top - scrollContainerRect.top;
    scrollContainer.scrollTo({
      left: nextLeft + scrollContainer.scrollLeft,
      top: nextTop + scrollContainer.scrollTop,
      behavior
    });
  }
  render() {
    const { slidesPerMove, scrolling } = this;
    const pagesCount = this.getPageCount();
    const currentPage = this.getCurrentPage();
    const prevEnabled = this.canScrollPrev();
    const nextEnabled = this.canScrollNext();
    const isLtr = this.localize.dir() === "ltr";
    return ke`
      <div part="base" class="carousel">
        <div
          id="scroll-container"
          part="scroll-container"
          class="${Rt({
      carousel__slides: true,
      "carousel__slides--horizontal": this.orientation === "horizontal",
      "carousel__slides--vertical": this.orientation === "vertical",
      "carousel__slides--dragging": this.dragging
    })}"
          style="--slides-per-page: ${this.slidesPerPage};"
          aria-busy="${scrolling ? "true" : "false"}"
          aria-atomic="true"
          tabindex="0"
          @keydown=${this.handleKeyDown}
          @mousedown="${this.handleMouseDragStart}"
          @scroll="${this.handleScroll}"
          @scrollend=${this.handleScrollEnd}
        >
          <slot></slot>
        </div>

        ${this.navigation ? ke`
              <div part="navigation" class="carousel__navigation">
                <button
                  part="navigation-button navigation-button--previous"
                  class="${Rt({
      "carousel__navigation-button": true,
      "carousel__navigation-button--previous": true,
      "carousel__navigation-button--disabled": !prevEnabled
    })}"
                  aria-label="${this.localize.term("previousSlide")}"
                  aria-controls="scroll-container"
                  aria-disabled="${prevEnabled ? "false" : "true"}"
                  @click=${prevEnabled ? () => this.previous() : null}
                >
                  <slot name="previous-icon">
                    <sl-icon library="system" name="${isLtr ? "chevron-left" : "chevron-right"}"></sl-icon>
                  </slot>
                </button>

                <button
                  part="navigation-button navigation-button--next"
                  class=${Rt({
      "carousel__navigation-button": true,
      "carousel__navigation-button--next": true,
      "carousel__navigation-button--disabled": !nextEnabled
    })}
                  aria-label="${this.localize.term("nextSlide")}"
                  aria-controls="scroll-container"
                  aria-disabled="${nextEnabled ? "false" : "true"}"
                  @click=${nextEnabled ? () => this.next() : null}
                >
                  <slot name="next-icon">
                    <sl-icon library="system" name="${isLtr ? "chevron-right" : "chevron-left"}"></sl-icon>
                  </slot>
                </button>
              </div>
            ` : ""}
        ${this.pagination ? ke`
              <div part="pagination" role="tablist" class="carousel__pagination" aria-controls="scroll-container">
                ${oo(oo2(pagesCount), (index) => {
      const isActive = index === currentPage;
      return ke`
                    <button
                      part="pagination-item ${isActive ? "pagination-item--active" : ""}"
                      class="${Rt({
        "carousel__pagination-item": true,
        "carousel__pagination-item--active": isActive
      })}"
                      role="tab"
                      aria-selected="${isActive ? "true" : "false"}"
                      aria-label="${this.localize.term("goToSlide", index + 1, pagesCount)}"
                      tabindex=${isActive ? "0" : "-1"}
                      @click=${() => this.goToSlide(index * slidesPerMove)}
                      @keydown=${this.handleKeyDown}
                    ></button>
                  `;
    })}
              </div>
            ` : ""}
      </div>
    `;
  }
};
SlCarousel.styles = [component_styles_default, carousel_styles_default];
SlCarousel.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlCarousel.prototype, "loop", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlCarousel.prototype, "navigation", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlCarousel.prototype, "pagination", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlCarousel.prototype, "autoplay", 2);
__decorateClass([
  n6({ type: Number, attribute: "autoplay-interval" })
], SlCarousel.prototype, "autoplayInterval", 2);
__decorateClass([
  n6({ type: Number, attribute: "slides-per-page" })
], SlCarousel.prototype, "slidesPerPage", 2);
__decorateClass([
  n6({ type: Number, attribute: "slides-per-move" })
], SlCarousel.prototype, "slidesPerMove", 2);
__decorateClass([
  n6()
], SlCarousel.prototype, "orientation", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true, attribute: "mouse-dragging" })
], SlCarousel.prototype, "mouseDragging", 2);
__decorateClass([
  e7(".carousel__slides")
], SlCarousel.prototype, "scrollContainer", 2);
__decorateClass([
  e7(".carousel__pagination")
], SlCarousel.prototype, "paginationContainer", 2);
__decorateClass([
  r5()
], SlCarousel.prototype, "activeSlide", 2);
__decorateClass([
  r5()
], SlCarousel.prototype, "scrolling", 2);
__decorateClass([
  r5()
], SlCarousel.prototype, "dragging", 2);
__decorateClass([
  t5({ passive: true })
], SlCarousel.prototype, "handleScroll", 1);
__decorateClass([
  watch("loop", { waitUntilFirstUpdate: true }),
  watch("slidesPerPage", { waitUntilFirstUpdate: true })
], SlCarousel.prototype, "initializeSlides", 1);
__decorateClass([
  watch("activeSlide")
], SlCarousel.prototype, "handelSlideChange", 1);
__decorateClass([
  watch("slidesPerMove")
], SlCarousel.prototype, "updateSlidesSnap", 1);
__decorateClass([
  watch("autoplay")
], SlCarousel.prototype, "handleAutoplayChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.BUHKANU6.js
SlCarousel.define("sl-carousel");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.NQ44LUGM.js
var carousel_item_styles_default = i`
  :host {
    --aspect-ratio: inherit;

    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    width: 100%;
    max-height: 100%;
    aspect-ratio: var(--aspect-ratio);
    scroll-snap-align: start;
    scroll-snap-stop: always;
  }

  ::slotted(img) {
    width: 100% !important;
    height: 100% !important;
    object-fit: cover;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.KCFYRKWD.js
var SlCarouselItem = class extends ShoelaceElement {
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "group");
  }
  render() {
    return ke` <slot></slot> `;
  }
};
SlCarouselItem.styles = [component_styles_default, carousel_item_styles_default];

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3DBK52Y7.js
SlCarouselItem.define("sl-carousel-item");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7XIC3PQE.js
var button_default = SlButton;
SlButton.define("sl-button");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.MMMZYM5S.js
var button_group_default = SlButtonGroup;
SlButtonGroup.define("sl-button-group");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.WQC6OWUE.js
var badge_styles_default = i`
  :host {
    display: inline-flex;
  }

  .badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: max(12px, 0.75em);
    font-weight: var(--sl-font-weight-semibold);
    letter-spacing: var(--sl-letter-spacing-normal);
    line-height: 1;
    border-radius: var(--sl-border-radius-small);
    border: solid 1px var(--sl-color-neutral-0);
    white-space: nowrap;
    padding: 0.35em 0.6em;
    user-select: none;
    -webkit-user-select: none;
    cursor: inherit;
  }

  /* Variant modifiers */
  .badge--primary {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--success {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--neutral {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--warning {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--danger {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /* Pill modifier */
  .badge--pill {
    border-radius: var(--sl-border-radius-pill);
  }

  /* Pulse modifier */
  .badge--pulse {
    animation: pulse 1.5s infinite;
  }

  .badge--pulse.badge--primary {
    --pulse-color: var(--sl-color-primary-600);
  }

  .badge--pulse.badge--success {
    --pulse-color: var(--sl-color-success-600);
  }

  .badge--pulse.badge--neutral {
    --pulse-color: var(--sl-color-neutral-600);
  }

  .badge--pulse.badge--warning {
    --pulse-color: var(--sl-color-warning-600);
  }

  .badge--pulse.badge--danger {
    --pulse-color: var(--sl-color-danger-600);
  }

  @keyframes pulse {
    0% {
      box-shadow: 0 0 0 0 var(--pulse-color);
    }
    70% {
      box-shadow: 0 0 0 0.5rem transparent;
    }
    100% {
      box-shadow: 0 0 0 0 transparent;
    }
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.AQLP63PT.js
var SlBadge = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.variant = "primary";
    this.pill = false;
    this.pulse = false;
  }
  render() {
    return ke`
      <span
        part="base"
        class=${Rt({
      badge: true,
      "badge--primary": this.variant === "primary",
      "badge--success": this.variant === "success",
      "badge--neutral": this.variant === "neutral",
      "badge--warning": this.variant === "warning",
      "badge--danger": this.variant === "danger",
      "badge--pill": this.pill,
      "badge--pulse": this.pulse
    })}
        role="status"
      >
        <slot></slot>
      </span>
    `;
  }
};
SlBadge.styles = [component_styles_default, badge_styles_default];
__decorateClass([
  n6({ reflect: true })
], SlBadge.prototype, "variant", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlBadge.prototype, "pill", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlBadge.prototype, "pulse", 2);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3LQGVQFJ.js
var badge_default = SlBadge;
SlBadge.define("sl-badge");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.P4NYDBZP.js
var breadcrumb_styles_default = i`
  .breadcrumb {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.5XTJSLWK.js
var SlBreadcrumb = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.separatorDir = this.localize.dir();
    this.label = "";
  }
  // Generates a clone of the separator element to use for each breadcrumb item
  getSeparator() {
    const separator = this.separatorSlot.assignedElements({ flatten: true })[0];
    const clone = separator.cloneNode(true);
    [clone, ...clone.querySelectorAll("[id]")].forEach((el) => el.removeAttribute("id"));
    clone.setAttribute("data-default", "");
    clone.slot = "separator";
    return clone;
  }
  handleSlotChange() {
    const items = [...this.defaultSlot.assignedElements({ flatten: true })].filter(
      (item) => item.tagName.toLowerCase() === "sl-breadcrumb-item"
    );
    items.forEach((item, index) => {
      const separator = item.querySelector('[slot="separator"]');
      if (separator === null) {
        item.append(this.getSeparator());
      } else if (separator.hasAttribute("data-default")) {
        separator.replaceWith(this.getSeparator());
      } else {
      }
      if (index === items.length - 1) {
        item.setAttribute("aria-current", "page");
      } else {
        item.removeAttribute("aria-current");
      }
    });
  }
  render() {
    if (this.separatorDir !== this.localize.dir()) {
      this.separatorDir = this.localize.dir();
      this.updateComplete.then(() => this.handleSlotChange());
    }
    return ke`
      <nav part="base" class="breadcrumb" aria-label=${this.label}>
        <slot @slotchange=${this.handleSlotChange}></slot>
      </nav>

      <span hidden aria-hidden="true">
        <slot name="separator">
          <sl-icon name=${this.localize.dir() === "rtl" ? "chevron-left" : "chevron-right"} library="system"></sl-icon>
        </slot>
      </span>
    `;
  }
};
SlBreadcrumb.styles = [component_styles_default, breadcrumb_styles_default];
SlBreadcrumb.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e7("slot")
], SlBreadcrumb.prototype, "defaultSlot", 2);
__decorateClass([
  e7('slot[name="separator"]')
], SlBreadcrumb.prototype, "separatorSlot", 2);
__decorateClass([
  n6()
], SlBreadcrumb.prototype, "label", 2);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.NCASIWC3.js
SlBreadcrumb.define("sl-breadcrumb");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.Q5P7Y2HU.js
var breadcrumb_item_styles_default = i`
  :host {
    display: inline-flex;
  }

  .breadcrumb-item {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    color: var(--sl-color-neutral-600);
    line-height: var(--sl-line-height-normal);
    white-space: nowrap;
  }

  .breadcrumb-item__label {
    display: inline-block;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    line-height: inherit;
    text-decoration: none;
    color: inherit;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    padding: 0;
    margin: 0;
    cursor: pointer;
    transition: var(--sl-transition-fast) --color;
  }

  :host(:not(:last-of-type)) .breadcrumb-item__label {
    color: var(--sl-color-primary-600);
  }

  :host(:not(:last-of-type)) .breadcrumb-item__label:hover {
    color: var(--sl-color-primary-500);
  }

  :host(:not(:last-of-type)) .breadcrumb-item__label:active {
    color: var(--sl-color-primary-600);
  }

  .breadcrumb-item__label:focus {
    outline: none;
  }

  .breadcrumb-item__label:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .breadcrumb-item__prefix,
  .breadcrumb-item__suffix {
    display: none;
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .breadcrumb-item--has-prefix .breadcrumb-item__prefix {
    display: inline-flex;
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .breadcrumb-item--has-suffix .breadcrumb-item__suffix {
    display: inline-flex;
    margin-inline-start: var(--sl-spacing-x-small);
  }

  :host(:last-of-type) .breadcrumb-item__separator {
    display: none;
  }

  .breadcrumb-item__separator {
    display: inline-flex;
    align-items: center;
    margin: 0 var(--sl-spacing-x-small);
    user-select: none;
    -webkit-user-select: none;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.QCACBKJY.js
var SlBreadcrumbItem = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "prefix", "suffix");
    this.rel = "noreferrer noopener";
  }
  render() {
    const isLink = this.href ? true : false;
    return ke`
      <div
        part="base"
        class=${Rt({
      "breadcrumb-item": true,
      "breadcrumb-item--has-prefix": this.hasSlotController.test("prefix"),
      "breadcrumb-item--has-suffix": this.hasSlotController.test("suffix")
    })}
      >
        <span part="prefix" class="breadcrumb-item__prefix">
          <slot name="prefix"></slot>
        </span>

        ${isLink ? ke`
              <a
                part="label"
                class="breadcrumb-item__label breadcrumb-item__label--link"
                href="${this.href}"
                target="${to(this.target ? this.target : void 0)}"
                rel=${to(this.target ? this.rel : void 0)}
              >
                <slot></slot>
              </a>
            ` : ke`
              <button part="label" type="button" class="breadcrumb-item__label breadcrumb-item__label--button">
                <slot></slot>
              </button>
            `}

        <span part="suffix" class="breadcrumb-item__suffix">
          <slot name="suffix"></slot>
        </span>

        <span part="separator" class="breadcrumb-item__separator" aria-hidden="true">
          <slot name="separator"></slot>
        </span>
      </div>
    `;
  }
};
SlBreadcrumbItem.styles = [component_styles_default, breadcrumb_item_styles_default];
__decorateClass([
  n6()
], SlBreadcrumbItem.prototype, "href", 2);
__decorateClass([
  n6()
], SlBreadcrumbItem.prototype, "target", 2);
__decorateClass([
  n6()
], SlBreadcrumbItem.prototype, "rel", 2);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2GDKSFZA.js
SlBreadcrumbItem.define("sl-breadcrumb-item");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.M3A4TKTU.js
var animated_image_styles_default = i`
  :host {
    --control-box-size: 3rem;
    --icon-size: calc(var(--control-box-size) * 0.625);

    display: inline-flex;
    position: relative;
    cursor: pointer;
  }

  img {
    display: block;
    width: 100%;
    height: 100%;
  }

  img[aria-hidden='true'] {
    display: none;
  }

  .animated-image__control-box {
    display: flex;
    position: absolute;
    align-items: center;
    justify-content: center;
    top: calc(50% - var(--control-box-size) / 2);
    right: calc(50% - var(--control-box-size) / 2);
    width: var(--control-box-size);
    height: var(--control-box-size);
    font-size: var(--icon-size);
    background: none;
    border: solid 2px currentColor;
    background-color: rgb(0 0 0 /50%);
    border-radius: var(--sl-border-radius-circle);
    color: white;
    pointer-events: none;
    transition: var(--sl-transition-fast) opacity;
  }

  :host([play]:hover) .animated-image__control-box {
    opacity: 1;
  }

  :host([play]:not(:hover)) .animated-image__control-box {
    opacity: 0;
  }

  :host([play]) slot[name='play-icon'],
  :host(:not([play])) slot[name='pause-icon'] {
    display: none;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.35FFOEVS.js
var SlAnimatedImage = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.isLoaded = false;
  }
  handleClick() {
    this.play = !this.play;
  }
  handleLoad() {
    const canvas = document.createElement("canvas");
    const { width, height } = this.animatedImage;
    canvas.width = width;
    canvas.height = height;
    canvas.getContext("2d").drawImage(this.animatedImage, 0, 0, width, height);
    this.frozenFrame = canvas.toDataURL("image/gif");
    if (!this.isLoaded) {
      this.emit("sl-load");
      this.isLoaded = true;
    }
  }
  handleError() {
    this.emit("sl-error");
  }
  handlePlayChange() {
    if (this.play) {
      this.animatedImage.src = "";
      this.animatedImage.src = this.src;
    }
  }
  handleSrcChange() {
    this.isLoaded = false;
  }
  render() {
    return ke`
      <div class="animated-image">
        <img
          class="animated-image__animated"
          src=${this.src}
          alt=${this.alt}
          crossorigin="anonymous"
          aria-hidden=${this.play ? "false" : "true"}
          @click=${this.handleClick}
          @load=${this.handleLoad}
          @error=${this.handleError}
        />

        ${this.isLoaded ? ke`
              <img
                class="animated-image__frozen"
                src=${this.frozenFrame}
                alt=${this.alt}
                aria-hidden=${this.play ? "true" : "false"}
                @click=${this.handleClick}
              />

              <div part="control-box" class="animated-image__control-box">
                <slot name="play-icon"><sl-icon name="play-fill" library="system"></sl-icon></slot>
                <slot name="pause-icon"><sl-icon name="pause-fill" library="system"></sl-icon></slot>
              </div>
            ` : ""}
      </div>
    `;
  }
};
SlAnimatedImage.styles = [component_styles_default, animated_image_styles_default];
SlAnimatedImage.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e7(".animated-image__animated")
], SlAnimatedImage.prototype, "animatedImage", 2);
__decorateClass([
  r5()
], SlAnimatedImage.prototype, "frozenFrame", 2);
__decorateClass([
  r5()
], SlAnimatedImage.prototype, "isLoaded", 2);
__decorateClass([
  n6()
], SlAnimatedImage.prototype, "src", 2);
__decorateClass([
  n6()
], SlAnimatedImage.prototype, "alt", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlAnimatedImage.prototype, "play", 2);
__decorateClass([
  watch("play", { waitUntilFirstUpdate: true })
], SlAnimatedImage.prototype, "handlePlayChange", 1);
__decorateClass([
  watch("src")
], SlAnimatedImage.prototype, "handleSrcChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.YVC5Q4AQ.js
SlAnimatedImage.define("sl-animated-image");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.K35GSB4N.js
var avatar_styles_default = i`
  :host {
    display: inline-block;

    --size: 3rem;
  }

  .avatar {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
    width: var(--size);
    height: var(--size);
    background-color: var(--sl-color-neutral-400);
    font-family: var(--sl-font-sans);
    font-size: calc(var(--size) * 0.5);
    font-weight: var(--sl-font-weight-normal);
    color: var(--sl-color-neutral-0);
    user-select: none;
    -webkit-user-select: none;
    vertical-align: middle;
  }

  .avatar--circle,
  .avatar--circle .avatar__image {
    border-radius: var(--sl-border-radius-circle);
  }

  .avatar--rounded,
  .avatar--rounded .avatar__image {
    border-radius: var(--sl-border-radius-medium);
  }

  .avatar--square {
    border-radius: 0;
  }

  .avatar__icon {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  .avatar__initials {
    line-height: 1;
    text-transform: uppercase;
  }

  .avatar__image {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    overflow: hidden;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.YOEQI544.js
var SlAvatar = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasError = false;
    this.image = "";
    this.label = "";
    this.initials = "";
    this.loading = "eager";
    this.shape = "circle";
  }
  handleImageChange() {
    this.hasError = false;
  }
  render() {
    const avatarWithImage = ke`
      <img
        part="image"
        class="avatar__image"
        src="${this.image}"
        loading="${this.loading}"
        alt=""
        @error="${() => this.hasError = true}"
      />
    `;
    let avatarWithoutImage = ke``;
    if (this.initials) {
      avatarWithoutImage = ke`<div part="initials" class="avatar__initials">${this.initials}</div>`;
    } else {
      avatarWithoutImage = ke`
        <div part="icon" class="avatar__icon" aria-hidden="true">
          <slot name="icon">
            <sl-icon name="person-fill" library="system"></sl-icon>
          </slot>
        </div>
      `;
    }
    return ke`
      <div
        part="base"
        class=${Rt({
      avatar: true,
      "avatar--circle": this.shape === "circle",
      "avatar--rounded": this.shape === "rounded",
      "avatar--square": this.shape === "square"
    })}
        role="img"
        aria-label=${this.label}
      >
        ${this.image && !this.hasError ? avatarWithImage : avatarWithoutImage}
      </div>
    `;
  }
};
SlAvatar.styles = [component_styles_default, avatar_styles_default];
SlAvatar.dependencies = {
  "sl-icon": SlIcon
};
__decorateClass([
  r5()
], SlAvatar.prototype, "hasError", 2);
__decorateClass([
  n6()
], SlAvatar.prototype, "image", 2);
__decorateClass([
  n6()
], SlAvatar.prototype, "label", 2);
__decorateClass([
  n6()
], SlAvatar.prototype, "initials", 2);
__decorateClass([
  n6()
], SlAvatar.prototype, "loading", 2);
__decorateClass([
  n6({ reflect: true })
], SlAvatar.prototype, "shape", 2);
__decorateClass([
  watch("image")
], SlAvatar.prototype, "handleImageChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.RS5VY2YI.js
SlAvatar.define("sl-avatar");

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.OCMJ7QFW.js
var alert_styles_default = i`
  :host {
    display: contents;

    /* For better DX, we'll reset the margin here so the base part can inherit it */
    margin: 0;
  }

  .alert {
    position: relative;
    display: flex;
    align-items: stretch;
    background-color: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-top-width: calc(var(--sl-panel-border-width) * 3);
    border-radius: var(--sl-border-radius-medium);
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-normal);
    line-height: 1.6;
    color: var(--sl-color-neutral-700);
    margin: inherit;
  }

  .alert:not(.alert--has-icon) .alert__icon,
  .alert:not(.alert--closable) .alert__close-button {
    display: none;
  }

  .alert__icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-large);
    padding-inline-start: var(--sl-spacing-large);
  }

  .alert--primary {
    border-top-color: var(--sl-color-primary-600);
  }

  .alert--primary .alert__icon {
    color: var(--sl-color-primary-600);
  }

  .alert--success {
    border-top-color: var(--sl-color-success-600);
  }

  .alert--success .alert__icon {
    color: var(--sl-color-success-600);
  }

  .alert--neutral {
    border-top-color: var(--sl-color-neutral-600);
  }

  .alert--neutral .alert__icon {
    color: var(--sl-color-neutral-600);
  }

  .alert--warning {
    border-top-color: var(--sl-color-warning-600);
  }

  .alert--warning .alert__icon {
    color: var(--sl-color-warning-600);
  }

  .alert--danger {
    border-top-color: var(--sl-color-danger-600);
  }

  .alert--danger .alert__icon {
    color: var(--sl-color-danger-600);
  }

  .alert__message {
    flex: 1 1 auto;
    display: block;
    padding: var(--sl-spacing-large);
    overflow: hidden;
  }

  .alert__close-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-medium);
    padding-inline-end: var(--sl-spacing-medium);
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ZNYIETUV.js
var toastStack = Object.assign(document.createElement("div"), { className: "sl-toast-stack" });
var SlAlert = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "icon", "suffix");
    this.localize = new LocalizeController2(this);
    this.open = false;
    this.closable = false;
    this.variant = "primary";
    this.duration = Infinity;
  }
  firstUpdated() {
    this.base.hidden = !this.open;
  }
  restartAutoHide() {
    clearTimeout(this.autoHideTimeout);
    if (this.open && this.duration < Infinity) {
      this.autoHideTimeout = window.setTimeout(() => this.hide(), this.duration);
    }
  }
  handleCloseClick() {
    this.hide();
  }
  handleMouseMove() {
    this.restartAutoHide();
  }
  async handleOpenChange() {
    if (this.open) {
      this.emit("sl-show");
      if (this.duration < Infinity) {
        this.restartAutoHide();
      }
      await stopAnimations(this.base);
      this.base.hidden = false;
      const { keyframes, options } = getAnimation(this, "alert.show", { dir: this.localize.dir() });
      await animateTo(this.base, keyframes, options);
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      clearTimeout(this.autoHideTimeout);
      await stopAnimations(this.base);
      const { keyframes, options } = getAnimation(this, "alert.hide", { dir: this.localize.dir() });
      await animateTo(this.base, keyframes, options);
      this.base.hidden = true;
      this.emit("sl-after-hide");
    }
  }
  handleDurationChange() {
    this.restartAutoHide();
  }
  /** Shows the alert. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the alert */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  /**
   * Displays the alert as a toast notification. This will move the alert out of its position in the DOM and, when
   * dismissed, it will be removed from the DOM completely. By storing a reference to the alert, you can reuse it by
   * calling this method again. The returned promise will resolve after the alert is hidden.
   */
  async toast() {
    return new Promise((resolve) => {
      if (toastStack.parentElement === null) {
        document.body.append(toastStack);
      }
      toastStack.appendChild(this);
      requestAnimationFrame(() => {
        this.clientWidth;
        this.show();
      });
      this.addEventListener(
        "sl-after-hide",
        () => {
          toastStack.removeChild(this);
          resolve();
          if (toastStack.querySelector("sl-alert") === null) {
            toastStack.remove();
          }
        },
        { once: true }
      );
    });
  }
  render() {
    return ke`
      <div
        part="base"
        class=${Rt({
      alert: true,
      "alert--open": this.open,
      "alert--closable": this.closable,
      "alert--has-icon": this.hasSlotController.test("icon"),
      "alert--primary": this.variant === "primary",
      "alert--success": this.variant === "success",
      "alert--neutral": this.variant === "neutral",
      "alert--warning": this.variant === "warning",
      "alert--danger": this.variant === "danger"
    })}
        role="alert"
        aria-hidden=${this.open ? "false" : "true"}
        @mousemove=${this.handleMouseMove}
      >
        <div part="icon" class="alert__icon">
          <slot name="icon"></slot>
        </div>

        <div part="message" class="alert__message" aria-live="polite">
          <slot></slot>
        </div>

        ${this.closable ? ke`
              <sl-icon-button
                part="close-button"
                exportparts="base:close-button__base"
                class="alert__close-button"
                name="x-lg"
                library="system"
                label=${this.localize.term("close")}
                @click=${this.handleCloseClick}
              ></sl-icon-button>
            ` : ""}
      </div>
    `;
  }
};
SlAlert.styles = [component_styles_default, alert_styles_default];
SlAlert.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass([
  e7('[part~="base"]')
], SlAlert.prototype, "base", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlAlert.prototype, "open", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlAlert.prototype, "closable", 2);
__decorateClass([
  n6({ reflect: true })
], SlAlert.prototype, "variant", 2);
__decorateClass([
  n6({ type: Number })
], SlAlert.prototype, "duration", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: true })
], SlAlert.prototype, "handleOpenChange", 1);
__decorateClass([
  watch("duration")
], SlAlert.prototype, "handleDurationChange", 1);
setDefaultAnimation("alert.show", {
  keyframes: [
    { opacity: 0, scale: 0.8 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("alert.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.8 }
  ],
  options: { duration: 250, easing: "ease" }
});

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LJCGGJEU.js
var alert_default = SlAlert;
SlAlert.define("sl-alert");

// src/node_modules/@shoelace-style/animations/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  backInDown: () => backInDown,
  backInLeft: () => backInLeft,
  backInRight: () => backInRight,
  backInUp: () => backInUp,
  backOutDown: () => backOutDown,
  backOutLeft: () => backOutLeft,
  backOutRight: () => backOutRight,
  backOutUp: () => backOutUp,
  bounce: () => bounce,
  bounceIn: () => bounceIn,
  bounceInDown: () => bounceInDown,
  bounceInLeft: () => bounceInLeft,
  bounceInRight: () => bounceInRight,
  bounceInUp: () => bounceInUp,
  bounceOut: () => bounceOut,
  bounceOutDown: () => bounceOutDown,
  bounceOutLeft: () => bounceOutLeft,
  bounceOutRight: () => bounceOutRight,
  bounceOutUp: () => bounceOutUp,
  easings: () => easings,
  fadeIn: () => fadeIn,
  fadeInBottomLeft: () => fadeInBottomLeft,
  fadeInBottomRight: () => fadeInBottomRight,
  fadeInDown: () => fadeInDown,
  fadeInDownBig: () => fadeInDownBig,
  fadeInLeft: () => fadeInLeft,
  fadeInLeftBig: () => fadeInLeftBig,
  fadeInRight: () => fadeInRight,
  fadeInRightBig: () => fadeInRightBig,
  fadeInTopLeft: () => fadeInTopLeft,
  fadeInTopRight: () => fadeInTopRight,
  fadeInUp: () => fadeInUp,
  fadeInUpBig: () => fadeInUpBig,
  fadeOut: () => fadeOut,
  fadeOutBottomLeft: () => fadeOutBottomLeft,
  fadeOutBottomRight: () => fadeOutBottomRight,
  fadeOutDown: () => fadeOutDown,
  fadeOutDownBig: () => fadeOutDownBig,
  fadeOutLeft: () => fadeOutLeft,
  fadeOutLeftBig: () => fadeOutLeftBig,
  fadeOutRight: () => fadeOutRight,
  fadeOutRightBig: () => fadeOutRightBig,
  fadeOutTopLeft: () => fadeOutTopLeft,
  fadeOutTopRight: () => fadeOutTopRight,
  fadeOutUp: () => fadeOutUp,
  fadeOutUpBig: () => fadeOutUpBig,
  flash: () => flash,
  flip: () => flip3,
  flipInX: () => flipInX,
  flipInY: () => flipInY,
  flipOutX: () => flipOutX,
  flipOutY: () => flipOutY,
  headShake: () => headShake,
  heartBeat: () => heartBeat,
  hinge: () => hinge,
  jackInTheBox: () => jackInTheBox,
  jello: () => jello,
  lightSpeedInLeft: () => lightSpeedInLeft,
  lightSpeedInRight: () => lightSpeedInRight,
  lightSpeedOutLeft: () => lightSpeedOutLeft,
  lightSpeedOutRight: () => lightSpeedOutRight,
  pulse: () => pulse,
  rollIn: () => rollIn,
  rollOut: () => rollOut,
  rotateIn: () => rotateIn,
  rotateInDownLeft: () => rotateInDownLeft,
  rotateInDownRight: () => rotateInDownRight,
  rotateInUpLeft: () => rotateInUpLeft,
  rotateInUpRight: () => rotateInUpRight,
  rotateOut: () => rotateOut,
  rotateOutDownLeft: () => rotateOutDownLeft,
  rotateOutDownRight: () => rotateOutDownRight,
  rotateOutUpLeft: () => rotateOutUpLeft,
  rotateOutUpRight: () => rotateOutUpRight,
  rubberBand: () => rubberBand,
  shake: () => shake,
  shakeX: () => shakeX,
  shakeY: () => shakeY,
  slideInDown: () => slideInDown,
  slideInLeft: () => slideInLeft,
  slideInRight: () => slideInRight,
  slideInUp: () => slideInUp,
  slideOutDown: () => slideOutDown,
  slideOutLeft: () => slideOutLeft,
  slideOutRight: () => slideOutRight,
  slideOutUp: () => slideOutUp,
  swing: () => swing,
  tada: () => tada,
  wobble: () => wobble,
  zoomIn: () => zoomIn,
  zoomInDown: () => zoomInDown,
  zoomInLeft: () => zoomInLeft,
  zoomInRight: () => zoomInRight,
  zoomInUp: () => zoomInUp,
  zoomOut: () => zoomOut,
  zoomOutDown: () => zoomOutDown,
  zoomOutLeft: () => zoomOutLeft,
  zoomOutRight: () => zoomOutRight,
  zoomOutUp: () => zoomOutUp
});

// src/node_modules/@shoelace-style/animations/dist/attention_seekers/bounce.js
var bounce = [
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", transform: "translate3d(0, 0, 0)" },
  { offset: 0.2, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", transform: "translate3d(0, 0, 0)" },
  { offset: 0.4, easing: "cubic-bezier(0.755, 0.05, 0.855, 0.06)", transform: "translate3d(0, -30px, 0) scaleY(1.1)" },
  { offset: 0.43, easing: "cubic-bezier(0.755, 0.05, 0.855, 0.06)", transform: "translate3d(0, -30px, 0) scaleY(1.1)" },
  { offset: 0.53, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", transform: "translate3d(0, 0, 0)" },
  { offset: 0.7, easing: "cubic-bezier(0.755, 0.05, 0.855, 0.06)", transform: "translate3d(0, -15px, 0) scaleY(1.05)" },
  {
    offset: 0.8,
    "transition-timing-function": "cubic-bezier(0.215, 0.61, 0.355, 1)",
    transform: "translate3d(0, 0, 0) scaleY(0.95)"
  },
  { offset: 0.9, transform: "translate3d(0, -4px, 0) scaleY(1.02)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/attention_seekers/flash.js
var flash = [
  { offset: 0, opacity: "1" },
  { offset: 0.25, opacity: "0" },
  { offset: 0.5, opacity: "1" },
  { offset: 0.75, opacity: "0" },
  { offset: 1, opacity: "1" }
];

// src/node_modules/@shoelace-style/animations/dist/attention_seekers/headShake.js
var headShake = [
  { offset: 0, transform: "translateX(0)" },
  { offset: 0.065, transform: "translateX(-6px) rotateY(-9deg)" },
  { offset: 0.185, transform: "translateX(5px) rotateY(7deg)" },
  { offset: 0.315, transform: "translateX(-3px) rotateY(-5deg)" },
  { offset: 0.435, transform: "translateX(2px) rotateY(3deg)" },
  { offset: 0.5, transform: "translateX(0)" }
];

// src/node_modules/@shoelace-style/animations/dist/attention_seekers/heartBeat.js
var heartBeat = [
  { offset: 0, transform: "scale(1)" },
  { offset: 0.14, transform: "scale(1.3)" },
  { offset: 0.28, transform: "scale(1)" },
  { offset: 0.42, transform: "scale(1.3)" },
  { offset: 0.7, transform: "scale(1)" }
];

// src/node_modules/@shoelace-style/animations/dist/attention_seekers/jello.js
var jello = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 0.111, transform: "translate3d(0, 0, 0)" },
  { offset: 0.222, transform: "skewX(-12.5deg) skewY(-12.5deg)" },
  { offset: 0.33299999999999996, transform: "skewX(6.25deg) skewY(6.25deg)" },
  { offset: 0.444, transform: "skewX(-3.125deg) skewY(-3.125deg)" },
  { offset: 0.555, transform: "skewX(1.5625deg) skewY(1.5625deg)" },
  { offset: 0.6659999999999999, transform: "skewX(-0.78125deg) skewY(-0.78125deg)" },
  { offset: 0.777, transform: "skewX(0.390625deg) skewY(0.390625deg)" },
  { offset: 0.888, transform: "skewX(-0.1953125deg) skewY(-0.1953125deg)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/attention_seekers/pulse.js
var pulse = [
  { offset: 0, transform: "scale3d(1, 1, 1)" },
  { offset: 0.5, transform: "scale3d(1.05, 1.05, 1.05)" },
  { offset: 1, transform: "scale3d(1, 1, 1)" }
];

// src/node_modules/@shoelace-style/animations/dist/attention_seekers/rubberBand.js
var rubberBand = [
  { offset: 0, transform: "scale3d(1, 1, 1)" },
  { offset: 0.3, transform: "scale3d(1.25, 0.75, 1)" },
  { offset: 0.4, transform: "scale3d(0.75, 1.25, 1)" },
  { offset: 0.5, transform: "scale3d(1.15, 0.85, 1)" },
  { offset: 0.65, transform: "scale3d(0.95, 1.05, 1)" },
  { offset: 0.75, transform: "scale3d(1.05, 0.95, 1)" },
  { offset: 1, transform: "scale3d(1, 1, 1)" }
];

// src/node_modules/@shoelace-style/animations/dist/attention_seekers/shake.js
var shake = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 0.1, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.2, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.3, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.4, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.5, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.6, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.7, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.8, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.9, transform: "translate3d(-10px, 0, 0)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/attention_seekers/shakeX.js
var shakeX = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 0.1, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.2, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.3, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.4, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.5, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.6, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.7, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.8, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.9, transform: "translate3d(-10px, 0, 0)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/attention_seekers/shakeY.js
var shakeY = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 0.1, transform: "translate3d(0, -10px, 0)" },
  { offset: 0.2, transform: "translate3d(0, 10px, 0)" },
  { offset: 0.3, transform: "translate3d(0, -10px, 0)" },
  { offset: 0.4, transform: "translate3d(0, 10px, 0)" },
  { offset: 0.5, transform: "translate3d(0, -10px, 0)" },
  { offset: 0.6, transform: "translate3d(0, 10px, 0)" },
  { offset: 0.7, transform: "translate3d(0, -10px, 0)" },
  { offset: 0.8, transform: "translate3d(0, 10px, 0)" },
  { offset: 0.9, transform: "translate3d(0, -10px, 0)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/attention_seekers/swing.js
var swing = [
  { offset: 0.2, transform: "rotate3d(0, 0, 1, 15deg)" },
  { offset: 0.4, transform: "rotate3d(0, 0, 1, -10deg)" },
  { offset: 0.6, transform: "rotate3d(0, 0, 1, 5deg)" },
  { offset: 0.8, transform: "rotate3d(0, 0, 1, -5deg)" },
  { offset: 1, transform: "rotate3d(0, 0, 1, 0deg)" }
];

// src/node_modules/@shoelace-style/animations/dist/attention_seekers/tada.js
var tada = [
  { offset: 0, transform: "scale3d(1, 1, 1)" },
  { offset: 0.1, transform: "scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.2, transform: "scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.3, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)" },
  { offset: 0.4, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.5, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)" },
  { offset: 0.6, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.7, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)" },
  { offset: 0.8, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.9, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)" },
  { offset: 1, transform: "scale3d(1, 1, 1)" }
];

// src/node_modules/@shoelace-style/animations/dist/attention_seekers/wobble.js
var wobble = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 0.15, transform: "translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg)" },
  { offset: 0.3, transform: "translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg)" },
  { offset: 0.45, transform: "translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.6, transform: "translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg)" },
  { offset: 0.75, transform: "translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/back_entrances/backInDown.js
var backInDown = [
  { offset: 0, transform: "translateY(-1200px) scale(0.7)", opacity: "0.7" },
  { offset: 0.8, transform: "translateY(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "scale(1)", opacity: "1" }
];

// src/node_modules/@shoelace-style/animations/dist/back_entrances/backInLeft.js
var backInLeft = [
  { offset: 0, transform: "translateX(-2000px) scale(0.7)", opacity: "0.7" },
  { offset: 0.8, transform: "translateX(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "scale(1)", opacity: "1" }
];

// src/node_modules/@shoelace-style/animations/dist/back_entrances/backInRight.js
var backInRight = [
  { offset: 0, transform: "translateX(2000px) scale(0.7)", opacity: "0.7" },
  { offset: 0.8, transform: "translateX(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "scale(1)", opacity: "1" }
];

// src/node_modules/@shoelace-style/animations/dist/back_entrances/backInUp.js
var backInUp = [
  { offset: 0, transform: "translateY(1200px) scale(0.7)", opacity: "0.7" },
  { offset: 0.8, transform: "translateY(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "scale(1)", opacity: "1" }
];

// src/node_modules/@shoelace-style/animations/dist/back_exits/backOutDown.js
var backOutDown = [
  { offset: 0, transform: "scale(1)", opacity: "1" },
  { offset: 0.2, transform: "translateY(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "translateY(700px) scale(0.7)", opacity: "0.7" }
];

// src/node_modules/@shoelace-style/animations/dist/back_exits/backOutLeft.js
var backOutLeft = [
  { offset: 0, transform: "scale(1)", opacity: "1" },
  { offset: 0.2, transform: "translateX(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "translateX(-2000px) scale(0.7)", opacity: "0.7" }
];

// src/node_modules/@shoelace-style/animations/dist/back_exits/backOutRight.js
var backOutRight = [
  { offset: 0, transform: "scale(1)", opacity: "1" },
  { offset: 0.2, transform: "translateX(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "translateX(2000px) scale(0.7)", opacity: "0.7" }
];

// src/node_modules/@shoelace-style/animations/dist/back_exits/backOutUp.js
var backOutUp = [
  { offset: 0, transform: "scale(1)", opacity: "1" },
  { offset: 0.2, transform: "translateY(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "translateY(-700px) scale(0.7)", opacity: "0.7" }
];

// src/node_modules/@shoelace-style/animations/dist/bouncing_entrances/bounceIn.js
var bounceIn = [
  { offset: 0, opacity: "0", transform: "scale3d(0.3, 0.3, 0.3)" },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.2, transform: "scale3d(1.1, 1.1, 1.1)" },
  { offset: 0.2, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.4, transform: "scale3d(0.9, 0.9, 0.9)" },
  { offset: 0.4, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.6, opacity: "1", transform: "scale3d(1.03, 1.03, 1.03)" },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.8, transform: "scale3d(0.97, 0.97, 0.97)" },
  { offset: 0.8, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, opacity: "1", transform: "scale3d(1, 1, 1)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" }
];

// src/node_modules/@shoelace-style/animations/dist/bouncing_entrances/bounceInDown.js
var bounceInDown = [
  { offset: 0, opacity: "0", transform: "translate3d(0, -3000px, 0) scaleY(3)" },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.6, opacity: "1", transform: "translate3d(0, 25px, 0) scaleY(0.9)" },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.75, transform: "translate3d(0, -10px, 0) scaleY(0.95)" },
  { offset: 0.75, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.9, transform: "translate3d(0, 5px, 0) scaleY(0.985)" },
  { offset: 0.9, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" }
];

// src/node_modules/@shoelace-style/animations/dist/bouncing_entrances/bounceInLeft.js
var bounceInLeft = [
  { offset: 0, opacity: "0", transform: "translate3d(-3000px, 0, 0) scaleX(3)" },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.6, opacity: "1", transform: "translate3d(25px, 0, 0) scaleX(1)" },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.75, transform: "translate3d(-10px, 0, 0) scaleX(0.98)" },
  { offset: 0.75, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.9, transform: "translate3d(5px, 0, 0) scaleX(0.995)" },
  { offset: 0.9, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" }
];

// src/node_modules/@shoelace-style/animations/dist/bouncing_entrances/bounceInRight.js
var bounceInRight = [
  { offset: 0, opacity: "0", transform: "translate3d(3000px, 0, 0) scaleX(3)" },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.6, opacity: "1", transform: "translate3d(-25px, 0, 0) scaleX(1)" },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.75, transform: "translate3d(10px, 0, 0) scaleX(0.98)" },
  { offset: 0.75, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.9, transform: "translate3d(-5px, 0, 0) scaleX(0.995)" },
  { offset: 0.9, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" }
];

// src/node_modules/@shoelace-style/animations/dist/bouncing_entrances/bounceInUp.js
var bounceInUp = [
  { offset: 0, opacity: "0", transform: "translate3d(0, 3000px, 0) scaleY(5)" },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.6, opacity: "1", transform: "translate3d(0, -20px, 0) scaleY(0.9)" },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.75, transform: "translate3d(0, 10px, 0) scaleY(0.95)" },
  { offset: 0.75, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.9, transform: "translate3d(0, -5px, 0) scaleY(0.985)" },
  { offset: 0.9, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" }
];

// src/node_modules/@shoelace-style/animations/dist/bouncing_exits/bounceOut.js
var bounceOut = [
  { offset: 0.2, transform: "scale3d(0.9, 0.9, 0.9)" },
  { offset: 0.5, opacity: "1", transform: "scale3d(1.1, 1.1, 1.1)" },
  { offset: 0.55, opacity: "1", transform: "scale3d(1.1, 1.1, 1.1)" },
  { offset: 1, opacity: "0", transform: "scale3d(0.3, 0.3, 0.3)" }
];

// src/node_modules/@shoelace-style/animations/dist/bouncing_exits/bounceOutDown.js
var bounceOutDown = [
  { offset: 0.2, transform: "translate3d(0, 10px, 0) scaleY(0.985)" },
  { offset: 0.4, opacity: "1", transform: "translate3d(0, -20px, 0) scaleY(0.9)" },
  { offset: 0.45, opacity: "1", transform: "translate3d(0, -20px, 0) scaleY(0.9)" },
  { offset: 1, opacity: "0", transform: "translate3d(0, 2000px, 0) scaleY(3)" }
];

// src/node_modules/@shoelace-style/animations/dist/bouncing_exits/bounceOutLeft.js
var bounceOutLeft = [
  { offset: 0.2, opacity: "1", transform: "translate3d(20px, 0, 0) scaleX(0.9)" },
  { offset: 1, opacity: "0", transform: "translate3d(-2000px, 0, 0) scaleX(2)" }
];

// src/node_modules/@shoelace-style/animations/dist/bouncing_exits/bounceOutRight.js
var bounceOutRight = [
  { offset: 0.2, opacity: "1", transform: "translate3d(-20px, 0, 0) scaleX(0.9)" },
  { offset: 1, opacity: "0", transform: "translate3d(2000px, 0, 0) scaleX(2)" }
];

// src/node_modules/@shoelace-style/animations/dist/bouncing_exits/bounceOutUp.js
var bounceOutUp = [
  { offset: 0.2, transform: "translate3d(0, -10px, 0) scaleY(0.985)" },
  { offset: 0.4, opacity: "1", transform: "translate3d(0, 20px, 0) scaleY(0.9)" },
  { offset: 0.45, opacity: "1", transform: "translate3d(0, 20px, 0) scaleY(0.9)" },
  { offset: 1, opacity: "0", transform: "translate3d(0, -2000px, 0) scaleY(3)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_entrances/fadeIn.js
var fadeIn = [
  { offset: 0, opacity: "0" },
  { offset: 1, opacity: "1" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_entrances/fadeInBottomLeft.js
var fadeInBottomLeft = [
  { offset: 0, opacity: "0", transform: "translate3d(-100%, 100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_entrances/fadeInBottomRight.js
var fadeInBottomRight = [
  { offset: 0, opacity: "0", transform: "translate3d(100%, 100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_entrances/fadeInDown.js
var fadeInDown = [
  { offset: 0, opacity: "0", transform: "translate3d(0, -100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_entrances/fadeInDownBig.js
var fadeInDownBig = [
  { offset: 0, opacity: "0", transform: "translate3d(0, -2000px, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_entrances/fadeInLeft.js
var fadeInLeft = [
  { offset: 0, opacity: "0", transform: "translate3d(-100%, 0, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_entrances/fadeInLeftBig.js
var fadeInLeftBig = [
  { offset: 0, opacity: "0", transform: "translate3d(-2000px, 0, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_entrances/fadeInRight.js
var fadeInRight = [
  { offset: 0, opacity: "0", transform: "translate3d(100%, 0, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_entrances/fadeInRightBig.js
var fadeInRightBig = [
  { offset: 0, opacity: "0", transform: "translate3d(2000px, 0, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_entrances/fadeInTopLeft.js
var fadeInTopLeft = [
  { offset: 0, opacity: "0", transform: "translate3d(-100%, -100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_entrances/fadeInTopRight.js
var fadeInTopRight = [
  { offset: 0, opacity: "0", transform: "translate3d(100%, -100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_entrances/fadeInUp.js
var fadeInUp = [
  { offset: 0, opacity: "0", transform: "translate3d(0, 100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_entrances/fadeInUpBig.js
var fadeInUpBig = [
  { offset: 0, opacity: "0", transform: "translate3d(0, 2000px, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_exits/fadeOut.js
var fadeOut = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_exits/fadeOutBottomLeft.js
var fadeOutBottomLeft = [
  { offset: 0, opacity: "1", transform: "translate3d(0, 0, 0)" },
  { offset: 1, opacity: "0", transform: "translate3d(-100%, 100%, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_exits/fadeOutBottomRight.js
var fadeOutBottomRight = [
  { offset: 0, opacity: "1", transform: "translate3d(0, 0, 0)" },
  { offset: 1, opacity: "0", transform: "translate3d(100%, 100%, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_exits/fadeOutDown.js
var fadeOutDown = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(0, 100%, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_exits/fadeOutDownBig.js
var fadeOutDownBig = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(0, 2000px, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_exits/fadeOutLeft.js
var fadeOutLeft = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(-100%, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_exits/fadeOutLeftBig.js
var fadeOutLeftBig = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(-2000px, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_exits/fadeOutRight.js
var fadeOutRight = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(100%, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_exits/fadeOutRightBig.js
var fadeOutRightBig = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(2000px, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_exits/fadeOutTopLeft.js
var fadeOutTopLeft = [
  { offset: 0, opacity: "1", transform: "translate3d(0, 0, 0)" },
  { offset: 1, opacity: "0", transform: "translate3d(-100%, -100%, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_exits/fadeOutTopRight.js
var fadeOutTopRight = [
  { offset: 0, opacity: "1", transform: "translate3d(0, 0, 0)" },
  { offset: 1, opacity: "0", transform: "translate3d(100%, -100%, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_exits/fadeOutUp.js
var fadeOutUp = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(0, -100%, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/fading_exits/fadeOutUpBig.js
var fadeOutUpBig = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(0, -2000px, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/flippers/flip.js
var flip3 = [
  {
    offset: 0,
    transform: "perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, -360deg)",
    easing: "ease-out"
  },
  {
    offset: 0.4,
    transform: "perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)\n      rotate3d(0, 1, 0, -190deg)",
    easing: "ease-out"
  },
  {
    offset: 0.5,
    transform: "perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)\n      rotate3d(0, 1, 0, -170deg)",
    easing: "ease-in"
  },
  {
    offset: 0.8,
    transform: "perspective(400px) scale3d(0.95, 0.95, 0.95) translate3d(0, 0, 0)\n      rotate3d(0, 1, 0, 0deg)",
    easing: "ease-in"
  },
  {
    offset: 1,
    transform: "perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, 0deg)",
    easing: "ease-in"
  }
];

// src/node_modules/@shoelace-style/animations/dist/flippers/flipInX.js
var flipInX = [
  { offset: 0, transform: "perspective(400px) rotate3d(1, 0, 0, 90deg)", easing: "ease-in", opacity: "0" },
  { offset: 0.4, transform: "perspective(400px) rotate3d(1, 0, 0, -20deg)", easing: "ease-in" },
  { offset: 0.6, transform: "perspective(400px) rotate3d(1, 0, 0, 10deg)", opacity: "1" },
  { offset: 0.8, transform: "perspective(400px) rotate3d(1, 0, 0, -5deg)" },
  { offset: 1, transform: "perspective(400px)" }
];

// src/node_modules/@shoelace-style/animations/dist/flippers/flipInY.js
var flipInY = [
  { offset: 0, transform: "perspective(400px) rotate3d(0, 1, 0, 90deg)", easing: "ease-in", opacity: "0" },
  { offset: 0.4, transform: "perspective(400px) rotate3d(0, 1, 0, -20deg)", easing: "ease-in" },
  { offset: 0.6, transform: "perspective(400px) rotate3d(0, 1, 0, 10deg)", opacity: "1" },
  { offset: 0.8, transform: "perspective(400px) rotate3d(0, 1, 0, -5deg)" },
  { offset: 1, transform: "perspective(400px)" }
];

// src/node_modules/@shoelace-style/animations/dist/flippers/flipOutX.js
var flipOutX = [
  { offset: 0, transform: "perspective(400px)" },
  { offset: 0.3, transform: "perspective(400px) rotate3d(1, 0, 0, -20deg)", opacity: "1" },
  { offset: 1, transform: "perspective(400px) rotate3d(1, 0, 0, 90deg)", opacity: "0" }
];

// src/node_modules/@shoelace-style/animations/dist/flippers/flipOutY.js
var flipOutY = [
  { offset: 0, transform: "perspective(400px)" },
  { offset: 0.3, transform: "perspective(400px) rotate3d(0, 1, 0, -15deg)", opacity: "1" },
  { offset: 1, transform: "perspective(400px) rotate3d(0, 1, 0, 90deg)", opacity: "0" }
];

// src/node_modules/@shoelace-style/animations/dist/lightspeed/lightSpeedInLeft.js
var lightSpeedInLeft = [
  { offset: 0, transform: "translate3d(-100%, 0, 0) skewX(30deg)", opacity: "0" },
  { offset: 0.6, transform: "skewX(-20deg)", opacity: "1" },
  { offset: 0.8, transform: "skewX(5deg)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/lightspeed/lightSpeedInRight.js
var lightSpeedInRight = [
  { offset: 0, transform: "translate3d(100%, 0, 0) skewX(-30deg)", opacity: "0" },
  { offset: 0.6, transform: "skewX(20deg)", opacity: "1" },
  { offset: 0.8, transform: "skewX(-5deg)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/lightspeed/lightSpeedOutLeft.js
var lightSpeedOutLeft = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "translate3d(-100%, 0, 0) skewX(-30deg)", opacity: "0" }
];

// src/node_modules/@shoelace-style/animations/dist/lightspeed/lightSpeedOutRight.js
var lightSpeedOutRight = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "translate3d(100%, 0, 0) skewX(30deg)", opacity: "0" }
];

// src/node_modules/@shoelace-style/animations/dist/rotating_entrances/rotateIn.js
var rotateIn = [
  { offset: 0, transform: "rotate3d(0, 0, 1, -200deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" }
];

// src/node_modules/@shoelace-style/animations/dist/rotating_entrances/rotateInDownLeft.js
var rotateInDownLeft = [
  { offset: 0, transform: "rotate3d(0, 0, 1, -45deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" }
];

// src/node_modules/@shoelace-style/animations/dist/rotating_entrances/rotateInDownRight.js
var rotateInDownRight = [
  { offset: 0, transform: "rotate3d(0, 0, 1, 45deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" }
];

// src/node_modules/@shoelace-style/animations/dist/rotating_entrances/rotateInUpLeft.js
var rotateInUpLeft = [
  { offset: 0, transform: "rotate3d(0, 0, 1, 45deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" }
];

// src/node_modules/@shoelace-style/animations/dist/rotating_entrances/rotateInUpRight.js
var rotateInUpRight = [
  { offset: 0, transform: "rotate3d(0, 0, 1, -90deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" }
];

// src/node_modules/@shoelace-style/animations/dist/rotating_exits/rotateOut.js
var rotateOut = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, 200deg)", opacity: "0" }
];

// src/node_modules/@shoelace-style/animations/dist/rotating_exits/rotateOutDownLeft.js
var rotateOutDownLeft = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, 45deg)", opacity: "0" }
];

// src/node_modules/@shoelace-style/animations/dist/rotating_exits/rotateOutDownRight.js
var rotateOutDownRight = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, -45deg)", opacity: "0" }
];

// src/node_modules/@shoelace-style/animations/dist/rotating_exits/rotateOutUpLeft.js
var rotateOutUpLeft = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, -45deg)", opacity: "0" }
];

// src/node_modules/@shoelace-style/animations/dist/rotating_exits/rotateOutUpRight.js
var rotateOutUpRight = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, 90deg)", opacity: "0" }
];

// src/node_modules/@shoelace-style/animations/dist/sliding_entrances/slideInDown.js
var slideInDown = [
  { offset: 0, transform: "translate3d(0, -100%, 0)", visibility: "visible" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/sliding_entrances/slideInLeft.js
var slideInLeft = [
  { offset: 0, transform: "translate3d(-100%, 0, 0)", visibility: "visible" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/sliding_entrances/slideInRight.js
var slideInRight = [
  { offset: 0, transform: "translate3d(100%, 0, 0)", visibility: "visible" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/sliding_entrances/slideInUp.js
var slideInUp = [
  { offset: 0, transform: "translate3d(0, 100%, 0)", visibility: "visible" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/sliding_exits/slideOutDown.js
var slideOutDown = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 1, visibility: "hidden", transform: "translate3d(0, 100%, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/sliding_exits/slideOutLeft.js
var slideOutLeft = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 1, visibility: "hidden", transform: "translate3d(-100%, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/sliding_exits/slideOutRight.js
var slideOutRight = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 1, visibility: "hidden", transform: "translate3d(100%, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/sliding_exits/slideOutUp.js
var slideOutUp = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 1, visibility: "hidden", transform: "translate3d(0, -100%, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/specials/hinge.js
var hinge = [
  { offset: 0, easing: "ease-in-out" },
  { offset: 0.2, transform: "rotate3d(0, 0, 1, 80deg)", easing: "ease-in-out" },
  { offset: 0.4, transform: "rotate3d(0, 0, 1, 60deg)", easing: "ease-in-out", opacity: "1" },
  { offset: 0.6, transform: "rotate3d(0, 0, 1, 80deg)", easing: "ease-in-out" },
  { offset: 0.8, transform: "rotate3d(0, 0, 1, 60deg)", easing: "ease-in-out", opacity: "1" },
  { offset: 1, transform: "translate3d(0, 700px, 0)", opacity: "0" }
];

// src/node_modules/@shoelace-style/animations/dist/specials/jackInTheBox.js
var jackInTheBox = [
  { offset: 0, opacity: "0", transform: "scale(0.1) rotate(30deg)", "transform-origin": "center bottom" },
  { offset: 0.5, transform: "rotate(-10deg)" },
  { offset: 0.7, transform: "rotate(3deg)" },
  { offset: 1, opacity: "1", transform: "scale(1)" }
];

// src/node_modules/@shoelace-style/animations/dist/specials/rollIn.js
var rollIn = [
  { offset: 0, opacity: "0", transform: "translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/specials/rollOut.js
var rollOut = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg)" }
];

// src/node_modules/@shoelace-style/animations/dist/zooming_entrances/zoomIn.js
var zoomIn = [
  { offset: 0, opacity: "0", transform: "scale3d(0.3, 0.3, 0.3)" },
  { offset: 0.5, opacity: "1" }
];

// src/node_modules/@shoelace-style/animations/dist/zooming_entrances/zoomInDown.js
var zoomInDown = [
  {
    offset: 0,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, -1000px, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)"
  },
  {
    offset: 0.6,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)"
  }
];

// src/node_modules/@shoelace-style/animations/dist/zooming_entrances/zoomInLeft.js
var zoomInLeft = [
  {
    offset: 0,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(-1000px, 0, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)"
  },
  {
    offset: 0.6,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(10px, 0, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)"
  }
];

// src/node_modules/@shoelace-style/animations/dist/zooming_entrances/zoomInRight.js
var zoomInRight = [
  {
    offset: 0,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(1000px, 0, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)"
  },
  {
    offset: 0.6,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(-10px, 0, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)"
  }
];

// src/node_modules/@shoelace-style/animations/dist/zooming_entrances/zoomInUp.js
var zoomInUp = [
  {
    offset: 0,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, 1000px, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)"
  },
  {
    offset: 0.6,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)"
  }
];

// src/node_modules/@shoelace-style/animations/dist/zooming_exits/zoomOut.js
var zoomOut = [
  { offset: 0, opacity: "1" },
  { offset: 0.5, opacity: "0", transform: "scale3d(0.3, 0.3, 0.3)" },
  { offset: 1, opacity: "0" }
];

// src/node_modules/@shoelace-style/animations/dist/zooming_exits/zoomOutDown.js
var zoomOutDown = [
  {
    offset: 0.4,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)"
  },
  {
    offset: 1,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, 2000px, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)"
  }
];

// src/node_modules/@shoelace-style/animations/dist/zooming_exits/zoomOutLeft.js
var zoomOutLeft = [
  { offset: 0.4, opacity: "1", transform: "scale3d(0.475, 0.475, 0.475) translate3d(42px, 0, 0)" },
  { offset: 1, opacity: "0", transform: "scale(0.1) translate3d(-2000px, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/zooming_exits/zoomOutRight.js
var zoomOutRight = [
  { offset: 0.4, opacity: "1", transform: "scale3d(0.475, 0.475, 0.475) translate3d(-42px, 0, 0)" },
  { offset: 1, opacity: "0", transform: "scale(0.1) translate3d(2000px, 0, 0)" }
];

// src/node_modules/@shoelace-style/animations/dist/zooming_exits/zoomOutUp.js
var zoomOutUp = [
  {
    offset: 0.4,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)"
  },
  {
    offset: 1,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, -2000px, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)"
  }
];

// src/node_modules/@shoelace-style/animations/dist/easings/easings.js
var easings = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  easeInSine: "cubic-bezier(0.47, 0, 0.745, 0.715)",
  easeOutSine: "cubic-bezier(0.39, 0.575, 0.565, 1)",
  easeInOutSine: "cubic-bezier(0.445, 0.05, 0.55, 0.95)",
  easeInQuad: "cubic-bezier(0.55, 0.085, 0.68, 0.53)",
  easeOutQuad: "cubic-bezier(0.25, 0.46, 0.45, 0.94)",
  easeInOutQuad: "cubic-bezier(0.455, 0.03, 0.515, 0.955)",
  easeInCubic: "cubic-bezier(0.55, 0.055, 0.675, 0.19)",
  easeOutCubic: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  easeInOutCubic: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  easeInQuart: "cubic-bezier(0.895, 0.03, 0.685, 0.22)",
  easeOutQuart: "cubic-bezier(0.165, 0.84, 0.44, 1)",
  easeInOutQuart: "cubic-bezier(0.77, 0, 0.175, 1)",
  easeInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  easeOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  easeInOutQuint: "cubic-bezier(0.86, 0, 0.07, 1)",
  easeInExpo: "cubic-bezier(0.95, 0.05, 0.795, 0.035)",
  easeOutExpo: "cubic-bezier(0.19, 1, 0.22, 1)",
  easeInOutExpo: "cubic-bezier(1, 0, 0, 1)",
  easeInCirc: "cubic-bezier(0.6, 0.04, 0.98, 0.335)",
  easeOutCirc: "cubic-bezier(0.075, 0.82, 0.165, 1)",
  easeInOutCirc: "cubic-bezier(0.785, 0.135, 0.15, 0.86)",
  easeInBack: "cubic-bezier(0.6, -0.28, 0.735, 0.045)",
  easeOutBack: "cubic-bezier(0.175, 0.885, 0.32, 1.275)",
  easeInOutBack: "cubic-bezier(0.68, -0.55, 0.265, 1.55)"
};

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.XVVDUPMB.js
var animation_styles_default = i`
  :host {
    display: contents;
  }
`;

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.QRIYBN4J.js
var SlAnimation = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasStarted = false;
    this.name = "none";
    this.play = false;
    this.delay = 0;
    this.direction = "normal";
    this.duration = 1e3;
    this.easing = "linear";
    this.endDelay = 0;
    this.fill = "auto";
    this.iterations = Infinity;
    this.iterationStart = 0;
    this.playbackRate = 1;
    this.handleAnimationFinish = () => {
      this.play = false;
      this.hasStarted = false;
      this.emit("sl-finish");
    };
    this.handleAnimationCancel = () => {
      this.play = false;
      this.hasStarted = false;
      this.emit("sl-cancel");
    };
  }
  /** Gets and sets the current animation time. */
  get currentTime() {
    var _a24, _b;
    return (_b = (_a24 = this.animation) == null ? void 0 : _a24.currentTime) != null ? _b : 0;
  }
  set currentTime(time) {
    if (this.animation) {
      this.animation.currentTime = time;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    this.createAnimation();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.destroyAnimation();
  }
  handleSlotChange() {
    this.destroyAnimation();
    this.createAnimation();
  }
  async createAnimation() {
    var _a24, _b;
    const easing = (_a24 = dist_exports.easings[this.easing]) != null ? _a24 : this.easing;
    const keyframes = (_b = this.keyframes) != null ? _b : dist_exports[this.name];
    const slot = await this.defaultSlot;
    const element = slot.assignedElements()[0];
    if (!element || !keyframes) {
      return false;
    }
    this.destroyAnimation();
    this.animation = element.animate(keyframes, {
      delay: this.delay,
      direction: this.direction,
      duration: this.duration,
      easing,
      endDelay: this.endDelay,
      fill: this.fill,
      iterationStart: this.iterationStart,
      iterations: this.iterations
    });
    this.animation.playbackRate = this.playbackRate;
    this.animation.addEventListener("cancel", this.handleAnimationCancel);
    this.animation.addEventListener("finish", this.handleAnimationFinish);
    if (this.play) {
      this.hasStarted = true;
      this.emit("sl-start");
    } else {
      this.animation.pause();
    }
    return true;
  }
  destroyAnimation() {
    if (this.animation) {
      this.animation.cancel();
      this.animation.removeEventListener("cancel", this.handleAnimationCancel);
      this.animation.removeEventListener("finish", this.handleAnimationFinish);
      this.hasStarted = false;
    }
  }
  handleAnimationChange() {
    if (!this.hasUpdated) {
      return;
    }
    this.createAnimation();
  }
  handlePlayChange() {
    if (this.animation) {
      if (this.play && !this.hasStarted) {
        this.hasStarted = true;
        this.emit("sl-start");
      }
      if (this.play) {
        this.animation.play();
      } else {
        this.animation.pause();
      }
      return true;
    }
    return false;
  }
  handlePlaybackRateChange() {
    if (this.animation) {
      this.animation.playbackRate = this.playbackRate;
    }
  }
  /** Clears all keyframe effects caused by this animation and aborts its playback. */
  cancel() {
    var _a24;
    (_a24 = this.animation) == null ? void 0 : _a24.cancel();
  }
  /** Sets the playback time to the end of the animation corresponding to the current playback direction. */
  finish() {
    var _a24;
    (_a24 = this.animation) == null ? void 0 : _a24.finish();
  }
  render() {
    return ke` <slot @slotchange=${this.handleSlotChange}></slot> `;
  }
};
SlAnimation.styles = [component_styles_default, animation_styles_default];
__decorateClass([
  r7("slot")
], SlAnimation.prototype, "defaultSlot", 2);
__decorateClass([
  n6()
], SlAnimation.prototype, "name", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], SlAnimation.prototype, "play", 2);
__decorateClass([
  n6({ type: Number })
], SlAnimation.prototype, "delay", 2);
__decorateClass([
  n6()
], SlAnimation.prototype, "direction", 2);
__decorateClass([
  n6({ type: Number })
], SlAnimation.prototype, "duration", 2);
__decorateClass([
  n6()
], SlAnimation.prototype, "easing", 2);
__decorateClass([
  n6({ attribute: "end-delay", type: Number })
], SlAnimation.prototype, "endDelay", 2);
__decorateClass([
  n6()
], SlAnimation.prototype, "fill", 2);
__decorateClass([
  n6({ type: Number })
], SlAnimation.prototype, "iterations", 2);
__decorateClass([
  n6({ attribute: "iteration-start", type: Number })
], SlAnimation.prototype, "iterationStart", 2);
__decorateClass([
  n6({ attribute: false })
], SlAnimation.prototype, "keyframes", 2);
__decorateClass([
  n6({ attribute: "playback-rate", type: Number })
], SlAnimation.prototype, "playbackRate", 2);
__decorateClass([
  watch([
    "name",
    "delay",
    "direction",
    "duration",
    "easing",
    "endDelay",
    "fill",
    "iterations",
    "iterationsStart",
    "keyframes"
  ])
], SlAnimation.prototype, "handleAnimationChange", 1);
__decorateClass([
  watch("play")
], SlAnimation.prototype, "handlePlayChange", 1);
__decorateClass([
  watch("playbackRate")
], SlAnimation.prototype, "handlePlaybackRateChange", 1);

// src/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.JKWZTULG.js
SlAnimation.define("sl-animation");

// src/node_modules/@tabler/icons/icons/filled/file.svg
var file_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="currentColor"%0A  class="icon icon-tabler icons-tabler-filled icon-tabler-file"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M12 2l.117 .007a1 1 0 0 1 .876 .876l.007 .117v4l.005 .15a2 2 0 0 0 1.838 1.844l.157 .006h4l.117 .007a1 1 0 0 1 .876 .876l.007 .117v9a3 3 0 0 1 -2.824 2.995l-.176 .005h-10a3 3 0 0 1 -2.995 -2.824l-.005 -.176v-14a3 3 0 0 1 2.824 -2.995l.176 -.005h5z" />%0A  <path d="M19 7h-4l-.001 -4.001z" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/pencil.svg
var pencil_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-pencil"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />%0A  <path d="M13.5 6.5l4 4" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/check.svg
var check_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-check"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M5 12l5 5l10 -10" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/x.svg
var x_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-x"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M18 6l-12 12" />%0A  <path d="M6 6l12 12" />%0A</svg>';

// src/components/toggle-text-input/toggle-text-input.ts
var _saveChanges_dec, _text_dec, _hasError_dec, _isEditable_dec, _a2, _ToggleTextInput_decorators, _init2, _isEditable, _hasError, _text, _saveChanges;
_ToggleTextInput_decorators = [t4("toggle-text-input")];
var ToggleTextInput = class extends (_a2 = LitElementWw, _isEditable_dec = [r5()], _hasError_dec = [r5()], _text_dec = [n6({ type: String, attribute: true })], _saveChanges_dec = [n6({ type: Function })], _a2) {
  constructor() {
    super(...arguments);
    __privateAdd(this, _isEditable, __runInitializers(_init2, 8, this, false)), __runInitializers(_init2, 11, this);
    __privateAdd(this, _hasError, __runInitializers(_init2, 12, this, false)), __runInitializers(_init2, 15, this);
    __privateAdd(this, _text, __runInitializers(_init2, 16, this, "")), __runInitializers(_init2, 19, this);
    __privateAdd(this, _saveChanges, __runInitializers(_init2, 20, this, (string) => {
    })), __runInitializers(_init2, 23, this);
  }
  //registering custom elements used in the widget
  static get scopedElements() {
    return {
      "sl-icon-button": icon_button_default
    };
  }
  static get styles() {
    return i`
      .horizontal {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 5px;
        width: 260px;
      }

      input {
        font-weight: bold;
        color: #3f3f46;
        margin: 0;
        padding: 0;
        border: none;
        border-bottom: 1px solid #d4d4d8;
        width: 180px;
        box-sizing: border-box;
      }

      input.error {
        border-bottom: 1px solid red;
      }

      p {
        font-size: 16px;
        font-weight: bold;
        color: #3f3f46;
        margin: 0;
        padding: 0;
        max-width: 180px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .error-message {
        color: red;
        font-size: 12px;
        margin-top: 4px;
      }
    `;
  }
  render() {
    return ke`
      <div class="horizontal">
        ${this.isEditable ? ke`
              <input
                id="pageNameInput"
                placeholder="Enter title"
                style="margin-right: 8px;"
                value=${this.text}
                class=${this.hasError ? "error" : ""}
              />
              <sl-icon-button
                id="cancelButton"
                src=${x_default}
                style="font-size: 18px;"
                @click=${() => this.toggleRename()}
              ></sl-icon-button>
              <sl-icon-button
                id="saveButton"
                src=${check_default}
                style="font-size: 18px;"
                @click="${() => this.save()}"
              ></sl-icon-button>
            ` : ke`
              <p>${this.text}</p>
              <sl-icon-button
                id="renameToggleButton"
                src=${pencil_default}
                style="font-size: 18px;"
                @click=${() => this.toggleRename()}
              ></sl-icon-button>
            `}
      </div>
      ${this.hasError ? ke`<div class="error-message">The title cannot be empty</div>` : ""}
    `;
  }
  toggleRename() {
    this.isEditable = !this.isEditable;
    this.hasError = false;
  }
  save() {
    const input = this.shadowRoot.querySelector(
      "#pageNameInput"
    );
    if (this.validate(input.value)) {
      this.isEditable = false;
      this.hasError = false;
      this.saveChanges(input.value);
    } else {
      this.hasError = true;
    }
  }
  validate(value) {
    return value.trim() !== "";
  }
};
_init2 = __decoratorStart(_a2);
_isEditable = new WeakMap();
_hasError = new WeakMap();
_text = new WeakMap();
_saveChanges = new WeakMap();
__decorateElement(_init2, 4, "isEditable", _isEditable_dec, ToggleTextInput, _isEditable);
__decorateElement(_init2, 4, "hasError", _hasError_dec, ToggleTextInput, _hasError);
__decorateElement(_init2, 4, "text", _text_dec, ToggleTextInput, _text);
__decorateElement(_init2, 4, "saveChanges", _saveChanges_dec, ToggleTextInput, _saveChanges);
ToggleTextInput = __decorateElement(_init2, 0, "ToggleTextInput", _ToggleTextInput_decorators, ToggleTextInput);
__runInitializers(_init2, 1, ToggleTextInput);

// src/node_modules/lit-html/directives/repeat.js
var Jt = (e10, s6, t8) => {
  const r9 = /* @__PURE__ */ new Map();
  for (let l3 = s6; l3 <= t8; l3++) r9.set(e10[l3], l3);
  return r9;
};
var Qt = e9(class extends i4 {
  constructor(e10) {
    if (super(e10), e10.type !== t6.CHILD) throw Error("repeat() can only be used in text expressions");
  }
  dt(e10, s6, t8) {
    let r9;
    void 0 === t8 ? t8 = s6 : void 0 !== s6 && (r9 = s6);
    const l3 = [], o7 = [];
    let i5 = 0;
    for (const s7 of e10) l3[i5] = r9 ? r9(s7, i5) : i5, o7[i5] = t8(s7, i5), i5++;
    return { values: o7, keys: l3 };
  }
  render(e10, s6, t8) {
    return this.dt(e10, s6, t8).values;
  }
  update(e10, [s6, t8, r9]) {
    const l3 = ut(e10), { values: o7, keys: i5 } = this.dt(s6, t8, r9);
    if (!Array.isArray(l3)) return this.ut = i5, o7;
    const n7 = this.ut ??= [], f5 = [];
    let u3, c6, d3 = 0, p3 = l3.length - 1, a3 = 0, h5 = o7.length - 1;
    for (; d3 <= p3 && a3 <= h5; ) if (null === l3[d3]) d3++;
    else if (null === l3[p3]) p3--;
    else if (n7[d3] === i5[a3]) f5[a3] = ct(l3[d3], o7[a3]), d3++, a3++;
    else if (n7[p3] === i5[h5]) f5[h5] = ct(l3[p3], o7[h5]), p3--, h5--;
    else if (n7[d3] === i5[h5]) f5[h5] = ct(l3[d3], o7[h5]), at(e10, f5[h5 + 1], l3[d3]), d3++, h5--;
    else if (n7[p3] === i5[a3]) f5[a3] = ct(l3[p3], o7[a3]), at(e10, l3[d3], l3[p3]), p3--, a3++;
    else if (void 0 === u3 && (u3 = Jt(i5, a3, h5), c6 = Jt(n7, d3, p3)), u3.has(n7[d3])) if (u3.has(n7[p3])) {
      const s7 = c6.get(i5[a3]), t9 = void 0 !== s7 ? l3[s7] : null;
      if (null === t9) {
        const s8 = at(e10, l3[d3]);
        ct(s8, o7[a3]), f5[a3] = s8;
      } else f5[a3] = ct(t9, o7[a3]), at(e10, l3[d3], t9), l3[s7] = null;
      a3++;
    } else pt(l3[p3]), p3--;
    else pt(l3[d3]), d3++;
    for (; a3 <= h5; ) {
      const s7 = at(e10, f5[h5 + 1]);
      ct(s7, o7[a3]), f5[a3++] = s7;
    }
    for (; d3 <= p3; ) {
      const e11 = l3[d3++];
      null !== e11 && pt(e11);
    }
    return this.ut = i5, dt(e10, f5), R;
  }
});

// src/node_modules/@tabler/icons/icons/outline/file.svg
var file_default2 = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-file"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M14 3v4a1 1 0 0 0 1 1h4" />%0A  <path d="M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/squares.svg
var squares_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-squares"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M8 10a2 2 0 0 1 2 -2h9a2 2 0 0 1 2 2v9a2 2 0 0 1 -2 2h-9a2 2 0 0 1 -2 -2z" />%0A  <path d="M16 8v-3a2 2 0 0 0 -2 -2h-9a2 2 0 0 0 -2 2v9a2 2 0 0 0 2 2h3" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/arrows-split-2.svg
var arrows_split_2_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-arrows-split-2"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M21 17h-5.397a5 5 0 0 1 -4.096 -2.133l-.514 -.734a5 5 0 0 0 -4.096 -2.133h-3.897" />%0A  <path d="M21 7h-5.395a5 5 0 0 0 -4.098 2.135l-.51 .73a5 5 0 0 1 -4.097 2.135h-3.9" />%0A  <path d="M18 10l3 -3l-3 -3" />%0A  <path d="M18 20l3 -3l-3 -3" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/search.svg
var search_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-search"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" />%0A  <path d="M21 21l-6 -6" />%0A</svg>';

// src/utils/gamebook-editor-state-context.ts
var editorState = n4("editorState");
var NO_NODE_SELECTED = {
  id: -1,
  inputs: {},
  outputs: {},
  class: "unselect",
  data: {}
};
var NO_COPY = {
  id: -1,
  class: "unselect",
  data: {}
};
var GamebookEditorState = class _GamebookEditorState {
  title;
  selectedNode;
  copiedNode;
  editorZoom;
  editorPosition;
  dividerPosition;
  editorIsCollapsed;
  editorContent;
  selectedContainer;
  branchIncomingContainer;
  searchTerm;
  searchResults;
  //Use observer pattern to notify main view of cahnge
  observer;
  constructor(title = "Gamebook Title", observer = null, selectedNode = NO_NODE_SELECTED, editorZoom = -1, editorPositon = { x: void 0, y: void 0 }, dividerPosition = 350, editorIsCollapsed = false, editorContent = null, copiedNode = NO_NODE_SELECTED, selectedContainer = void 0, branchIncomingContainer = void 0, searchTerm = "", searchResults = void 0) {
    this.title = title;
    this.selectedNode = selectedNode;
    this.editorZoom = editorZoom;
    this.editorPosition = editorPositon;
    this.observer = observer;
    this.dividerPosition = dividerPosition;
    this.editorIsCollapsed = editorIsCollapsed;
    this.editorContent = editorContent;
    this.copiedNode = copiedNode;
    this.selectedContainer = selectedContainer;
    this.branchIncomingContainer = branchIncomingContainer;
    this.searchTerm = searchTerm;
    this.searchResults = searchResults;
  }
  setTitle(newTitle = Math.random().toString()) {
    this.title = newTitle;
    this.notifyObservers();
  }
  setSelectedNode(node = NO_NODE_SELECTED) {
    delete node.name;
    delete node.pos_x;
    delete node.pos_y;
    delete node.html;
    delete node.typenode;
    this.selectedNode = node;
    this.notifyObservers();
  }
  setSelectedContainer(selectedContainer = void 0) {
    this.selectedContainer = selectedContainer;
    this.notifyObservers();
  }
  setBranchIncomingContainer(incomingContainer = void 0) {
    this.branchIncomingContainer = incomingContainer;
    this.notifyObservers();
  }
  setEditorZoom(zoom = -1) {
    this.editorZoom = zoom;
    this.notifyObservers();
  }
  setEditorPosition(x4 = -1, y3 = -1) {
    this.editorPosition = { x: x4, y: y3 };
    this.notifyObservers();
  }
  setDividerPosition(pos = 350) {
    this.dividerPosition = pos;
    this.notifyObservers();
  }
  setEditorIsCollapsed(isCollapsed = false) {
    this.editorIsCollapsed = isCollapsed;
    this.notifyObservers();
  }
  setEditorContent(editorContent = null) {
    let copy = editorContent;
    Object.values(copy.drawflow.Home.data).forEach((node) => {
      delete node.html;
      delete node.name;
    });
    this.editorContent = copy;
    this.notifyObservers();
  }
  setCopiedNode(node = NO_COPY) {
    delete node.name;
    delete node.inputs;
    delete node.outputs;
    delete node.pos_x;
    delete node.pos_y;
    delete node.html;
    delete node.typenode;
    delete node.html;
    this.copiedNode = node;
    this.notifyObservers();
  }
  setSearchTerm(term = "") {
    this.searchTerm = term;
    this.notifyObservers();
  }
  setSearchResults(results = void 0) {
    this.searchResults = results;
    this.notifyObservers();
  }
  // Method to register an observer
  addObserver(observer) {
    this.observer = observer;
  }
  // Method to notify all observers
  notifyObservers() {
    if (this.observer !== null) {
      this.observer();
    }
  }
  toString() {
    const stringify = JSON.stringify(
      {
        title: this.title,
        observer: this.observer,
        selectedNode: this.selectedNode,
        editorZoom: this.editorZoom,
        editorPosition: this.editorPosition,
        dividerPosition: this.dividerPosition,
        editorIsCollapsed: this.editorIsCollapsed,
        editorContent: this.editorContent,
        copiedNode: this.copiedNode,
        selectedContainer: this.selectedContainer,
        // Include selectedContainer here
        branchIncomingContainer: this.branchIncomingContainer,
        searchTerm: this.searchTerm,
        searchResults: this.searchResults
      },
      this.replacer.bind(this)
    );
    return stringify;
  }
  replacer(key, value) {
    if (key === "selectedContainer" || key === "branchIncomingContainer") {
      return this.domElementReplacer(key, value);
    }
    if (key === "editorContent") {
      if (value) {
        Object.values(value.drawflow.Home.data).forEach((node) => {
          delete node.html;
        });
      }
    }
    return value;
  }
  domElementReplacer(key, value) {
    if (value instanceof HTMLElement) {
      return {
        tagName: value.tagName,
        attributes: [...value.attributes].filter(
          (attr) => ![
            "id",
            "class",
            "contenteditable",
            "style",
            "tabindex",
            "draggable"
          ].includes(attr.name)
        ).map((attr) => ({
          name: attr.name,
          value: attr.value
        }))
      };
    }
    return value;
  }
  // Static method to deserialize from string to GamebookEditorState instance
  static fromString(serialized) {
    console.log("fromString");
    const data = JSON.parse(serialized);
    return new _GamebookEditorState(
      data.title,
      data.observer,
      data.selectedNode,
      data.editorZoom,
      data.editorPosition,
      data.dividerPosition,
      data.editorIsCollapsed,
      data.editorContent,
      data.copiedNode,
      data.selectedContainer,
      data.branchIncomingContainer,
      data.searchTerm,
      data.searchResults
    );
  }
};

// src/components/node-output-select/node-output-select.ts
var _selectElement_dec, _searchElement_dec, _searchTerm_dec, _editorStore_dec, _isOpen_dec, _inOutputList_dec, _required_dec, _disabled_dec, _outputClass_dec, _incomingNodeId_dec, _a3, _NodeOutputSelect_decorators, _init3, _incomingNodeId, _outputClass, _disabled, _required, _inOutputList, _isOpen, _editorStore, _searchTerm, _searchElement, _selectElement;
_NodeOutputSelect_decorators = [t4("node-output-select")];
var NodeOutputSelect = class extends (_a3 = h3, _incomingNodeId_dec = [n6({ type: Number })], _outputClass_dec = [n6({ type: String })], _disabled_dec = [n6({ type: Boolean })], _required_dec = [n6({ type: Boolean })], _inOutputList_dec = [n6({ type: Boolean })], _isOpen_dec = [n6({ type: Boolean })], _editorStore_dec = [c4({ context: editorState, subscribe: true }), n6({ type: Object, attribute: true, reflect: false })], _searchTerm_dec = [r5()], _searchElement_dec = [e7("sl-input")], _selectElement_dec = [e7("sl-select")], _a3) {
  constructor() {
    super(...arguments);
    __privateAdd(this, _incomingNodeId, __runInitializers(_init3, 8, this)), __runInitializers(_init3, 11, this);
    __privateAdd(this, _outputClass, __runInitializers(_init3, 12, this)), __runInitializers(_init3, 15, this);
    __privateAdd(this, _disabled, __runInitializers(_init3, 16, this)), __runInitializers(_init3, 19, this);
    __privateAdd(this, _required, __runInitializers(_init3, 20, this)), __runInitializers(_init3, 23, this);
    __privateAdd(this, _inOutputList, __runInitializers(_init3, 24, this)), __runInitializers(_init3, 27, this);
    __privateAdd(this, _isOpen, __runInitializers(_init3, 28, this)), __runInitializers(_init3, 31, this);
    __privateAdd(this, _editorStore, __runInitializers(_init3, 32, this, new GamebookEditorState("Default"))), __runInitializers(_init3, 35, this);
    __privateAdd(this, _searchTerm, __runInitializers(_init3, 36, this, "")), __runInitializers(_init3, 39, this);
    __privateAdd(this, _searchElement, __runInitializers(_init3, 40, this)), __runInitializers(_init3, 43, this);
    __privateAdd(this, _selectElement, __runInitializers(_init3, 44, this)), __runInitializers(_init3, 47, this);
  }
  /*
  
    */
  firstUpdated() {
    const openObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "attributes" && mutation.attributeName === "open") {
          this.onOpenChange(this.selectElement.hasAttribute("open"));
        }
      });
    });
    openObserver.observe(this.selectElement, { attributes: true });
  }
  /*
  
    */
  render() {
    const data = this.editorStore.editorContent.drawflow.Home.data;
    const nodeId = this.editorStore.selectedNode.id;
    const dataFiltered = Object.keys(data).filter(
      (key) => data[key].id !== nodeId && data[key].id !== Number(this.incomingNodeId)
    );
    const options = (nodeClass) => Object.keys(data).filter(
      (key) => data[key].id !== nodeId && data[key].id !== Number(this.incomingNodeId) && data[key].class === nodeClass
    ).map(
      (key) => ke`<sl-option
            value="${data[key].id}"
            class="node-option-visible ${data[key].class}"
            @mouseenter=${() => this.highlightNode(data[key].id)}
            @mouseleave=${() => this.unhighlightNode(data[key].id)}
            >${data[key].data.title}</sl-option
          >`
    );
    const hasNodesOfClass = (nodeClass) => Object.keys(data).some(
      (key) => data[key].id !== nodeId && data[key].id !== Number(this.incomingNodeId) && data[key].class === nodeClass
    );
    return ke`
      <sl-select
        placement="bottom"
        hoist
        class="${!this.editorStore.selectedNode?.outputs?.[this.outputClass]?.connections?.[0]?.node && this.required && !this.disabled ? "no-value" : ""}"
        size=${this.inOutputList ? "small" : "medium"}
        placeholder="Not connected"
        clearable
        .value=${this.editorStore.selectedNode.outputs?.[this.outputClass]?.connections?.[0]?.node ?? ""}
        @sl-input=${this._handleUserInputTargetPage}
        @mouseenter=${() => {
      if (!this.isOpen) {
        this.highlightConnection();
      }
    }}
        @mouseleave=${() => {
      if (!this.isOpen) {
        this.unhighlightConnection();
      }
    }}
        ?disabled=${this.disabled}
      >
        <div style="padding: 10px">
          <sl-input
            placeholder="Search..."
            @sl-input=${this.handleSearch}
            @click=${() => this.searchElement.focus()}
            @keydown=${this.handleKeydown}
            clearable
            class="searchInput"
          >
            <sl-icon src=${search_default} slot="prefix"></sl-icon>
          </sl-input>
        </div>
        <sl-divider></sl-divider>

        ${dataFiltered.length === 0 ? ke`<small>No nodes found</small>` : ke`
              ${hasNodesOfClass("page") || hasNodesOfClass("origin") ? ke`
                    <small class="icon-header" id="divider-page"
                      ><sl-icon src="${file_default2}"></sl-icon> Pages</small
                    >
                    ${options("page")} ${options("origin")}
                    ${hasNodesOfClass("popup") || hasNodesOfClass("branch") ? ke`<sl-divider id="divider-page"></sl-divider>` : ""}
                  ` : ""}
              ${hasNodesOfClass("popup") ? ke`
                    <small class="icon-header" id="divider-popup"
                      ><sl-icon src="${squares_default}"></sl-icon> Popup</small
                    >
                    ${options("popup")}
                    ${hasNodesOfClass("branch") ? ke`<sl-divider id="divider-popup"></sl-divider>` : ""}
                  ` : ""}
              ${hasNodesOfClass("branch") ? ke`
                    <small class="icon-header" id="divider-branch"
                      ><sl-icon src="${arrows_split_2_default}"></sl-icon> Branch</small
                    >
                    ${options("branch")}
                  ` : ""}
              <small id="no-nodes-found" style="display: none"
                >No nodes found</small
              >
            `}
      </sl-select>
    `;
  }
  /*
  
    */
  handleSearch(event) {
    const searchTerm = event.target.value.toLowerCase();
    this.searchTerm = searchTerm;
    this.shadowRoot.querySelectorAll("sl-option").forEach((option) => {
      const title = option.textContent.toLowerCase();
      option.classList.toggle(
        "node-option-visible",
        title.includes(searchTerm)
      );
      option.classList.toggle(
        "node-option-hidden",
        !title.includes(searchTerm)
      );
    });
    this._toggleDividers(
      "page",
      this.hasVisibleNodesOfClass("page") || this.hasVisibleNodesOfClass("origin")
    );
    this._toggleDividers("popup", this.hasVisibleNodesOfClass("popup"));
    this._toggleDividers("branch", this.hasVisibleNodesOfClass("branch"));
    this.shadowRoot.querySelector("#no-nodes-found").style.display = this._hasNoVisibleNodes() ? "block" : "none";
  }
  /*
  
    */
  _toggleDividers(dividerId, shouldDisplay) {
    const displayStyle = shouldDisplay ? "flex" : "none";
    this.shadowRoot.querySelectorAll(`#divider-${dividerId}`).forEach((element) => {
      element.style.display = displayStyle;
    });
  }
  /*
  
    */
  _hasNoVisibleNodes() {
    return !(this.hasVisibleNodesOfClass("page") || this.hasVisibleNodesOfClass("origin") || this.hasVisibleNodesOfClass("popup") || this.hasVisibleNodesOfClass("branch"));
  }
  /*
  
    */
  hasVisibleNodesOfClass(nodeClass) {
    return this.shadowRoot.querySelectorAll(`.node-option-visible.${nodeClass}`).length > 0;
  }
  /*
  
    */
  handleKeydown(event) {
    this.searchElement.focus();
    event.stopPropagation();
  }
  /*
  
    */
  _handleUserInputTargetPage(event) {
    if (event.target instanceof HTMLElement && event.target.tagName.toLowerCase() === "sl-select") {
      const selectedValue = event.target.value;
      const connections = this.editorStore.selectedNode?.outputs?.[this.outputClass]?.connections;
      if (connections?.[0]?.node === void 0 && selectedValue) {
        const event2 = new CustomEvent("createConnection", {
          detail: {
            outputNodeId: this.editorStore.selectedNode.id,
            inputNodeId: selectedValue,
            outputClass: this.outputClass,
            inputClass: "input_1"
          },
          bubbles: true,
          composed: true
        });
        this.dispatchEvent(event2);
      } else if (connections?.[0]?.node !== void 0 && selectedValue) {
        const removeEvent = new CustomEvent("deleteConnection", {
          detail: {
            outputNodeId: this.editorStore.selectedNode.id,
            inputNodeId: connections[0].node,
            outputClass: this.outputClass,
            inputClass: "input_1"
          },
          bubbles: true,
          composed: true
        });
        this.dispatchEvent(removeEvent);
        const createEvent = new CustomEvent("createConnection", {
          detail: {
            outputNodeId: this.editorStore.selectedNode.id,
            inputNodeId: selectedValue,
            outputClass: this.outputClass,
            inputClass: "input_1"
          },
          bubbles: true,
          composed: true
        });
        this.dispatchEvent(createEvent);
      } else if (!selectedValue) {
        const removeEvent = new CustomEvent("deleteConnection", {
          detail: {
            outputNodeId: this.editorStore.selectedNode.id,
            inputNodeId: connections?.[0]?.node,
            outputClass: this.outputClass,
            inputClass: "input_1"
          },
          bubbles: true,
          composed: true
        });
        this.dispatchEvent(removeEvent);
      }
    }
    this.requestUpdate();
  }
  /*
  
    */
  onOpenChange(isOpen) {
    this.isOpen = isOpen;
    if (isOpen) {
      this.unhighlightConnection();
      this.dispatchEvent(
        new CustomEvent("highlightOutput", {
          detail: {
            outputNodeId: this.editorStore.selectedNode.id,
            outputClass: this.outputClass
          },
          bubbles: true,
          composed: true
        })
      );
    } else {
      this.unhighlightConnection();
    }
  }
  /*
  
    */
  highlightConnection() {
    this.dispatchEvent(
      new CustomEvent("highlightConnection", {
        detail: {
          outputNodeId: this.editorStore.selectedNode.id,
          inputNodeId: this.editorStore.selectedNode?.outputs?.[this.outputClass]?.connections?.[0]?.node,
          outputClass: this.outputClass,
          inputClass: "input_1",
          highlightButton: true
        },
        bubbles: true,
        composed: true
      })
    );
  }
  /*
  
    */
  unhighlightConnection() {
    this.dispatchEvent(
      new CustomEvent("unhighlightConnection", {
        detail: {
          outputNodeId: this.editorStore.selectedNode.id,
          inputNodeId: this.editorStore.selectedNode?.outputs?.[this.outputClass]?.connections?.[0]?.node,
          outputClass: this.outputClass,
          inputClass: "input_1",
          highlightButton: true
        },
        bubbles: true,
        composed: true
      })
    );
  }
  /*
  
    */
  highlightNode(nodeId) {
    this.dispatchEvent(
      new CustomEvent("highlightNode", {
        detail: {
          nodeId
        },
        bubbles: true,
        composed: true
      })
    );
  }
  /*
  
    */
  unhighlightNode(nodeId) {
    this.dispatchEvent(
      new CustomEvent("unhighlightNode", {
        detail: {
          nodeId
        },
        bubbles: true,
        composed: true
      })
    );
  }
};
_init3 = __decoratorStart(_a3);
_incomingNodeId = new WeakMap();
_outputClass = new WeakMap();
_disabled = new WeakMap();
_required = new WeakMap();
_inOutputList = new WeakMap();
_isOpen = new WeakMap();
_editorStore = new WeakMap();
_searchTerm = new WeakMap();
_searchElement = new WeakMap();
_selectElement = new WeakMap();
__decorateElement(_init3, 4, "incomingNodeId", _incomingNodeId_dec, NodeOutputSelect, _incomingNodeId);
__decorateElement(_init3, 4, "outputClass", _outputClass_dec, NodeOutputSelect, _outputClass);
__decorateElement(_init3, 4, "disabled", _disabled_dec, NodeOutputSelect, _disabled);
__decorateElement(_init3, 4, "required", _required_dec, NodeOutputSelect, _required);
__decorateElement(_init3, 4, "inOutputList", _inOutputList_dec, NodeOutputSelect, _inOutputList);
__decorateElement(_init3, 4, "isOpen", _isOpen_dec, NodeOutputSelect, _isOpen);
__decorateElement(_init3, 4, "editorStore", _editorStore_dec, NodeOutputSelect, _editorStore);
__decorateElement(_init3, 4, "searchTerm", _searchTerm_dec, NodeOutputSelect, _searchTerm);
__decorateElement(_init3, 4, "searchElement", _searchElement_dec, NodeOutputSelect, _searchElement);
__decorateElement(_init3, 4, "selectElement", _selectElement_dec, NodeOutputSelect, _selectElement);
NodeOutputSelect = __decorateElement(_init3, 0, "NodeOutputSelect", _NodeOutputSelect_decorators, NodeOutputSelect);
__publicField(NodeOutputSelect, "styles", i`
    .node-option-visible {
      display: block;
    }
    .node-option-hidden {
      display: none;
    }

    :host([in-output-list]) sl-select {
      --sl-input-border-width: 0px;
      --sl-input-padding: 0px;
    }
    :host([in-output-list]) sl-select::part(listbox) {
      width: 250px;
      height: 250px;
    }

    :host([in-output-list]) sl-select::part(display-input) {
      border: none;
      font-weight: 500;
      color: #0084c7;
      font-size: 12px;
      width: 70px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-align: left;
    }

    sl-select::part(listbox) {
      width: 250px;
      height: 250px;
    }

    sl-select.no-value::part(combobox) {
      border: 1px solid #dc2625;
    }

    .icon-header {
      display: flex;
      align-items: center;
      gap: 7px;
    }

    .searchInput {
      --sl-input-border-width: 1px;
    }
  `);
__runInitializers(_init3, 1, NodeOutputSelect);

// src/node_modules/@tabler/icons/icons/outline/plus.svg
var plus_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-plus"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M12 5l0 14" />%0A  <path d="M5 12l14 0" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/minus.svg
var minus_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-minus"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M5 12l14 0" />%0A</svg>';

// src/node_modules/bootstrap-icons/icons/x-circle-fill.svg
var x_circle_fill_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">%0A  <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0M5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293z"/>%0A</svg>';

// src/components/node-connection-list/node-connection-list.ts
var _editorStore_dec2, _branch_dec, _input_dec, _output_dec, _a4, _NodeConnectionList_decorators, _init4, _output, _input, _branch, _editorStore2;
_NodeConnectionList_decorators = [t4("node-connection-list")];
var NodeConnectionList = class extends (_a4 = LitElementWw, _output_dec = [n6({ type: Boolean, reflect: true })], _input_dec = [n6({ type: Boolean, reflect: true })], _branch_dec = [n6({ type: Boolean, reflect: true })], _editorStore_dec2 = [c4({ context: editorState, subscribe: true }), n6({ type: Object, attribute: true, reflect: false })], _a4) {
  constructor() {
    super(...arguments);
    __privateAdd(this, _output, __runInitializers(_init4, 8, this, false)), __runInitializers(_init4, 11, this);
    __privateAdd(this, _input, __runInitializers(_init4, 12, this, false)), __runInitializers(_init4, 15, this);
    __privateAdd(this, _branch, __runInitializers(_init4, 16, this, false)), __runInitializers(_init4, 19, this);
    __privateAdd(this, _editorStore2, __runInitializers(_init4, 20, this, new GamebookEditorState("Default"))), __runInitializers(_init4, 23, this);
  }
  /*
  
  
    */
  // Registering custom elements used in the widget
  static get scopedElements() {
    return {
      "sl-button": button_default,
      "sl-icon-button": icon_button_default,
      "sl-icon": icon_default,
      "node-output-select": NodeOutputSelect
    };
  }
  /*
  
  
    */
  static get styles() {
    return i`
      .titlebar {
        display: flex;
        flex-direction: row;
        align-items: center;
        border-bottom: 1px solid #d4d4d8;
        padding-bottom: 5px;
        width: 100%;
      }

      .titlebar p {
        font-size: 12px;
        color: #3f3f46;
        margin: 0px;
        padding: 0px;
        margin-right: auto;
        max-width: 150px;
        min-width: 80px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .verticalStack {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        box-sizing: border-box;
        height: 100%;
        width: 100%;
        overflow-y: scroll;
        padding-right: 5px;

        scrollbar-width: thin;
        scrollbar-color: transparent transparent;
        position: relative;
      }

      .item {
        box-sizing: border-box;
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 5px;
        width: 100%;
        border-bottom: 1px solid #e4e4e7;
        padding-left: 5px;
        box-sizing: border-box;
      }

      .item p {
        padding: 0px;
        margin: 0px;
        font-size: 12px;
      }

      .itemButton {
        width: 100%;
      }

      sl-button::part(base) {
        justify-content: flex-start; /* Aligns the content to the left */
        text-align: left; /* Ensures text within the button is aligned left */
      }

      sl-button::part(label) {
        max-width: 130px; /* Ensures the label takes up the full width of the button */
        text-align: left; /* Aligns the text within the label to the left */
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin-right: auto;
      }

      sl-icon-button.minus::part(base) {
        padding: 0px;
      }

      sl-icon-button.add::part(base) {
        padding-left: 0px;
        padding-top: 0px;
        padding-bottom: 0px;
        padding-right: 4px;
        font-size: 16px;
      }

      .verticalStack::-webkit-scrollbar {
        width: 6px; /* Width of the scrollbar */
      }

      .verticalStack::-webkit-scrollbar-track {
        background: transparent; /* Hide the track */
      }

      .verticalStack::-webkit-scrollbar-thumb {
        background-color: #888; /* Color of the scrollbar handle */
        border-radius: 10px; /* Rounded corners */
      }

      .verticalStack::-webkit-scrollbar-thumb:hover {
        background-color: #555; /* Darker color on hover */
      }

      .no-node-message {
        font-size: 12px;
        color: darkgray;
        margin: 0px;
        padding-top: 10px;
      }

      .container {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        justify-content: start;
        width: 100%;
        height: 100%;
      }

      .branch-item {
        box-sizing: border-box;
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 5px;
        width: 100%;
        box-sizing: border-box;
      }

      .branch-item-container {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        justify-content: flex-start;
        margin-top: 10px;
        gap: 5px;
        width: 100%;
        height: 100%;
        text-align: center;
      }
    `;
  }
  /*
  
  
    */
  renderOutputs() {
    return ke`
      <div class="container">
        <div class="titlebar">
          <p>
            Outputs
            (${Object.keys(
      this.editorStore.selectedNode.outputs
    ).length.toString()})
          </p>
          <sl-icon-button @click=${this._addOutput} src=${plus_default} class="add">
          </sl-icon-button>
        </div>
        <div class="verticalStack">
          ${Qt(
      Object.entries(this.editorStore.selectedNode.outputs),
      ([output_class]) => `${this.editorStore.selectedNode.id}-${output_class}`,
      ([output_class, drawflowConnection], index) => ke`
              <div
                class="item"
                @mouseenter=${() => this.dispatchEvent(
        new CustomEvent("highlightOutput", {
          detail: {
            outputNodeId: this.editorStore.selectedNode.id,
            outputClass: output_class
          },
          bubbles: true,
          composed: true
        })
      )}
                @mouseleave=${() => this.dispatchEvent(
        new CustomEvent("unhighlightOutput", {
          detail: {
            outputNodeId: this.editorStore.selectedNode.id,
            outputClass: output_class
          },
          bubbles: true,
          composed: true
        })
      )}
              >
                <p style="color: gray">${index + 1}</p>
                <node-output-select
                  .outputClass=${output_class}
                  in-output-list
                  .inOutputList=${true}
                ></node-output-select>
                <sl-icon-button
                  class="minus"
                  src=${minus_default}
                  style="font-size: 15px;"
                  @click=${() => this._deleteOutput(output_class)}
                ></sl-icon-button>
              </div>
            `
    )}
        </div>
      </div>
    `;
  }
  /*
  
  
    */
  renderInputs() {
    return ke`
      <div class="container">
        <div class="titlebar">
          <p>
            Incoming
            (${this.editorStore.selectedNode.inputs["input_1"]?.connections.length.toString()})
          </p>
        </div>
        <div class="verticalStack">
          ${this.editorStore.selectedNode.inputs["input_1"]?.connections.map(
      (connection, index) => ke` <div class="item">
              <p style="color: gray">${index + 1}</p>
              <sl-button
                class="itemButton"
                variant="text"
                size="small"
                @mouseenter=${() => this.dispatchEvent(
        new CustomEvent("highlightConnection", {
          detail: {
            outputNodeId: connection?.node,
            inputNodeId: this.editorStore.selectedNode.id,
            outputClass: connection?.input,
            inputClass: "input_1",
            highlightButton: true
          },
          bubbles: true,
          composed: true
        })
      )}
                @mouseleave=${() => this.dispatchEvent(
        new CustomEvent("unhighlightConnection", {
          detail: {
            outputNodeId: connection?.node,
            inputNodeId: this.editorStore.selectedNode.id,
            outputClass: connection?.input,
            inputClass: "input_1",
            highlightButton: true
          },
          bubbles: true,
          composed: true
        })
      )}
              >
                ${this.editorStore.editorContent.drawflow.Home.data[connection.node].data.title}
              </sl-button>
              <sl-icon-button
                src=${x_circle_fill_default}
                style="font-size: 14px; color: #71717A;"
                @click=${() => this.dispatchEvent(
        new CustomEvent("deleteConnection", {
          detail: {
            outputNodeId: connection?.node,
            inputNodeId: this.editorStore.selectedNode.id,
            outputClass: connection?.input,
            inputClass: "input_1"
          },
          bubbles: true,
          composed: true
        })
      )}
              ></sl-icon-button>
            </div>`
    )}
        </div>
      </div>
    `;
  }
  /*
  
   
    */
  renderInputsBranch() {
    const connections = this.editorStore.selectedNode.inputs.input_1?.connections;
    const length = connections ? Object.values(connections).length : 0;
    return ke`
      <div class="container">
        <div class="titlebar">
          <p>Accessing</p>
        </div>
        <div class="verticalStack">
          ${length > 0 ? ke` ${connections.map(
      (connection, index) => ke` 
                <div class="item">
              <p style="color: gray">${index + 1}</p>
              <sl-button
                class="itemButton"
                variant="text"
                size="small"
                 @mouseenter=${() => this.dispatchEvent(
        new CustomEvent("highlightConnection", {
          detail: {
            outputNodeId: connection?.node,
            inputNodeId: this.editorStore.selectedNode.id,
            outputClass: connection?.input,
            inputClass: "input_1",
            highlightButton: true
          },
          bubbles: true,
          composed: true
        })
      )}
                @mouseleave=${() => this.dispatchEvent(
        new CustomEvent("unhighlightConnection", {
          detail: {
            outputNodeId: connection?.node,
            inputNodeId: this.editorStore.selectedNode.id,
            outputClass: connection?.input,
            inputClass: "input_1",
            highlightButton: true
          },
          bubbles: true,
          composed: true
        })
      )}
              >
                  ${this.editorStore.editorContent.drawflow.Home.data[connection.node].data.title}
              </sl-button>
                    <sl-icon-button
                      src=${x_circle_fill_default}
                      style="font-size: 14px; color: #71717A;"
                      @click=${() => this.dispatchEvent(
        new CustomEvent("deleteConnection", {
          detail: {
            outputNodeId: connection?.node,
            inputNodeId: this.editorStore.selectedNode.id,
            outputClass: connection?.input,
            inputClass: "input_1"
          },
          bubbles: true,
          composed: true
        })
      )}
                    ></sl-icon-button>
                  </div>
                </div>`
    )}` : ke` <div class="container">
                <p class="no-node-message">
                  Connect a node to create rules based on its content!
                </p>
              </div>`}
        </div>
      </div>
    `;
  }
  /*
  
  
    */
  render() {
    if (this.output) {
      return this.renderOutputs();
    } else if (this.input) {
      return this.renderInputs();
    } else if (this.branch) {
      return this.renderInputsBranch();
    } else {
      return ke`<p>Please specify either 'input' or 'output' attribute.</p>`;
    }
  }
  /*
  
  
    */
  _deleteOutput(output_class) {
    this.dispatchEvent(
      new CustomEvent("deleteOutput", {
        detail: {
          nodeId: this.editorStore.selectedNode.id,
          outputClass: output_class
        },
        bubbles: true,
        composed: true
      })
    );
  }
  /*
  
  
    */
  _addOutput() {
    this.dispatchEvent(
      new CustomEvent("addOutput", {
        detail: { nodeId: this.editorStore.selectedNode.id },
        bubbles: true,
        composed: true
      })
    );
  }
};
_init4 = __decoratorStart(_a4);
_output = new WeakMap();
_input = new WeakMap();
_branch = new WeakMap();
_editorStore2 = new WeakMap();
__decorateElement(_init4, 4, "output", _output_dec, NodeConnectionList, _output);
__decorateElement(_init4, 4, "input", _input_dec, NodeConnectionList, _input);
__decorateElement(_init4, 4, "branch", _branch_dec, NodeConnectionList, _branch);
__decorateElement(_init4, 4, "editorStore", _editorStore_dec2, NodeConnectionList, _editorStore2);
NodeConnectionList = __decorateElement(_init4, 0, "NodeConnectionList", _NodeConnectionList_decorators, NodeConnectionList);
__runInitializers(_init4, 1, NodeConnectionList);

// src/components/node-detail-view/page-node-detail-view/page-node-detail-view.ts
var _editorStore_dec3, _a5, _PageNodeDetailView_decorators, _init5, _editorStore3;
_PageNodeDetailView_decorators = [t4("page-node-detail-view")];
var PageNodeDetailView = class extends (_a5 = LitElementWw, _editorStore_dec3 = [c4({ context: editorState, subscribe: true }), n6({ type: Object, attribute: true, reflect: false })], _a5) {
  constructor() {
    super(...arguments);
    __privateAdd(this, _editorStore3, __runInitializers(_init5, 8, this, new GamebookEditorState("Default"))), __runInitializers(_init5, 11, this);
  }
  //registering custom elements used in the widget
  static get scopedElements() {
    return {
      "toggle-text-input": ToggleTextInput,
      "node-connection-list": NodeConnectionList,
      "sl-divider": divider_default,
      "sl-icon": icon_default
    };
  }
  render() {
    return ke` <div class="title-bar">
        <div class="div-icon-page">
          <sl-icon src=${file_default}></sl-icon>
        </div>
        <div class="div-title">
          <toggle-text-input
            .text=${this.editorStore.selectedNode.data.title}
            .saveChanges=${(string) => this.renameNode(string)}
          ></toggle-text-input>
          <p class="subtitle">Page</p>
        </div>
        <div class="inputOutputControls">
          <node-connection-list input></node-connection-list>
          <sl-divider vertical style="height: 100%;"></sl-divider>
          <node-connection-list output></node-connection-list>
        </div>
      </div>

      <div class="page-node-detail-view">
        <div class="preview">
          <div class="page">
            <slot></slot>
          </div>
        </div>
      </div>`;
  }
  /*
  
  
    */
  renameNode(text) {
    const event = new CustomEvent("renameSelectedNode", {
      detail: { newTitle: text },
      bubbles: true,
      composed: true
    });
    this.dispatchEvent(event);
  }
};
_init5 = __decoratorStart(_a5);
_editorStore3 = new WeakMap();
__decorateElement(_init5, 4, "editorStore", _editorStore_dec3, PageNodeDetailView, _editorStore3);
PageNodeDetailView = __decorateElement(_init5, 0, "PageNodeDetailView", _PageNodeDetailView_decorators, PageNodeDetailView);
//import CSS
__publicField(PageNodeDetailView, "styles", [page_node_detail_view_styles_default]);
__runInitializers(_init5, 1, PageNodeDetailView);

// src/components/node-detail-view/node-detail-view.styles.ts
var node_detail_view_styles_default = i`
  :host {
    box-sizing: border-box;
    height: fit-content;

    background-color: #fbfbfb;
    width: 100%;
  }

  :host * {
    box-sizing: border-box;
  }

  /* .selected-node {
  } */

  .no-node-selected {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 150px;
    background-color: #fbfbfb;
    color: darkgray;
  }

  .title-bar {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    justify-items: center;

    box-sizing: border-box;
    width: 100%;
    height: 150px;

    gap: 15px;
    padding: 15px;

    background-color: white;
    border-bottom: 1px solid #d4d4d8;
    /* 
    border-top-left-radius: 8px;
    border-top-right-radius: 8px; */
  }

  .inputOutputControls {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    justify-items: center;
  }

  node-connection-list {
    height: 100%; /* Adjust as needed */
    flex: 1; /* This makes the node-connection-list elements take up remaining space evenly */
  }

  .div-title {
    display: flex;
    flex-direction: column;
  }

  .subtitle {
    font-size: 12px;
    color: gray;
    margin: 0px;
    padding: 0px;
  }

  .div-icon-popup {
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    height: 65px; /* Remove the fixed height */
    aspect-ratio: 1;
    background-color: #9762b4;
  }

  .div-icon-page {
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    height: 65px; /* Remove the fixed height */
    aspect-ratio: 1;
    background-color: #3077ba;
  }

  .div-icon-branch {
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    height: 65px; /* Remove the fixed height */
    aspect-ratio: 1;
    background-color: #05ae9e;
  }

  .div-icon-popup sl-icon,
  .div-icon-page sl-icon,
  .div-icon-branch sl-icon {
    width: 42px;
    height: 42px;
    color: white;
  }
`;

// src/node_modules/@tabler/icons/icons/outline/align-left.svg
var align_left_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-align-left"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M4 6l16 0" />%0A  <path d="M4 12l10 0" />%0A  <path d="M4 18l14 0" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/align-right.svg
var align_right_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-align-right"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M4 6l16 0" />%0A  <path d="M10 12l10 0" />%0A  <path d="M6 18l14 0" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/align-center.svg
var align_center_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-align-center"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M4 6l16 0" />%0A  <path d="M8 12l8 0" />%0A  <path d="M6 18l12 0" />%0A</svg>';

// src/components/gamebook/gamebook-components/gamebook-button/webwriter-gamebook-button.ts
var _button_dec, _tabIndex_dec, _variant_dec, _alignment_dec, _width_dec, _outline_dec, _pill_dec, _size_dec, _name_dec, _getNodeEditor_dec, _identifier_dec, _dataTargetId_dec, _a6, _WebWriterGamebookButton_decorators, _init6, _dataTargetId, _identifier, _getNodeEditor, _name, _size, _pill, _outline, _width, _alignment, _variant, _tabIndex, _button;
_WebWriterGamebookButton_decorators = [t4("webwriter-gamebook-button")];
var WebWriterGamebookButton = class extends (_a6 = LitElementWw, _dataTargetId_dec = [n6({ type: Number, reflect: true })], _identifier_dec = [n6({ type: String, attribute: true, reflect: true })], _getNodeEditor_dec = [n6({ attribute: true })], _name_dec = [n6({ type: String, reflect: true })], _size_dec = [n6({ type: String, reflect: true })], _pill_dec = [n6({ type: Boolean, reflect: true })], _outline_dec = [n6({ type: Boolean, reflect: true })], _width_dec = [n6({ type: Number, reflect: true })], _alignment_dec = [n6({ type: String, reflect: true })], _variant_dec = [n6({ type: String, reflect: true })], _tabIndex_dec = [n6({ type: Number, attribute: true, reflect: true })], _button_dec = [e7("sl-button")], _a6) {
  constructor() {
    super(...arguments);
    __privateAdd(this, _dataTargetId, __runInitializers(_init6, 8, this)), __runInitializers(_init6, 11, this);
    __privateAdd(this, _identifier, __runInitializers(_init6, 12, this)), __runInitializers(_init6, 15, this);
    __privateAdd(this, _getNodeEditor, __runInitializers(_init6, 16, this, () => {
    })), __runInitializers(_init6, 19, this);
    __privateAdd(this, _name, __runInitializers(_init6, 20, this, "Button")), __runInitializers(_init6, 23, this);
    __privateAdd(this, _size, __runInitializers(_init6, 24, this, "small")), __runInitializers(_init6, 27, this);
    __privateAdd(this, _pill, __runInitializers(_init6, 28, this, false)), __runInitializers(_init6, 31, this);
    __privateAdd(this, _outline, __runInitializers(_init6, 32, this, false)), __runInitializers(_init6, 35, this);
    __privateAdd(this, _width, __runInitializers(_init6, 36, this, 50)), __runInitializers(_init6, 39, this);
    __privateAdd(this, _alignment, __runInitializers(_init6, 40, this, "center")), __runInitializers(_init6, 43, this);
    __privateAdd(this, _variant, __runInitializers(_init6, 44, this, "default")), __runInitializers(_init6, 47, this);
    __privateAdd(this, _tabIndex, __runInitializers(_init6, 48, this, -1)), __runInitializers(_init6, 51, this);
    __privateAdd(this, _button, __runInitializers(_init6, 52, this)), __runInitializers(_init6, 55, this);
  }
  static get scopedElements() {
    return {
      "sl-button": button_default,
      "sl-select": select_default,
      "sl-option": option_default,
      "sl-range": range_default,
      "sl-icon-button": icon_button_default,
      "sl-checkbox": checkbox_default,
      "sl-input": input_default,
      "sl-color-picker": color_picker_default,
      "sl-divider": divider_default,
      "sl-button-group": button_group_default,
      "sl-icon": icon_default
    };
  }
  static get styles() {
    return i`
      :host(.highlighted) {
        border: 1px dashed #38bdf8;
        -webkit-box-shadow: 0 4px 30px 4px #c0c0c0;
        box-shadow: 0 4px 30px 4px #c0c0c0;
      }

      :host(:not([contenteditable="true"]):not([contenteditable=""]))
        .author-only {
        display: none;
      }

      :host([contenteditable="true"]) .author-only,
      :host([contenteditable=""]) .author-only {
        display: flex;
        flex-direction: column;
        box-sizing: border-box;
        padding-left: 10px;
        padding-bottom: 10px;
        gap: 12px;
      }

      .author-only .item {
        display: flex;
        flex-direction: column;
        gap: 7px;
        padding-bottom: 10px;
      }

      .author-only p {
        margin: 0px;
        font-weight: 500;
        font-size: 15px;
        box-sizing: border-box;

        /* border-bottom: 1.5px solid #52525b; */
        color: #52525b;
      }

      .container {
        display: flex;
        width: 100%;
      }

      .controls p {
        padding: 0px;
        margin: 0px;
      }

      .active {
        background-color: #e0e0e0; /* example color for active state */
      }

      sl-button.active::part(base) {
        background-color: #efefef; /* example color for active state */
      }
    `;
  }
  firstUpdated() {
    this.shadowRoot.querySelector("#sizeSelect").value = this.size;
    this.shadowRoot.querySelector("#pillCheckbox").checked = this.pill;
    this.shadowRoot.querySelector("#outlineCheckbox").checked = this.outline;
    this.shadowRoot.querySelector("#widthRange").value = this.width;
    this.shadowRoot.querySelector("#variantSelect").value = this.variant;
    this.addEventListener("mouseover", () => {
      const parsed = this.parseConnectionIdentifier(this.identifier);
      const event = new CustomEvent("hoverButton", {
        detail: {
          outputNodeId: parsed.outputNodeId,
          inputNodeId: parsed.inputNodeId,
          outputClass: parsed.outputClass,
          inputClass: "input_1",
          highlightButton: false
        },
        bubbles: true,
        // Allows the event to bubble up through the DOM
        composed: true
        // Allows the event to pass through shadow DOM boundaries
      });
      this.dispatchEvent(event);
    });
    this.addEventListener("mouseleave", () => {
      const parsed = this.parseConnectionIdentifier(this.identifier);
      const event = new CustomEvent("leaveButton", {
        detail: {
          outputNodeId: parsed.outputNodeId,
          inputNodeId: parsed.inputNodeId,
          outputClass: parsed.outputClass,
          inputClass: "input_1",
          highlightButton: false
        },
        bubbles: true,
        // Allows the event to bubble up through the DOM
        composed: true
        // Allows the event to pass through shadow DOM boundaries
      });
      this.dispatchEvent(event);
    });
  }
  handleSizeChange(e10) {
    this.size = e10.target.value;
  }
  handlePillChange(e10) {
    this.pill = e10.target.checked;
  }
  handleOutlineChange(e10) {
    this.outline = e10.target.checked;
  }
  handleWidthChange(e10) {
    this.width = e10.target.value;
  }
  handleVariantChange(e10) {
    this.variant = e10.target.value;
  }
  handleAlignmentChange(alignment) {
    this.alignment = alignment;
  }
  render() {
    return ke`
      <div class="container" style="justify-content: ${this.alignment};">
        <sl-button
          size=${this.size}
          style="
            width: ${this.width}%;
            pointer-events: ${this.isContentEditable ? "none" : "auto"}
          "
          variant=${this.variant}
          ?pill=${this.pill}
          ?outline=${this.outline}
        >
          <p>${this.name}</p>
        </sl-button>

        <div part="options" class="author-only">
          <div class="item">
            <p>Title</p>
            <sl-input
              size="small"
              .value=${this.name}
              @input=${(e10) => this.name = e10.target.value}
            ></sl-input>
          </div>
          <div class="item">
            <p>Size</p>
            <sl-select
              size="small"
              id="sizeSelect"
              @sl-change=${this.handleSizeChange}
            >
              <sl-option value="small">Small</sl-option>
              <sl-option value="medium">Medium</sl-option>
              <sl-option value="large">Large</sl-option>
            </sl-select>
          </div>
          <div class="item">
            <p>Variant</p>
            <sl-select
              size="small"
              id="variantSelect"
              @sl-change=${this.handleVariantChange}
            >
              <sl-option value="default">Default</sl-option>
              <sl-option value="text">Text</sl-option>
              <sl-option value="primary">Primary</sl-option>
              <sl-option value="success">Success</sl-option>
              <sl-option value="neutral">Neutral</sl-option>
              <sl-option value="warning">Warning</sl-option>
              <sl-option value="danger">Danger</sl-option>
            </sl-select>
          </div>
          <div
            style="display: flex; gap: 5px; align-items: center; justify-content: flex-start;"
          >
            <p style="margin-right: auto;">Pill</p>
            <sl-checkbox id="pillCheckbox" @sl-change=${this.handlePillChange}>
            </sl-checkbox>
          </div>
          <div
            style="display: flex; gap: 5px; align-items: center; justify-content: flex-start;"
          >
            <p style="margin-right: auto;">Outline</p>
            <sl-checkbox
              id="outlineCheckbox"
              @sl-change=${this.handleOutlineChange}
            >
            </sl-checkbox>
          </div>
          <div class="item">
            <div
              style="display: flex; gap: 5px; align-items: center; justify-content: flex-start; padding: 0px; margin: 0px;"
            >
              <p style="margin-right: auto;">Width</p>
              <p style="font-weight: 300;">${this.width}%</p>
            </div>
            <sl-range
              size="small"
              id="widthRange"
              min="10"
              max="100"
              tooltip="none"
              value=${this.width}
              @input=${this.handleWidthChange}
              style="--thumb-size: 17px;"
            ></sl-range>
          </div>
          <div
            style="display: flex; gap: 5px; align-items: center; justify-content: flex-start; padding: 0px; margin: 0px; flex-direction: column"
          >
            <p style="margin-right: auto;">Alignment</p>
            <sl-button-group style="width: 100%">
              <sl-button
                class=${this.alignment === "flex-start" ? "active" : ""}
                @click=${() => this.handleAlignmentChange("flex-start")}
              >
                <sl-icon src=${align_left_default}></sl-icon>
              </sl-button>
              <sl-button
                class=${this.alignment === "center" ? "active" : ""}
                @click=${() => this.handleAlignmentChange("center")}
              >
                <sl-icon src=${align_center_default}></sl-icon>
              </sl-button>
              <sl-button
                class=${this.alignment === "flex-end" ? "active" : ""}
                @click=${() => this.handleAlignmentChange("flex-end")}
              >
                <sl-icon src=${align_right_default}></sl-icon>
              </sl-button>
            </sl-button-group>
          </div>
        </div>
      </div>
    `;
  }
  /*
  
    */
  parseConnectionIdentifier(identifier) {
    const parts = identifier.split("-");
    const parsed = {
      outputNodeId: parseInt(parts[0]),
      outputClass: parts[1],
      inputNodeId: parseInt(parts[2]),
      inputClass: parts[3]
    };
    return parsed;
  }
};
_init6 = __decoratorStart(_a6);
_dataTargetId = new WeakMap();
_identifier = new WeakMap();
_getNodeEditor = new WeakMap();
_name = new WeakMap();
_size = new WeakMap();
_pill = new WeakMap();
_outline = new WeakMap();
_width = new WeakMap();
_alignment = new WeakMap();
_variant = new WeakMap();
_tabIndex = new WeakMap();
_button = new WeakMap();
__decorateElement(_init6, 4, "dataTargetId", _dataTargetId_dec, WebWriterGamebookButton, _dataTargetId);
__decorateElement(_init6, 4, "identifier", _identifier_dec, WebWriterGamebookButton, _identifier);
__decorateElement(_init6, 4, "getNodeEditor", _getNodeEditor_dec, WebWriterGamebookButton, _getNodeEditor);
__decorateElement(_init6, 4, "name", _name_dec, WebWriterGamebookButton, _name);
__decorateElement(_init6, 4, "size", _size_dec, WebWriterGamebookButton, _size);
__decorateElement(_init6, 4, "pill", _pill_dec, WebWriterGamebookButton, _pill);
__decorateElement(_init6, 4, "outline", _outline_dec, WebWriterGamebookButton, _outline);
__decorateElement(_init6, 4, "width", _width_dec, WebWriterGamebookButton, _width);
__decorateElement(_init6, 4, "alignment", _alignment_dec, WebWriterGamebookButton, _alignment);
__decorateElement(_init6, 4, "variant", _variant_dec, WebWriterGamebookButton, _variant);
__decorateElement(_init6, 4, "tabIndex", _tabIndex_dec, WebWriterGamebookButton, _tabIndex);
__decorateElement(_init6, 4, "button", _button_dec, WebWriterGamebookButton, _button);
WebWriterGamebookButton = __decorateElement(_init6, 0, "WebWriterGamebookButton", _WebWriterGamebookButton_decorators, WebWriterGamebookButton);
__runInitializers(_init6, 1, WebWriterGamebookButton);

// src/node_modules/@tabler/icons/icons/filled/squares.svg
var squares_default2 = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="currentColor"%0A  class="icon icon-tabler icons-tabler-filled icon-tabler-squares"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M19 7a3 3 0 0 1 3 3v9a3 3 0 0 1 -3 3h-9a3 3 0 0 1 -3 -3v-9a3 3 0 0 1 3 -3z" />%0A  <path d="M14 2a3 3 0 0 1 3 2.999l-7 .001a5 5 0 0 0 -5 5l-.001 7l-.175 -.005a3 3 0 0 1 -2.824 -2.995v-9a3 3 0 0 1 3 -3z" />%0A</svg>';

// src/components/node-detail-view/popup-node-detail-view/popup-node-detail-view.styles.ts
var popup_node_detail_view_styles_default = i`
  .popup-node-detail-view {
    width: auto;
    height: auto;

    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;

    border-radius: 0px 0px 8px 8px;

    background-color: white;
    box-sizing: border-box;
  }

  .preview {
    width: 100%;
    height: auto;

    box-sizing: border-box;

    background-color: white;

    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;

    box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
  }

  .page {
    box-sizing: border-box;
    width: 100%;
    height: auto;

    color: black;

    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
  }

  .overlay {
    top: 0;
    left: 0;
    width: 100%;
    height: auto;
    color: white;
    z-index: 1; /* Ensure the overlay is above other content */
    padding: 10px;

    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;

    background-color: rgba(0, 0, 0, 0.25);
  }

  .dialog {
    height: auto;
    border-radius: 3px;
    background-color: white;
    width: 100%;
    color: black;
  }

  .header {
    box-sizing: border-box;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-items: center;
    padding-left: 4px;
    padding-right: 20px;
    padding-top: 10px;
    padding-bottom: 10px;
  }

  sl-input {
    flex-grow: 1;
  }

  sl-input::part(base) {
    --sl-input-border-width: 0px;
    --sl-input-padding: 0px;
    /* Resembling the style in the picture */
    box-sizing: border-box;

    font-family: -apple-system, BlinkMacSystemFont, "Avenir Next", Avenir,
      "Nimbus Sans L", Roboto, "Noto Sans", "Segoe UI", Arial, Helvetica,
      "Helvetica Neue", sans-serif;
    font-feature-settings: normal;
    font-kerning: auto;
    font-optical-sizing: auto;
    font-size: 20px;
    font-size-adjust: none;
    font-stretch: 100%;
    font-style: normal;
    font-variant-alternates: normal;
    font-variant-caps: normal;
    font-variant-east-asian: normal;
    font-variant-ligatures: normal;
    font-variant-numeric: normal;
    font-variant-position: normal;
    font-variation-settings: normal;
    font-weight: 400;
    line-height: 28px;
    color: black;
  }

  .title-bar {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    justify-items: center;

    box-sizing: border-box;
    width: 100%;
    height: 150px;

    gap: 15px;
    padding: 15px;

    background-color: white;
    border-bottom: 1px solid #d4d4d8;
    /* 
    border-top-left-radius: 8px;
    border-top-right-radius: 8px; */
  }

  .inputOutputControls {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    justify-items: center;
  }

  node-connection-list {
    height: 100%; /* Adjust as needed */
    flex: 1; /* This makes the node-connection-list elements take up remaining space evenly */
  }

  .div-title {
    display: flex;
    flex-direction: column;
  }

  .subtitle {
    font-size: 12px;
    color: gray;
    margin: 0px;
    padding: 0px;
  }

  .div-icon-popup {
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    height: 65px; /* Remove the fixed height */
    aspect-ratio: 1;
    background-color: #9762b4;
  }

  .div-icon-page {
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    height: 65px; /* Remove the fixed height */
    aspect-ratio: 1;
    background-color: #3077ba;
  }

  .div-icon-branch {
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    height: 65px; /* Remove the fixed height */
    aspect-ratio: 1;
    background-color: #05ae9e;
  }

  .div-icon-popup sl-icon,
  .div-icon-page sl-icon,
  .div-icon-branch sl-icon {
    width: 42px;
    height: 42px;
    color: white;
  }
`;

// src/components/node-detail-view/popup-node-detail-view/popup-node-detail-view.ts
var _editorStore_dec4, _nodeEditor_dec, _textAreaHTML_dec, _nodeSelect_dec, _a7, _PopupNodeDetailView_decorators, _init7, _nodeSelect, _textAreaHTML, _nodeEditor, _editorStore4;
_PopupNodeDetailView_decorators = [t4("popup-node-detail-view")];
var PopupNodeDetailView = class extends (_a7 = LitElementWw, _nodeSelect_dec = [e7(".nodeSelect")], _textAreaHTML_dec = [e7("#textAreaHTML")], _nodeEditor_dec = [n6({ type: Object })], _editorStore_dec4 = [c4({ context: editorState, subscribe: true }), n6({ type: Object, attribute: true, reflect: false })], _a7) {
  constructor() {
    super(...arguments);
    __privateAdd(this, _nodeSelect, __runInitializers(_init7, 8, this)), __runInitializers(_init7, 11, this);
    __privateAdd(this, _textAreaHTML, __runInitializers(_init7, 12, this)), __runInitializers(_init7, 15, this);
    __privateAdd(this, _nodeEditor, __runInitializers(_init7, 16, this)), __runInitializers(_init7, 19, this);
    __privateAdd(this, _editorStore4, __runInitializers(_init7, 20, this, new GamebookEditorState("Default"))), __runInitializers(_init7, 23, this);
  }
  //registering custom elements used in the widget
  static get scopedElements() {
    return {
      "sl-button": button_default,
      "sl-textarea": textarea_default,
      "sl-divider": divider_default,
      "sl-icon-button": icon_button_default,
      "sl-dropdown": dropdown_default,
      "sl-menu": menu_default,
      "sl-menu-item": menu_item_default,
      "sl-select": select_default,
      "sl-option": option_default,
      "sl-input": input_default,
      "sl-icon": icon_default,
      "sl-dialog": dialog_default,
      "webwriter-gamebook-button": WebWriterGamebookButton,
      "toggle-text-input": ToggleTextInput,
      "node-connection-list": NodeConnectionList
    };
  }
  firstUpdated(_changedProperties) {
  }
  /*
  
  
    */
  render() {
    return ke` <div class="title-bar">
        <div class="div-icon-popup">
          <sl-icon src=${squares_default2}></sl-icon>
        </div>
        <div class="div-title">
          <toggle-text-input
            .text=${this.editorStore.selectedNode.data.title}
            .saveChanges=${(string) => this.renameNode(string)}
          ></toggle-text-input>
          <p class="subtitle">Popup</p>
        </div>
        <div class="inputOutputControls">
          <node-connection-list
            input
            .nodeEditor=${this.nodeEditor}
            .selectedNode=${this.editorStore.selectedNode}
          ></node-connection-list>
          <sl-divider vertical style="height: 100%;"></sl-divider>
          <node-connection-list
            output
            .nodeEditor=${this.nodeEditor}
            .selectedNode=${this.editorStore.selectedNode}
          ></node-connection-list>
        </div>
      </div>

      <div class="popup-node-detail-view">
        <div class="preview">
          <div class="page">
            <div class="overlay">
              <div class="dialog">
                <div
                  class="header"
                  style=${this.editorStore.selectedContainer?.noHeader ? "display: none" : "display: flex"}
                >
                  <sl-input
                    value=${this.editorStore.selectedContainer?.titleLabel}
                    @sl-input=${(event) => this.handleDialogTitleChange(event)}
                  ></sl-input>
                  <sl-icon-button
                    src=${x_default}
                    style=${this.editorStore.selectedContainer?.preventClosing ? "display: none" : "display: flex"}
                  ></sl-icon-button>
                </div>
                <slot></slot>
              </div>
            </div>
          </div>
        </div>
      </div>`;
  }
  /*
  
  
    */
  handleDialogTitleChange(event) {
    const value = event.target.value;
    this.editorStore.selectedContainer.titleLabel = value;
    this.editorStore.setSelectedContainer(this.editorStore.selectedContainer);
  }
  /*
  
  
    */
  renameNode(text) {
    const event = new CustomEvent("renameSelectedNode", {
      detail: { newTitle: text },
      bubbles: true,
      composed: true
    });
    this.dispatchEvent(event);
  }
};
_init7 = __decoratorStart(_a7);
_nodeSelect = new WeakMap();
_textAreaHTML = new WeakMap();
_nodeEditor = new WeakMap();
_editorStore4 = new WeakMap();
__decorateElement(_init7, 4, "nodeSelect", _nodeSelect_dec, PopupNodeDetailView, _nodeSelect);
__decorateElement(_init7, 4, "textAreaHTML", _textAreaHTML_dec, PopupNodeDetailView, _textAreaHTML);
__decorateElement(_init7, 4, "nodeEditor", _nodeEditor_dec, PopupNodeDetailView, _nodeEditor);
__decorateElement(_init7, 4, "editorStore", _editorStore_dec4, PopupNodeDetailView, _editorStore4);
PopupNodeDetailView = __decorateElement(_init7, 0, "PopupNodeDetailView", _PopupNodeDetailView_decorators, PopupNodeDetailView);
//import CSS
__publicField(PopupNodeDetailView, "styles", [popup_node_detail_view_styles_default]);
__runInitializers(_init7, 1, PopupNodeDetailView);

// src/components/node-detail-view/branch-node-detail-view/branch-node-detail-view.styles.ts
var branch_node_detail_view_styles_default = i`
  :host * {
    box-sizing: border-box;
  }

  .titlebar {
    display: flex;
    justify-content: left;
    align-items: center;
    padding-right: 10px;
    padding-left: 10px;
    padding-top: 10px;
  }

  .title {
    font-size: 16px;
    font-weight: bold;
    color: #505055;
    margin: 0px;
    margin-right: auto;
  }

  .ruleList {
    display: flex;
    flex-direction: column;
    padding: 10px;
  }

  .ruleItem {
    display: flex;
    flex-direction: row;
    align-items: center;
    box-sizing: border-box;
    gap: 10px;
    width: 100%;
  }

  .ruleItem > *:not(.draggable, .minus, #index, #percent) {
    flex: 1 !important; /* Make each child (except .draggable) take up equal space */
    min-width: 0; /* Prevent overflow issues */
    flex-grow: 1 !important;
  }

  sl-select::part(listbox) {
    width: 250px;
    height: 100px;
  }

  .no-node {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 80px;
    background-color: #fbfbfb;
    color: darkgray;
  }

  .draggable {
    cursor: row-resize;
  }

  .rule-divider {
    --color: #0084c7;
    --width: 2px;
    margin: 0px;
    transition: opacity 0s ease-in-out;
  }

  .shadow-effect {
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.2);
  }

  .dragging {
    opacity: 0.5;
    border: 2px dashed #ccc;
  }

  .rule-divider {
    transition: visibility 0.2s ease-in-out;
  }

  .title-bar {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    justify-items: center;

    box-sizing: border-box;
    width: 100%;
    height: 150px;

    gap: 15px;
    padding: 15px;

    background-color: white;
    border-bottom: 1px solid #d4d4d8;
  }

  .div-title {
    display: flex;
    flex-direction: column;
    flex: 1; /* This makes the node-connection-list elements take up remaining space evenly */
    margin-right: auto;
  }

  .subtitle {
    font-size: 12px;
    color: gray;
    margin: 0px;
    padding: 0px;
  }

  .inputOutputControls {
    max-width: 190px;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    justify-items: center;
  }

  node-connection-list {
    height: 100%; /* Adjust as needed */
    width: 100%;
  }

  .div-icon-branch {
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    height: 65px; /* Remove the fixed height */
    aspect-ratio: 1;
    background-color: #05ae9e;
  }

  .div-icon-branch sl-icon {
    width: 42px;
    height: 42px;
    color: white;
  }
`;

// src/node_modules/@tabler/icons/icons/outline/circle-dashed-x.svg
var circle_dashed_x_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-circle-dashed-x"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M8.56 3.69a9 9 0 0 0 -2.92 1.95" />%0A  <path d="M3.69 8.56a9 9 0 0 0 -.69 3.44" />%0A  <path d="M3.69 15.44a9 9 0 0 0 1.95 2.92" />%0A  <path d="M8.56 20.31a9 9 0 0 0 3.44 .69" />%0A  <path d="M15.44 20.31a9 9 0 0 0 2.92 -1.95" />%0A  <path d="M20.31 15.44a9 9 0 0 0 .69 -3.44" />%0A  <path d="M20.31 8.56a9 9 0 0 0 -1.95 -2.92" />%0A  <path d="M15.44 3.69a9 9 0 0 0 -3.44 -.69" />%0A  <path d="M14 14l-4 -4" />%0A  <path d="M10 14l4 -4" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/circle-dashed-check.svg
var circle_dashed_check_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-circle-dashed-check"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M8.56 3.69a9 9 0 0 0 -2.92 1.95" />%0A  <path d="M3.69 8.56a9 9 0 0 0 -.69 3.44" />%0A  <path d="M3.69 15.44a9 9 0 0 0 1.95 2.92" />%0A  <path d="M8.56 20.31a9 9 0 0 0 3.44 .69" />%0A  <path d="M15.44 20.31a9 9 0 0 0 2.92 -1.95" />%0A  <path d="M20.31 15.44a9 9 0 0 0 .69 -3.44" />%0A  <path d="M20.31 8.56a9 9 0 0 0 -1.95 -2.92" />%0A  <path d="M15.44 3.69a9 9 0 0 0 -3.44 -.69" />%0A  <path d="M9 12l2 2l4 -4" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/grip-horizontal.svg
var grip_horizontal_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-grip-horizontal"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M5 9m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" />%0A  <path d="M5 15m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" />%0A  <path d="M12 9m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" />%0A  <path d="M12 15m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" />%0A  <path d="M19 9m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" />%0A  <path d="M19 15m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/percentage.svg
var percentage_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-percentage"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M17 17m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" />%0A  <path d="M7 7m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" />%0A  <path d="M6 18l12 -12" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/help-octagon.svg
var help_octagon_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-help-octagon"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M12.802 2.165l5.575 2.389c.48 .206 .863 .589 1.07 1.07l2.388 5.574c.22 .512 .22 1.092 0 1.604l-2.389 5.575c-.206 .48 -.589 .863 -1.07 1.07l-5.574 2.388c-.512 .22 -1.092 .22 -1.604 0l-5.575 -2.389a2.036 2.036 0 0 1 -1.07 -1.07l-2.388 -5.574a2.036 2.036 0 0 1 0 -1.604l2.389 -5.575c.206 -.48 .589 -.863 1.07 -1.07l5.574 -2.388a2.036 2.036 0 0 1 1.604 0z" />%0A  <path d="M12 16v.01" />%0A  <path d="M12 13a2 2 0 0 0 .914 -3.782a1.98 1.98 0 0 0 -2.414 .483" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/number-123.svg
var number_123_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-number-123"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M3 10l2 -2v8" />%0A  <path d="M9 8h3a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 0 -1 1v2a1 1 0 0 0 1 1h3" />%0A  <path d="M17 8h2.5a1.5 1.5 0 0 1 1.5 1.5v1a1.5 1.5 0 0 1 -1.5 1.5h-1.5h1.5a1.5 1.5 0 0 1 1.5 1.5v1a1.5 1.5 0 0 1 -1.5 1.5h-2.5" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/checkbox.svg
var checkbox_default2 = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-checkbox"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M9 11l3 3l8 -8" />%0A  <path d="M20 12v6a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h9" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/blockquote.svg
var blockquote_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-blockquote"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M6 15h15" />%0A  <path d="M21 19h-15" />%0A  <path d="M15 11h6" />%0A  <path d="M21 7h-6" />%0A  <path d="M9 9h1a1 1 0 1 1 -1 1v-2.5a2 2 0 0 1 2 -2" />%0A  <path d="M3 9h1a1 1 0 1 1 -1 1v-2.5a2 2 0 0 1 2 -2" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/highlight.svg
var highlight_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-highlight"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M3 19h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />%0A  <path d="M12.5 5.5l4 4" />%0A  <path d="M4.5 13.5l4 4" />%0A  <path d="M21 15v4h-8l4 -4z" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/microphone.svg
var microphone_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-microphone"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M9 2m0 3a3 3 0 0 1 3 -3h0a3 3 0 0 1 3 3v5a3 3 0 0 1 -3 3h0a3 3 0 0 1 -3 -3z" />%0A  <path d="M5 10a7 7 0 0 0 14 0" />%0A  <path d="M8 21l8 0" />%0A  <path d="M12 17l0 4" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/packages.svg
var packages_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-packages"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M7 16.5l-5 -3l5 -3l5 3v5.5l-5 3z" />%0A  <path d="M2 13.5v5.5l5 3" />%0A  <path d="M7 16.545l5 -3.03" />%0A  <path d="M17 16.5l-5 -3l5 -3l5 3v5.5l-5 3z" />%0A  <path d="M12 19l5 3" />%0A  <path d="M17 16.5l5 -3" />%0A  <path d="M12 13.5v-5.5l-5 -3l5 -3l5 3v5.5" />%0A  <path d="M7 5.03v5.455" />%0A  <path d="M12 8l5 -3" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/book.svg
var book_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-book"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M3 19a9 9 0 0 1 9 0a9 9 0 0 1 9 0" />%0A  <path d="M3 6a9 9 0 0 1 9 0a9 9 0 0 1 9 0" />%0A  <path d="M3 6l0 13" />%0A  <path d="M12 6l0 13" />%0A  <path d="M21 6l0 13" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/trash.svg
var trash_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-trash"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M4 7l16 0" />%0A  <path d="M10 11l0 6" />%0A  <path d="M14 11l0 6" />%0A  <path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12" />%0A  <path d="M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/filled/circle-arrow-right.svg
var circle_arrow_right_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="currentColor"%0A  class="icon icon-tabler icons-tabler-filled icon-tabler-circle-arrow-right"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M12 2l.324 .005a10 10 0 1 1 -.648 0l.324 -.005zm.613 5.21a1 1 0 0 0 -1.32 1.497l2.291 2.293h-5.584l-.117 .007a1 1 0 0 0 .117 1.993h5.584l-2.291 2.293l-.083 .094a1 1 0 0 0 1.497 1.32l4 -4l.073 -.082l.064 -.089l.062 -.113l.044 -.11l.03 -.112l.017 -.126l.003 -.075l-.007 -.118l-.029 -.148l-.035 -.105l-.054 -.113l-.071 -.111a1.008 1.008 0 0 0 -.097 -.112l-4 -4z" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/filled/info-square-rounded.svg
var info_square_rounded_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="currentColor"%0A  class="icon icon-tabler icons-tabler-filled icon-tabler-info-square-rounded"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M12 2l.642 .005l.616 .017l.299 .013l.579 .034l.553 .046c4.687 .455 6.65 2.333 7.166 6.906l.03 .29l.046 .553l.041 .727l.006 .15l.017 .617l.005 .642l-.005 .642l-.017 .616l-.013 .299l-.034 .579l-.046 .553c-.455 4.687 -2.333 6.65 -6.906 7.166l-.29 .03l-.553 .046l-.727 .041l-.15 .006l-.617 .017l-.642 .005l-.642 -.005l-.616 -.017l-.299 -.013l-.579 -.034l-.553 -.046c-4.687 -.455 -6.65 -2.333 -7.166 -6.906l-.03 -.29l-.046 -.553l-.041 -.727l-.006 -.15l-.017 -.617l-.004 -.318v-.648l.004 -.318l.017 -.616l.013 -.299l.034 -.579l.046 -.553c.455 -4.687 2.333 -6.65 6.906 -7.166l.29 -.03l.553 -.046l.727 -.041l.15 -.006l.617 -.017c.21 -.003 .424 -.005 .642 -.005zm0 9h-1l-.117 .007a1 1 0 0 0 0 1.986l.117 .007v3l.007 .117a1 1 0 0 0 .876 .876l.117 .007h1l.117 -.007a1 1 0 0 0 .876 -.876l.007 -.117l-.007 -.117a1 1 0 0 0 -.764 -.857l-.112 -.02l-.117 -.006v-3l-.007 -.117a1 1 0 0 0 -.876 -.876l-.117 -.007zm.01 -3l-.127 .007a1 1 0 0 0 0 1.986l.117 .007l.127 -.007a1 1 0 0 0 0 -1.986l-.117 -.007z" />%0A</svg>';

// src/components/options-panel/webwriter-gamebook-options.ts
var _editorStore_dec5, _searchInput_dec, _a8, _WebWriterGamebookOptions_decorators, _init8, _searchInput, _editorStore5;
_WebWriterGamebookOptions_decorators = [t4("webwriter-gamebook-options")];
var WebWriterGamebookOptions = class extends (_a8 = LitElementWw, _searchInput_dec = [e7("#searchInput")], _editorStore_dec5 = [c4({ context: editorState, subscribe: true }), n6({ type: Object, attribute: true, reflect: false })], _a8) {
  constructor() {
    super(...arguments);
    __privateAdd(this, _searchInput, __runInitializers(_init8, 8, this)), __runInitializers(_init8, 11, this);
    __privateAdd(this, _editorStore5, __runInitializers(_init8, 12, this, new GamebookEditorState("Default"))), __runInitializers(_init8, 15, this);
  }
  static get styles() {
    return i`
      :host {
        padding-left: 10px;
      }
      .author-only {
        display: flex;
        flex-direction: column;
        box-sizing: border-box;
        gap: 10px;
        width: 180px;
      }

      .author-only .header p {
        margin: 0px;
        font-weight: 500;
        font-size: 15px;
        box-sizing: border-box;
        color: #52525b;
      }

      .author-only .header {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-items: center;
        border-bottom: 2px solid #52525b;
        gap: 7px;
        padding-bottom: 10px;
      }

      .author-only .searchBar {
        display: flex;
        flex-direction: row;
        align-items: flex-start;
        justify-items: center;
        width: 100%;
        height: 65px;
      }

      .author-only .searchBar * {
        width: 100%;
      }

      .author-only sl-icon {
        color: #52525b;
      }

      .author-only .horizontalStack {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 5px;
        width: 100%;
      }

      sl-button.square {
        width: 42px; /* Set this value to whatever size you want */
        height: 42px; /* Same value as width to ensure it's a square */
      }

      p {
        margin: 0px;
        font-weight: 400;
        font-size: 15px;
        box-sizing: border-box;
        color: #52525b;
      }
    `;
  }
  //registering custom elements used in the widget
  static get scopedElements() {
    return {
      "sl-input": input_default,
      "sl-icon": icon_default,
      "sl-button": button_default,
      "sl-button-group": button_group_default,
      "sl-select": select_default,
      "sl-divider": divider_default,
      "sl-icon-button": icon_button_default,
      "sl-switch": switch_default,
      "sl-dropdown": dropdown_default,
      "sl-menu": menu_default,
      "sl-menu-item": menu_item_default,
      "sl-menu-label": menu_label_default
    };
  }
  render() {
    const options = (data) => Object.keys(data).filter(
      (key) => this.editorStore.searchResults !== void 0 ? this.editorStore.searchResults.includes(Number(key)) : true
      // No filtering when searchResults is empty
    ).map(
      (key) => ke`<sl-menu-item
              value="${data[key].id}"
              @click=${() => this.moveTo(data[key])}
              ><p>${data[key].data.title}</p>
              ${data[key].class === "page" || data[key].class === "origin" ? ke` <sl-icon slot="prefix" src=${file_default2}></sl-icon> ` : data[key].class === "popup" ? ke` <sl-icon slot="prefix" src=${squares_default}></sl-icon>` : data[key].class === "branch" ? ke` <sl-icon slot="prefix" src=${arrows_split_2_default}></sl-icon>` : null}
            </sl-menu-item>
            <sl-divider></sl-divider> `
    );
    return ke`
      <div class="author-only">
        <div class="header">
          <sl-icon src=${book_default}></sl-icon>
          <p>Gamebook</p>
        </div>

        <sl-dropdown>
          <sl-input
            style="max-width: 180px"
            slot="trigger"
            id="searchInput"
            placeholder="Search..."
            clearable
            @sl-input=${this._handleNodeSearch}
            @keydown=${this._handleInputKeydown}
            .value=${this.editorStore.searchTerm}
          >
            <sl-icon src=${search_default} slot="prefix"></sl-icon>
          </sl-input>
          <sl-menu hoist style="width: 180px;">
            ${this.editorStore.searchResults ? ke`
                  <sl-menu-label
                    >${this.editorStore.searchResults.length}
                    nodes</sl-menu-label
                  >
                  <sl-divider></sl-divider>
                ` : null}
            ${options(this.editorStore.editorContent.drawflow.Home.data)}
          </sl-menu>
        </sl-dropdown>

        <sl-button-group label="Alignment">
          <sl-button
            id="copyNodeBtn"
            class="flex-item"
            @click=${() => this.editorStore.setCopiedNode(this.editorStore.selectedNode)}
            ?disabled=${this.editorStore.selectedNode.id === -1}
          >
            Copy
          </sl-button>

          <sl-button
            class="flex-item"
            @click=${() => this.dispatchEvent(
      new CustomEvent("pasteNode", {
        bubbles: true,
        composed: true
      })
    )}
            ?disabled=${this.editorStore.copiedNode.id === -1}
          >
            Paste
          </sl-button>

          <sl-button
            class="square"
            variant="default"
            id="deleteNodeBtn"
            @click=${() => this.deleteSelectedNode()}
            ?disabled=${this.editorStore.selectedNode.id === -1 || this.editorStore.selectedNode.class == "origin" ? true : false}
          >
            <sl-icon src=${trash_default}></sl-icon>
          </sl-button>
        </sl-button-group>

        ${this.editorStore.selectedNode.id != -1 ? ke`
              <div class="header">
                ${this.editorStore.selectedNode.class == "page" ? ke`
                      <sl-icon src=${file_default2}></sl-icon>
                      <p>Page</p>
                    ` : this.editorStore.selectedNode.class == "origin" ? ke`
                      <sl-icon src=${file_default2}></sl-icon>
                      <p>Start Page</p>
                    ` : this.editorStore.selectedNode.class == "popup" ? ke`
                      <sl-icon src=${squares_default}></sl-icon>
                      <p>Popup</p>
                    ` : this.editorStore.selectedNode.class == "branch" ? ke`
                      <sl-icon src=${arrows_split_2_default}></sl-icon>
                      <p>Branch</p>
                    ` : null}
              </div>

              ${this.editorStore.selectedNode.class == "page" || this.editorStore.selectedNode.class == "origin" ? ke`
                    <sl-button
                      id="makeNodeOriginBtn"
                      @click=${() => this.makeNodeOrigin()}
                      ?disabled=${this.editorStore.selectedNode.class == "origin" ? true : false}
                    >
                      <sl-icon src=${circle_arrow_right_default} slot="prefix"></sl-icon>
                      Set as Start Page
                    </sl-button>
                  ` : null}
              ${this.editorStore.selectedNode.class == "branch" ? ke`
                    <p>
                      <sl-icon
                        src="${info_square_rounded_default}"
                        style="vertical-align: middle; margin: 1px;"
                      ></sl-icon>
                      Create rules to guide how your gamebook progresses. The
                      first rule that applies will be used.
                    </p>
                    <p>
                      <sl-icon
                        src="${packages_default}"
                        style="vertical-align: middle; margin: 1px;"
                      ></sl-icon>
                      Requires
                      <a
                        href="https://webwriter.app/widgets/"
                        target="https://webwriter.app/widgets/"
                      >
                        WebWriter Quiz Widget </a
                      >.
                    </p>
                  ` : null}
              ${this.editorStore.selectedNode.class == "popup" ? ke`
                    <sl-switch
                      ?checked=${this.editorStore.selectedContainer.preventClosing}
                      @sl-input=${(event) => this.handleSwitchPreventClosing(event)}
                    >
                      Prevent Closing
                    </sl-switch>
                    <sl-switch
                      ?checked=${this.editorStore.selectedContainer.noHeader ? false : true}
                      @sl-input=${(event) => this.handleSwitchNoHeader(event)}
                    >
                      Header
                    </sl-switch>
                  ` : null}
            ` : null}
      </div>
    `;
  }
  /*
  
    */
  _handleNodeSearch(event) {
    const inputText = event.target.value;
    this.editorStore.setSearchTerm(inputText);
    this.dispatchEvent(
      new CustomEvent("nodeSearch", {
        bubbles: true,
        composed: true
      })
    );
    this.requestUpdate();
  }
  /*
  
    */
  makeNodeOrigin() {
    this.dispatchEvent(
      new CustomEvent("makeSelectedNodeOrigin", {
        detail: { newId: this.editorStore.selectedNode.id },
        bubbles: true,
        composed: true
      })
    );
  }
  /*
  
    */
  handleSwitchPreventClosing(event) {
    const value = event.target.checked;
    this.editorStore.selectedContainer.preventClosing = value;
    this.editorStore.setSelectedContainer(this.editorStore.selectedContainer);
    this.requestUpdate();
  }
  /*
  
  
    */
  handleSwitchNoHeader(event) {
    const value = event.target.checked;
    this.editorStore.selectedContainer.noHeader = !value;
    this.editorStore.setSelectedContainer(this.editorStore.selectedContainer);
    this.requestUpdate();
  }
  /*
  
  
    */
  deleteSelectedNode() {
    this.dispatchEvent(
      new CustomEvent("deleteSelectedNode", {
        bubbles: true,
        composed: true
      })
    );
  }
  /*
  
  
    */
  moveTo(node) {
    this.dispatchEvent(
      new CustomEvent("moveTo", {
        detail: { node },
        bubbles: true,
        composed: true
      })
    );
  }
  /*
  
  
    */
  _handleInputKeydown(event) {
    if (event.key === " ") {
      event.stopPropagation();
    }
  }
};
_init8 = __decoratorStart(_a8);
_searchInput = new WeakMap();
_editorStore5 = new WeakMap();
__decorateElement(_init8, 4, "searchInput", _searchInput_dec, WebWriterGamebookOptions, _searchInput);
__decorateElement(_init8, 4, "editorStore", _editorStore_dec5, WebWriterGamebookOptions, _editorStore5);
WebWriterGamebookOptions = __decorateElement(_init8, 0, "WebWriterGamebookOptions", _WebWriterGamebookOptions_decorators, WebWriterGamebookOptions);
__runInitializers(_init8, 1, WebWriterGamebookOptions);

// src/components/gamebook/gamebook-components/gamebook-containers/gamebook-page/webwriter-gamebook-page.ts
var _slotContent_dec, _buttons_dec, _slotElement_dec, _branchesOff_dec, _originPage_dec, _pageTitle_dec, _drawflowNodeId_dec, _tabIndex_dec2, _a9, _WebWriterGamebookPage_decorators, _init9, _tabIndex2, _drawflowNodeId, _pageTitle, _originPage, _branchesOff, _slotElement, _buttons, _slotContent;
_WebWriterGamebookPage_decorators = [t4("webwriter-gamebook-page")];
var WebWriterGamebookPage = class extends (_a9 = LitElementWw, _tabIndex_dec2 = [n6({ type: Number, attribute: true, reflect: true })], _drawflowNodeId_dec = [n6({ type: Number, attribute: true, reflect: true })], _pageTitle_dec = [n6({ type: String, attribute: true, reflect: true })], _originPage_dec = [n6({ type: Number, attribute: true, reflect: true })], _branchesOff_dec = [n6({ type: Number, attribute: true, reflect: true })], _slotElement_dec = [e7("slot")], _buttons_dec = [o5({
  flatten: true,
  selector: "webwriter-gamebook-button, webwriter-gamebook-branch-button"
})], _slotContent_dec = [o5({
  flatten: true
})], _a9) {
  /* 
  
  
  */
  constructor() {
    super();
    __privateAdd(this, _tabIndex2, __runInitializers(_init9, 8, this, -1)), __runInitializers(_init9, 11, this);
    __privateAdd(this, _drawflowNodeId, __runInitializers(_init9, 12, this)), __runInitializers(_init9, 15, this);
    __privateAdd(this, _pageTitle, __runInitializers(_init9, 16, this)), __runInitializers(_init9, 19, this);
    __privateAdd(this, _originPage, __runInitializers(_init9, 20, this)), __runInitializers(_init9, 23, this);
    __privateAdd(this, _branchesOff, __runInitializers(_init9, 24, this, -1)), __runInitializers(_init9, 27, this);
    __privateAdd(this, _slotElement, __runInitializers(_init9, 28, this)), __runInitializers(_init9, 31, this);
    __privateAdd(this, _buttons, __runInitializers(_init9, 32, this)), __runInitializers(_init9, 35, this);
    __privateAdd(this, _slotContent, __runInitializers(_init9, 36, this)), __runInitializers(_init9, 39, this);
    // Create an observer instance linked to the callback function
    __publicField(this, "mutationObserver");
    /*
    
      */
    __publicField(this, "mutationCallback", (mutationList) => {
      mutationList.forEach(({ type, removedNodes }) => {
        if (type === "childList") {
          removedNodes.forEach((node) => {
            const element = node;
            const nodeName = element.nodeName.toLowerCase();
            const isSelectedNode = element.classList?.contains(
              "ProseMirror-selectednode"
            );
            const dispatchEventIfNeeded = (eventName, detail) => {
              const event = new CustomEvent(eventName, {
                detail,
                bubbles: true,
                composed: true
              });
              this.dispatchEvent(event);
            };
            if (element.classList?.contains("ww-widget")) {
              if (nodeName === "webwriter-gamebook-button" || nodeName === "webwriter-gamebook-branch-button") {
                const connButton = node;
                if (connButton.identifier !== "x") {
                  dispatchEventIfNeeded("buttonDeleted", {
                    identifier: connButton.identifier
                  });
                }
              } else if (nodeName === "webwriter-quiz" || nodeName === "webwriter-task") {
                if (this.branchesOff !== -1) {
                  dispatchEventIfNeeded("quizElementDeleted", {
                    containerId: this.branchesOff,
                    id: element.id,
                    isQuiz: nodeName === "webwriter-quiz"
                  });
                }
              }
            }
          });
        }
      });
    });
    this.mutationObserver = new MutationObserver(this.mutationCallback);
  }
  //import CSS
  static get styles() {
    return i`
      .page {
        display: flex;
        flex-direction: column;
        gap: 10px; /* Adjust the value to your desired spacing */
        padding: 20px;
        box-sizing: border-box;
        width: 100%;
        min-height: 400px;
        height: 100%;
      }

      :host(:not([contenteditable="true"]):not([contenteditable=""]))
        .author-only {
        display: none;
      }
    `;
  }
  //registering custom elements used in the widget
  static get scopedElements() {
    return {
      "sl-button": button_default,
      "webwriter-gamebook-button": WebWriterGamebookButton,
      "webwriter-gamebook-options": WebWriterGamebookOptions
    };
  }
  /* 
  
  */
  firstUpdated(_changedProperties) {
    const config = {
      attributes: true,
      childList: true,
      subtree: true,
      characterData: true
    };
    this.mutationObserver.observe(this, config);
    const slot = this.shadowRoot.querySelector("slot");
    const assignedElements = slot.assignedElements();
    if (assignedElements.length == 0) {
      const par = document.createElement("p");
      this.appendChild(par);
    }
  }
  /*
  
  
    */
  render() {
    return ke`<slot class="page"></slot>
      <webwriter-gamebook-options
        class="author-only"
        part="options"
      ></webwriter-gamebook-options> `;
  }
  /*
  
  
    */
  hide() {
    this.style.display = "none";
  }
  /*
  
  
    */
  show() {
    this.style.display = "block";
  }
};
_init9 = __decoratorStart(_a9);
_tabIndex2 = new WeakMap();
_drawflowNodeId = new WeakMap();
_pageTitle = new WeakMap();
_originPage = new WeakMap();
_branchesOff = new WeakMap();
_slotElement = new WeakMap();
_buttons = new WeakMap();
_slotContent = new WeakMap();
__decorateElement(_init9, 4, "tabIndex", _tabIndex_dec2, WebWriterGamebookPage, _tabIndex2);
__decorateElement(_init9, 4, "drawflowNodeId", _drawflowNodeId_dec, WebWriterGamebookPage, _drawflowNodeId);
__decorateElement(_init9, 4, "pageTitle", _pageTitle_dec, WebWriterGamebookPage, _pageTitle);
__decorateElement(_init9, 4, "originPage", _originPage_dec, WebWriterGamebookPage, _originPage);
__decorateElement(_init9, 4, "branchesOff", _branchesOff_dec, WebWriterGamebookPage, _branchesOff);
__decorateElement(_init9, 4, "slotElement", _slotElement_dec, WebWriterGamebookPage, _slotElement);
__decorateElement(_init9, 4, "buttons", _buttons_dec, WebWriterGamebookPage, _buttons);
__decorateElement(_init9, 4, "slotContent", _slotContent_dec, WebWriterGamebookPage, _slotContent);
WebWriterGamebookPage = __decorateElement(_init9, 0, "WebWriterGamebookPage", _WebWriterGamebookPage_decorators, WebWriterGamebookPage);
__runInitializers(_init9, 1, WebWriterGamebookPage);

// src/components/gamebook/gamebook-components/gamebook-containers/gamebook-popup/webwriter-gamebook-popup.ts
var _branchesOff_dec2, _preventClosing_dec, _noHeader_dec, _titleLabel_dec, _dialog_dec, _slotContent_dec2, _pageTitle_dec2, _buttons_dec2, _tabIndex_dec3, _drawflowNodeId_dec2, _a10, _WebWriterGamebookPopup_decorators, _init10, _drawflowNodeId2, _tabIndex3, _buttons2, _pageTitle2, _slotContent2, _dialog, _titleLabel, _noHeader, _preventClosing, _branchesOff2;
_WebWriterGamebookPopup_decorators = [t4("webwriter-gamebook-popup")];
var WebWriterGamebookPopup = class extends (_a10 = LitElementWw, _drawflowNodeId_dec2 = [n6({ type: Number, attribute: true, reflect: true })], _tabIndex_dec3 = [n6({ type: Number, attribute: true, reflect: true })], _buttons_dec2 = [o5({
  flatten: true,
  selector: "webwriter-gamebook-button, webwriter-gamebook-branch-button"
})], _pageTitle_dec2 = [n6({ type: String, attribute: true, reflect: true })], _slotContent_dec2 = [o5({
  flatten: true
})], _dialog_dec = [e7("#dialog")], _titleLabel_dec = [n6({ type: String, attribute: true, reflect: true })], _noHeader_dec = [n6({ type: Boolean, attribute: true, reflect: true })], _preventClosing_dec = [n6({ type: Boolean, attribute: true, reflect: true })], _branchesOff_dec2 = [n6({ type: Number, attribute: true, reflect: true })], _a10) {
  /* 
  
  
  */
  constructor() {
    super();
    __privateAdd(this, _drawflowNodeId2, __runInitializers(_init10, 8, this)), __runInitializers(_init10, 11, this);
    __privateAdd(this, _tabIndex3, __runInitializers(_init10, 12, this, -1)), __runInitializers(_init10, 15, this);
    __privateAdd(this, _buttons2, __runInitializers(_init10, 16, this)), __runInitializers(_init10, 19, this);
    __privateAdd(this, _pageTitle2, __runInitializers(_init10, 20, this)), __runInitializers(_init10, 23, this);
    __privateAdd(this, _slotContent2, __runInitializers(_init10, 24, this)), __runInitializers(_init10, 27, this);
    __privateAdd(this, _dialog, __runInitializers(_init10, 28, this)), __runInitializers(_init10, 31, this);
    __privateAdd(this, _titleLabel, __runInitializers(_init10, 32, this, "Dialog")), __runInitializers(_init10, 35, this);
    __privateAdd(this, _noHeader, __runInitializers(_init10, 36, this, false)), __runInitializers(_init10, 39, this);
    __privateAdd(this, _preventClosing, __runInitializers(_init10, 40, this)), __runInitializers(_init10, 43, this);
    __privateAdd(this, _branchesOff2, __runInitializers(_init10, 44, this, -1)), __runInitializers(_init10, 47, this);
    // Create an observer instance linked to the callback function
    __publicField(this, "mutationObserver");
    /*
    
    
      */
    __publicField(this, "mutationCallback", (mutationList) => {
      mutationList.forEach(({ type, removedNodes }) => {
        if (type === "childList") {
          removedNodes.forEach((node) => {
            const element = node;
            const nodeName = element.nodeName.toLowerCase();
            const isSelectedNode = element.classList?.contains(
              "ProseMirror-selectednode"
            );
            const dispatchEventIfNeeded = (eventName, detail) => {
              const event = new CustomEvent(eventName, {
                detail,
                bubbles: true,
                composed: true
              });
              this.dispatchEvent(event);
            };
            if (element.classList?.contains("ww-widget")) {
              if (nodeName === "webwriter-gamebook-button" || nodeName === "webwriter-gamebook-branch-button") {
                const connButton = node;
                if (connButton.identifier !== "x") {
                  dispatchEventIfNeeded("buttonDeleted", {
                    identifier: connButton.identifier
                  });
                }
              } else if (nodeName === "webwriter-quiz" || nodeName === "webwriter-task") {
                if (this.branchesOff !== -1) {
                  dispatchEventIfNeeded("quizElementDeleted", {
                    containerId: this.branchesOff,
                    id: element.id,
                    isQuiz: nodeName === "webwriter-quiz"
                  });
                }
              }
            }
          });
        }
      });
    });
    this.mutationObserver = new MutationObserver(this.mutationCallback);
  }
  //import CSS
  static get styles() {
    return i`
      :host(:not([contenteditable="true"]):not([contenteditable=""])) .page {
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        gap: 10px; /* Adjust the value to your desired spacing */
        box-sizing: border-box;
        width: 100%;
        height: auto;
        padding: 0px;
      }

      :host([contenteditable="true"]) .page,
      :host([contenteditable=""]) .page {
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        gap: 10px; /* Adjust the value to your desired spacing */
        box-sizing: border-box;
        width: 100%;
        height: auto;
        padding: 20px;
      }

      :host(:not([contenteditable="true"]):not([contenteditable=""]))
        .author-only {
        display: none;
      }

      /* Base style for the close button visibility */
      sl-dialog::part(close-button) {
        display: var(--close-button-display, flex);
      }

      /* Hide the close button when the class is applied */
      .hide-close-button {
        --close-button-display: none;
      }

      sl-dialog::part(base) {
        position: absolute; /* Make the overlay absolute */
      }

      sl-dialog::part(overlay) {
        position: absolute; /* Make the overlay absolute */
        background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent background */
      }
    `;
  }
  //registering custom elements used in the widget
  static get scopedElements() {
    return {
      "sl-dialog": dialog_default,
      "webwriter-gamebook-button": WebWriterGamebookButton,
      "webwriter-gamebook-options": WebWriterGamebookOptions
    };
  }
  /* 
  
  
  */
  firstUpdated(_changedProperties) {
    const config = { attributes: true, childList: true, subtree: true };
    this.mutationObserver.observe(this, config);
    const slot = this.shadowRoot.querySelector("slot");
    const assignedElements = slot.assignedElements();
    if (assignedElements.length == 0) {
      const par = document.createElement("p");
      this.appendChild(par);
    }
    if (this.preventClosing && this.dialog) {
      this.dialog.addEventListener("sl-request-close", (event) => {
        if (event.detail.source === "overlay" || event.detail.source === "close-button" || event.detail.source === "keyboard") {
          event.preventDefault();
        }
      });
      this.dialog.classList.add("hide-close-button");
    }
  }
  /*
  
  
    */
  render() {
    return ke` ${this.isContentEditable ? ke`
          <slot class="page"></slot>
          <webwriter-gamebook-options
            class="author-only"
            part="options"
          ></webwriter-gamebook-options>
        ` : ke`
          <sl-dialog
            id="dialog"
            style="--width: 100%;"
            label=${this.titleLabel}
            ?no-header=${this.noHeader ? true : false}
            ><slot class="page"></slot
          ></sl-dialog>
        `}`;
  }
  /*
  
  
    */
  hide() {
    this.style.display = "none";
  }
  /*
  
  
    */
  show() {
    this.style.display = "block";
  }
  /*
  
  
    */
  hideDialog() {
    this.dialog.hide();
    this.style.display = "none";
  }
  /*
  
  
  */
  showDialog() {
    this.style.display = "block";
    this.dialog.show();
  }
};
_init10 = __decoratorStart(_a10);
_drawflowNodeId2 = new WeakMap();
_tabIndex3 = new WeakMap();
_buttons2 = new WeakMap();
_pageTitle2 = new WeakMap();
_slotContent2 = new WeakMap();
_dialog = new WeakMap();
_titleLabel = new WeakMap();
_noHeader = new WeakMap();
_preventClosing = new WeakMap();
_branchesOff2 = new WeakMap();
__decorateElement(_init10, 4, "drawflowNodeId", _drawflowNodeId_dec2, WebWriterGamebookPopup, _drawflowNodeId2);
__decorateElement(_init10, 4, "tabIndex", _tabIndex_dec3, WebWriterGamebookPopup, _tabIndex3);
__decorateElement(_init10, 4, "buttons", _buttons_dec2, WebWriterGamebookPopup, _buttons2);
__decorateElement(_init10, 4, "pageTitle", _pageTitle_dec2, WebWriterGamebookPopup, _pageTitle2);
__decorateElement(_init10, 4, "slotContent", _slotContent_dec2, WebWriterGamebookPopup, _slotContent2);
__decorateElement(_init10, 4, "dialog", _dialog_dec, WebWriterGamebookPopup, _dialog);
__decorateElement(_init10, 4, "titleLabel", _titleLabel_dec, WebWriterGamebookPopup, _titleLabel);
__decorateElement(_init10, 4, "noHeader", _noHeader_dec, WebWriterGamebookPopup, _noHeader);
__decorateElement(_init10, 4, "preventClosing", _preventClosing_dec, WebWriterGamebookPopup, _preventClosing);
__decorateElement(_init10, 4, "branchesOff", _branchesOff_dec2, WebWriterGamebookPopup, _branchesOff2);
WebWriterGamebookPopup = __decorateElement(_init10, 0, "WebWriterGamebookPopup", _WebWriterGamebookPopup_decorators, WebWriterGamebookPopup);
__runInitializers(_init10, 1, WebWriterGamebookPopup);

// src/components/component-select/webwriter-quiz-select/webwriter-quiz-select.ts
var _selectElement_dec2, _searchElement_dec2, _searchTerm_dec2, _value_dec, _options_dec, _container_dec, _a11, _WebWriterQuizSelect_decorators, _init11, _container, _options, _value, _searchTerm2, _searchElement2, _selectElement2;
_WebWriterQuizSelect_decorators = [t4("webwriter-quiz-select")];
var WebWriterQuizSelect = class extends (_a11 = h3, _container_dec = [n6({ type: Object })], _options_dec = [n6({ type: Object })], _value_dec = [n6({ type: String })], _searchTerm_dec2 = [r5()], _searchElement_dec2 = [e7("sl-input")], _selectElement_dec2 = [e7("sl-select")], _a11) {
  constructor() {
    super(...arguments);
    __privateAdd(this, _container, __runInitializers(_init11, 8, this)), __runInitializers(_init11, 11, this);
    __privateAdd(this, _options, __runInitializers(_init11, 12, this, [])), __runInitializers(_init11, 15, this);
    __privateAdd(this, _value, __runInitializers(_init11, 16, this)), __runInitializers(_init11, 19, this);
    __privateAdd(this, _searchTerm2, __runInitializers(_init11, 20, this, "")), __runInitializers(_init11, 23, this);
    __privateAdd(this, _searchElement2, __runInitializers(_init11, 24, this)), __runInitializers(_init11, 27, this);
    __privateAdd(this, _selectElement2, __runInitializers(_init11, 28, this)), __runInitializers(_init11, 31, this);
  }
  /*
  
    */
  // Move the option gathering logic to firstUpdated lifecycle method
  firstUpdated() {
    const containersSlot = this.container?.shadowRoot.querySelector("slot");
    const assignedElements = containersSlot.assignedElements();
    let wwWidgetElements = assignedElements.filter(
      (el) => el.classList.contains("ww-widget")
    );
    wwWidgetElements = wwWidgetElements.filter(
      (el) => el.tagName.toLowerCase().includes("webwriter-quiz") || el.tagName.toLowerCase().includes("webwriter-task")
    );
    this.options = [...this.options, ...wwWidgetElements];
  }
  render() {
    return ke`
      <sl-select
        placement="bottom"
        hoist
        class="nodeSelect"
        placeholder="Select element"
        clearable
        .value=${this.value}
        @sl-input=${this._handleElementSelect}
      >
        ${this.container instanceof WebWriterGamebookPage ? ke` <small class="icon-header" id="divider-page"
              ><sl-icon src="${file_default2}"></sl-icon>${this.container?.pageTitle}</small
            >` : this.container instanceof WebWriterGamebookPopup ? ke`<small class="icon-header" id="divider-page"
              ><sl-icon src="${squares_default}"></sl-icon>${this.container?.pageTitle}</small
            >` : null}
        ${this.options.length === 0 ? ke`<small class="message"
              >No quiz element found.
              <br />
              Download the quiz WebWriter Quiz Widget over packages
              <sl-icon
                src="${packages_default}"
                style="vertical-align: middle; margin: 1px;"
              ></sl-icon
            ></small>` : ke`${Qt(
      this.options,
      (element) => element.id,
      // or use another unique identifier
      (element) => ke`
                <sl-option value=${`${element.id}`}>
                  ${element.tagName.toLowerCase().includes("webwriter-task") ? ke`${element.children[1].tagName.replace("WEBWRITER-", "").toLowerCase().replace(/^./, (str) => str.toUpperCase())}
                      ${element.children[1]?.tagName.toLowerCase().includes("order") ? ke`
                            <sl-icon slot="prefix" src=${number_123_default}></sl-icon>
                            <p
                              slot="suffix"
                              style="color: lightgray; margin: 0px; padding: 4px;"
                            >
                              (${element.children[0].textContent + "..."})
                            </p>
                          ` : element.children[1].tagName.toLowerCase().includes("choice") ? ke`<sl-icon slot="prefix" src=${checkbox_default2}></sl-icon>
                            <p
                              slot="suffix"
                              style="color: lightgray; margin: 0px; padding: 4px;"
                            >
                              (${element.children[0].textContent + "..."})
                            </p> ` : element.children[1].tagName.toLowerCase().includes("text") ? ke`<sl-icon
                              slot="prefix"
                              src=${blockquote_default}
                            ></sl-icon>
                            <p
                              slot="suffix"
                              style="color: lightgray; margin: 0px; padding: 4px;"
                            >
                              (${element.children[0].textContent + "..."})
                            </p> ` : element.children[1].tagName.toLowerCase().includes("mark") ? ke`<sl-icon
                              slot="prefix"
                              src=${highlight_default}
                            ></sl-icon>
                            <p
                              slot="suffix"
                              style="color: lightgray; margin: 0px; padding: 4px;"
                            >
                              (${element.children[0].textContent + "..."})
                            </p> ` : element.children[1].tagName.toLowerCase().includes("speech") ? ke`<sl-icon
                              slot="prefix"
                              src=${microphone_default}
                            ></sl-icon>
                            <p
                              slot="suffix"
                              style="color: lightgray; margin: 0px; padding: 4px;"
                            >
                              (${element.children[0].textContent + "..."})
                            </p> ` : null} ` : element.tagName.toLowerCase().includes("webwriter-quiz") ? ke`
                        ${element.tagName.replace("WEBWRITER-", "").toLowerCase().replace(/^./, (str) => str.toUpperCase())}
                        ${element.tagName.toLowerCase().includes("quiz") ? ke`<sl-icon
                              slot="prefix"
                              src=${help_octagon_default}
                            ></sl-icon>` : null}
                      ` : null}
                </sl-option>
              `
    )}`}
      </sl-select>
    `;
  }
  _handleElementSelect(event) {
    if (event.target instanceof HTMLElement && event.target.tagName.toLowerCase() === "sl-select") {
      const selectedValue = event.target.value;
      this.value = selectedValue;
    }
  }
};
_init11 = __decoratorStart(_a11);
_container = new WeakMap();
_options = new WeakMap();
_value = new WeakMap();
_searchTerm2 = new WeakMap();
_searchElement2 = new WeakMap();
_selectElement2 = new WeakMap();
__decorateElement(_init11, 4, "container", _container_dec, WebWriterQuizSelect, _container);
__decorateElement(_init11, 4, "options", _options_dec, WebWriterQuizSelect, _options);
__decorateElement(_init11, 4, "value", _value_dec, WebWriterQuizSelect, _value);
__decorateElement(_init11, 4, "searchTerm", _searchTerm_dec2, WebWriterQuizSelect, _searchTerm2);
__decorateElement(_init11, 4, "searchElement", _searchElement_dec2, WebWriterQuizSelect, _searchElement2);
__decorateElement(_init11, 4, "selectElement", _selectElement_dec2, WebWriterQuizSelect, _selectElement2);
WebWriterQuizSelect = __decorateElement(_init11, 0, "WebWriterQuizSelect", _WebWriterQuizSelect_decorators, WebWriterQuizSelect);
__publicField(WebWriterQuizSelect, "styles", i`
    .nodeSelect {
      width: 100%;
    }

    sl-select::part(listbox) {
      width: 250px;
      height: 250px;
    }

    .node-option-visible {
      display: block;
    }
    .node-option-hidden {
      display: none;
    }

    .message {
      display: inline-block;
      margin: 10px 20px; /* Adjust margin for padding around the small element */
      padding: 10px; /* Optional: for internal padding */
      border-radius: 8px; /* Soft round corners */
      background-color: #f9f9f9; /* Light background for better readability */
      color: #333; /* Text color */
      font-size: 14px; /* Adjust the size of the text */
      line-height: 1.5; /* Make sure the text is well spaced */
    }

    .icon-header {
      display: flex;
      align-items: center;
      gap: 7px;
    }
  `);
__runInitializers(_init11, 1, WebWriterQuizSelect);

// src/components/component-select/webwriter-quiz-tasks-select/webwriter-quiz-tasks-select.ts
var _selectElement_dec3, _searchElement_dec3, _searchTerm_dec3, _value_dec2, _options_dec2, _quiz_dec, _a12, _WebWriterQuizTasksSelect_decorators, _init12, _quiz, _options2, _value2, _searchTerm3, _searchElement3, _selectElement3;
_WebWriterQuizTasksSelect_decorators = [t4("webwriter-quiz-tasks-select")];
var WebWriterQuizTasksSelect = class extends (_a12 = h3, _quiz_dec = [n6({ type: Object })], _options_dec2 = [n6({ type: Object })], _value_dec2 = [n6({ type: String })], _searchTerm_dec3 = [r5()], _searchElement_dec3 = [e7("sl-input")], _selectElement_dec3 = [e7("sl-select")], _a12) {
  constructor() {
    super(...arguments);
    __privateAdd(this, _quiz, __runInitializers(_init12, 8, this)), __runInitializers(_init12, 11, this);
    __privateAdd(this, _options2, __runInitializers(_init12, 12, this, [])), __runInitializers(_init12, 15, this);
    __privateAdd(this, _value2, __runInitializers(_init12, 16, this)), __runInitializers(_init12, 19, this);
    __privateAdd(this, _searchTerm3, __runInitializers(_init12, 20, this, "")), __runInitializers(_init12, 23, this);
    __privateAdd(this, _searchElement3, __runInitializers(_init12, 24, this)), __runInitializers(_init12, 27, this);
    __privateAdd(this, _selectElement3, __runInitializers(_init12, 28, this)), __runInitializers(_init12, 31, this);
  }
  /*
  
    */
  // Move the option gathering logic to firstUpdated lifecycle method
  firstUpdated() {
    const containersSlot = this.quiz?.shadowRoot.querySelector("slot");
    const assignedElements = containersSlot.assignedElements();
    const tasks = assignedElements.filter(
      (el) => el.tagName.toLowerCase().includes("webwriter-task")
    );
    let taskOptions = [];
    tasks.forEach((task) => {
      const taskContent = task.children;
      const prompt = taskContent[0];
      const taskElement = taskContent[1];
      if (!taskElement.tagName.toLowerCase().includes("speech")) {
        taskOptions = [
          ...taskOptions,
          { task, prompt, taskElement }
        ];
      }
    });
    this.options = [...this.options, ...taskOptions];
  }
  updated(_changedProperties) {
    const partTags = this.selectElement.shadowRoot?.querySelector('div[part="tags"]');
    if (partTags?.childElementCount >= 2) {
      this.selectElement.classList.add("two-tags");
    } else {
      this.selectElement.classList.remove("two-tags");
    }
  }
  render() {
    return ke` <sl-select
      placement="bottom"
      hoist
      class="nodeSelect"
      placeholder="Select Tasks"
      .value=${this.value}
      @sl-input=${this._handleElementSelect}
      multiple
      max-options-visible="1"
    >
      <small class="icon-header" id="divider-page"
        >Select task(s) from the quiz</small
      >
      ${this.options.length === 0 ? ke`<small class="message">No tasks found in the quiz. </small>` : ke` ${Qt(
      this.options,
      (element) => element.id,
      (element, index) => ke`
              <sl-option value=${`${element.task.id}`}>
                ${`${index + 1}. ${element.taskElement.tagName.replace("WEBWRITER-", "").toLowerCase().replace(/^./, (str) => str.toUpperCase())}`}
                ${element.taskElement.tagName.toLowerCase().includes("order") ? ke` <sl-icon slot="prefix" src=${number_123_default}></sl-icon>` : element.taskElement.tagName.toLowerCase().includes("choice") ? ke`<sl-icon slot="prefix" src=${checkbox_default2}></sl-icon>` : element.taskElement.tagName.toLowerCase().includes("text") ? ke`<sl-icon slot="prefix" src=${blockquote_default}></sl-icon>` : element.taskElement.tagName.toLowerCase().includes("mark") ? ke`<sl-icon slot="prefix" src=${highlight_default}></sl-icon>` : element.taskElement.tagName.toLowerCase().includes("speech") ? ke`<sl-icon slot="prefix" src=${microphone_default}></sl-icon>` : null}

                <p
                  slot="suffix"
                  style="color: lightgray; margin: 0px; padding: 4px;"
                >
                  (${element.prompt.textContent.substring(0, 10) + "..."})
                </p>
              </sl-option>
            `
    )}`}
    </sl-select>`;
  }
  _handleElementSelect(event) {
    if (event.target instanceof HTMLElement && event.target.tagName.toLowerCase() === "sl-select") {
      const selectedValue = event.target.value;
      this.value = selectedValue;
    }
  }
};
_init12 = __decoratorStart(_a12);
_quiz = new WeakMap();
_options2 = new WeakMap();
_value2 = new WeakMap();
_searchTerm3 = new WeakMap();
_searchElement3 = new WeakMap();
_selectElement3 = new WeakMap();
__decorateElement(_init12, 4, "quiz", _quiz_dec, WebWriterQuizTasksSelect, _quiz);
__decorateElement(_init12, 4, "options", _options_dec2, WebWriterQuizTasksSelect, _options2);
__decorateElement(_init12, 4, "value", _value_dec2, WebWriterQuizTasksSelect, _value2);
__decorateElement(_init12, 4, "searchTerm", _searchTerm_dec3, WebWriterQuizTasksSelect, _searchTerm3);
__decorateElement(_init12, 4, "searchElement", _searchElement_dec3, WebWriterQuizTasksSelect, _searchElement3);
__decorateElement(_init12, 4, "selectElement", _selectElement_dec3, WebWriterQuizTasksSelect, _selectElement3);
WebWriterQuizTasksSelect = __decorateElement(_init12, 0, "WebWriterQuizTasksSelect", _WebWriterQuizTasksSelect_decorators, WebWriterQuizTasksSelect);
__publicField(WebWriterQuizTasksSelect, "styles", i`
    .nodeSelect {
      width: 100%;
    }

    sl-select::part(listbox) {
      width: 250px;
      height: 250px;
    }

    sl-select::part(tags) {
      width: 80px;
    }

    sl-select::part(tag) {
      max-width: 40%; /* Adjust the width to your needs */

      white-space: nowrap; /* Ensure text is in one line */
      overflow: hidden; /* Hide overflowing text */
      text-overflow: ellipsis; /* Add "..." if text overflows */
    }

    sl-select.two-tags::part(tag) {
      display: inline-flex; /* Keep the layout as inline flex */

      max-width: 30px; /* Control the minimum width */

      white-space: nowrap; /* Ensure the text stays in one line */
      overflow: hidden; /* Hide overflowing content */
      text-overflow: ellipsis; /* Add ellipsis for truncated content */
      box-sizing: border-box; /* Include padding/border in width calculation */
    }

    .node-option-visible {
      display: block;
    }
    .node-option-hidden {
      display: none;
    }

    .icon-header {
      display: flex;
      align-items: center;
      gap: 7px;
    }
  `);
__runInitializers(_init12, 1, WebWriterQuizTasksSelect);

// src/components/node-detail-view/branch-node-detail-view/branch-node-detail-view.ts
var _editorStore_dec6, _hoveredDividerIndex_dec, _ruleDrag_dec, _a13, _BranchNodeDetailView_decorators, _init13, _ruleDrag, _hoveredDividerIndex, _editorStore6;
_BranchNodeDetailView_decorators = [t4("branch-node-detail-view")];
var BranchNodeDetailView = class extends (_a13 = LitElementWw, _ruleDrag_dec = [n6({ type: Boolean })], _hoveredDividerIndex_dec = [n6({ type: Number })], _editorStore_dec6 = [c4({ context: editorState, subscribe: true }), n6({ type: Object, attribute: true, reflect: false })], _a13) {
  constructor() {
    super(...arguments);
    __privateAdd(this, _ruleDrag, __runInitializers(_init13, 8, this, false)), __runInitializers(_init13, 11, this);
    __publicField(this, "draggedIndex", -1);
    __privateAdd(this, _hoveredDividerIndex, __runInitializers(_init13, 12, this, -1)), __runInitializers(_init13, 15, this);
    __privateAdd(this, _editorStore6, __runInitializers(_init13, 16, this, new GamebookEditorState("Default"))), __runInitializers(_init13, 19, this);
  }
  //registering custom elements used in the widget
  static get scopedElements() {
    return {
      "sl-button": button_default,
      "sl-icon-button": icon_button_default,
      "sl-icon": icon_default,
      "sl-select": select_default,
      "sl-input": input_default,
      "sl-option": option_default,
      "sl-divider": divider_default,
      "node-output-select": NodeOutputSelect,
      "webwriter-quiz-select": WebWriterQuizSelect,
      "toggle-text-input": ToggleTextInput,
      "node-connection-list": NodeConnectionList,
      "webwriter-quiz-tasks-select": WebWriterQuizTasksSelect
    };
  }
  //
  //
  firstUpdated(_changedProperties) {
  }
  render() {
    let isConnected = this.editorStore.selectedContainer?.incomingContainerId !== -1;
    return ke`
      <div class="title-bar">
        <div class="div-icon-branch">
          <sl-icon src=${arrows_split_2_default}></sl-icon>
        </div>
        <div class="div-title">
          <toggle-text-input
            .text=${this.editorStore.selectedNode.data.title}
            .saveChanges=${(string) => this.renameNode(string)}
          ></toggle-text-input>
          <p class="subtitle">Branch</p>
        </div>
        <div class="inputOutputControls">
          <node-connection-list
            branch
            .selectedNode=${this.editorStore.selectedNode}
          ></node-connection-list>
        </div>
      </div>
      ${this.editorStore.selectedContainer ? ke`<div class="container">
            <div class="titlebar">
              <p
                class="title"
                style=${isConnected ? "color: #505055" : "color: darkgrey"}
              >
                Rules
                (${this.editorStore.selectedContainer.rules?.length.toString()})
              </p>
              <sl-icon-button
                src=${plus_default}
                class="add"
                @click=${() => this.addEmptyRule()}
                ?disabled=${!isConnected}
              >
              </sl-icon-button>
            </div>

            <div class="ruleList">
              ${this.editorStore.selectedContainer?.rules?.length > 0 ? ke`
                    ${Qt(
      this.editorStore.selectedContainer?.rules,
      (rule, index) => ke`
                    <!-- top divider  -->
                    <sl-divider
                      class="rule-divider"
                      style="
                            visibility: ${this.draggedIndex == -1 || index > this.draggedIndex || index == this.draggedIndex ? "hidden" : "visible"};
                              opacity: ${this.hoveredDividerIndex == index ? "100%" : "0%"};  
                              "
                    ></sl-divider>
                    <!--   -->
      
                        <div
                             class="ruleItem"
                             id="horizontal-stack-${index}"
                             draggable="true"
                             @dragstart=${(e10) => this._onDragStart(e10, index)}
                             @dragend=${this._onDragEnd}
                             @dragover=${(e10) => this._onDragOver(e10, index)}
                             @dragleave=${(e10) => this._onDragLeave(e10, index)}
                             @drop=${(e10) => this._onDrop(e10)}
                           >
                             <div
                               id="index"
                               style="min-width: 25px; display: flex; flex-direction: row; align-items: center; justify-content: center;"
                             >
                               <p style="color: darkgrey; font-size: 15px;">
                                 ${parseInt(
        rule.output_id.split("_")[1],
        10
      )}
                               </p>
                             </div>

                             <sl-icon
                               class="draggable"
                               src=${grip_horizontal_default}
                               style="font-size: 15px; flex-shrink: 0"
                             ></sl-icon>

                             <!-- Element -->
                             <webwriter-quiz-select
                               .value=${rule.elementId}
                               @sl-change=${(e10) => this.updateRuleElement(
        index,
        e10.target.selectElement.value.toString()
      )}
                               .container=${this.editorStore.branchIncomingContainer}
                             >
                             </webwriter-quiz-select>

                             <!-- Subelements -->
                             ${rule.elementId !== "" && rule.elementId !== "text" && this.editorStore.branchIncomingContainer.querySelector(`#${rule.elementId}`)?.tagName.toLowerCase() == "webwriter-quiz" ? ke` <webwriter-quiz-tasks-select
                                     .value=${rule.quizTasks.split(" ")}
                                     @sl-change=${(e10) => this.updateRuleTasks(
        index,
        e10.target.selectElement.value.toString()
      )}
                                     .quiz=${this.editorStore.branchIncomingContainer.querySelector(
        `#${rule.elementId}`
      )}
                                   >
                                   </webwriter-quiz-tasks-select>` : null}

                             <!-- Condition -->
                             <sl-select
                               clearable
                               placeholder="Condition"
                               value=${rule.condition}
                               @sl-change=${(e10) => this.updateRuleCondition(
        index,
        e10.target.value
      )}
                               ?disabled=${!rule.isConditionEnabled}
                             >
                               <!-- Quiz Conditions -->
                               <sl-option value="correct">
                                 <sl-icon
                                   slot="prefix"
                                   src=${circle_dashed_check_default}
                                 ></sl-icon>
                                 Correct</sl-option
                               >
                               <sl-option value="incorrect">
                                 <sl-icon
                                   slot="prefix"
                                   src=${circle_dashed_x_default}
                                 ></sl-icon>
                                 Incorrect</sl-option
                               >
                             </sl-select>

                             <!-- Match -->
                             ${rule.elementId !== "" ? ke`${this.editorStore.branchIncomingContainer.querySelector(`#${rule.elementId}`)?.tagName?.toLowerCase() === "webwriter-quiz" && rule.condition == "" ? ke`
                                         <sl-input
                                           placeholder="Match"
                                           ?disabled=${!rule.isMatchEnabled}
                                         ></sl-input>
                                       ` : this.editorStore.branchIncomingContainer.querySelector(`#${rule.elementId}`)?.tagName.toLowerCase() == "webwriter-quiz" && (rule.condition == "correct" || rule.condition == "incorrect") ? ke`<sl-input
                                         id="percent"
                                         placeholder="..."
                                         value=${rule.match}
                                         type="number"
                                         min="0"
                                         max="100"
                                         inputmode="numeric"
                                         @sl-input=${(e10) => this._validateAndUpdateRuleMatch(
        e10,
        index
      )}
                                       >
                                         <sl-icon
                                           src=${percentage_default}
                                           slot="prefix"
                                         ></sl-icon>
                                       </sl-input>` : null}` : null}

                             <!-- Output -->
                             <node-output-select
                              
                               .selectedNode=${this.editorStore.selectedNode}
                               .incomingNodeId=${this.editorStore.selectedNode.inputs["input_1"].connections?.[0]?.node}
                               .outputClass=${rule.output_id}
                               ?disabled=${!rule.isTargetEnabled}
                               required="true"
                             ></node-output-select>

                             <sl-icon-button
                               class="minus"
                               src=${minus_default}
                               style="font-size: 15px;"
                               @click=${() => this.editorStore.selectedContainer.deleteRule(
        rule.output_id
      )}
                               ?disabled=${!this.isConnected}
                             ></sl-icon-button>
                           </div>
                 
                      <!-- bottom divider -->
                      <sl-divider
                        class="rule-divider"
                        style="
                           visibility: ${this.draggedIndex == -1 || index < this.draggedIndex || index == this.draggedIndex ? "hidden" : "visible"};
                            opacity: ${this.hoveredDividerIndex == index ? "100%" : "0%"};
                            "
                      ></sl-divider>
                      <!--  -->
                    </div>
                  `
    )}

                    <sl-divider></sl-divider>

                    <!-- the else rule  -->
                    <div class="ruleItem" id="horizontal-stack-else">
                      <div
                        id="index"
                        style="min-width: 25px; display: flex; flex-direction: row; align-items: center; justify-content: center;"
                      >
                        <p style="color: darkgrey; font-size: 15px;">
                          If no rule is satisfied, go to
                        </p>
                      </div>

                      <!-- Output -->
                      <node-output-select
                        .selectedNode=${this.editorStore.selectedNode}
                        .incomingNodeId=${this.editorStore.selectedNode.inputs["input_1"].connections?.[0]?.node}
                        .outputClass=${this.editorStore.selectedContainer.elseRule?.output_id}
                        required="true"
                      ></node-output-select>
                    </div>
                  ` : ke`<p class="no-node">No branching rules</p>`}
            </div>
            <slot></slot>
          </div>` : null}
    `;
  }
  /*
  
  
    */
  _onDragStart(event, index) {
    this.draggedIndex = index;
    const stackElement = this.shadowRoot?.getElementById(
      `horizontal-stack-${index}`
    );
    if (stackElement) {
      stackElement.classList.add("dragging");
    }
    this.requestUpdate();
  }
  /*
  
  
    */
  _onDragEnd() {
    if (this.draggedIndex !== -1) {
      const stackElement = this.shadowRoot?.getElementById(
        `horizontal-stack-${this.draggedIndex}`
      );
      if (stackElement) {
        stackElement.classList.remove("dragging");
      }
    }
    this.draggedIndex = -1;
    this.hoveredDividerIndex = -1;
    this.requestUpdate();
  }
  /*
  
  
    */
  _onDragOver(event, index) {
    event.preventDefault();
    this.hoveredDividerIndex = index;
    this.requestUpdate();
  }
  /*
  
  
    */
  _onDragLeave(event, index) {
    event.preventDefault();
    this.hoveredDividerIndex = -1;
    this.requestUpdate();
  }
  /*
  
  
    */
  _onDrop(event) {
    event.preventDefault();
    if (this.draggedIndex !== -1 && this.hoveredDividerIndex !== -1 && this.draggedIndex !== this.hoveredDividerIndex) {
      const { selectedContainer, selectedNode } = this.editorStore;
      let staticCopyRules = this.editorStore.selectedContainer.rules;
      const hoveredRuleOutput = selectedContainer.rules[this.hoveredDividerIndex].output_id;
      const draggedRuleOutput = selectedContainer.rules[this.draggedIndex].output_id;
      const outputs = selectedNode.outputs;
      outputs[draggedRuleOutput].connections.forEach((connection) => {
        const connectionDetail = {
          outputNodeId: selectedNode.id,
          inputNodeId: connection.node,
          inputClass: "input_1"
        };
        this.dispatchEvent(
          new CustomEvent("createConnection", {
            detail: { ...connectionDetail, outputClass: hoveredRuleOutput },
            bubbles: true,
            composed: true
          })
        );
        this.dispatchEvent(
          new CustomEvent("deleteConnection", {
            detail: { ...connectionDetail, outputClass: draggedRuleOutput },
            bubbles: true,
            composed: true
          })
        );
      });
      const hoveredOutputNumber = parseInt(hoveredRuleOutput.split("_")[1], 10);
      const draggedOutputNumber = parseInt(draggedRuleOutput.split("_")[1], 10);
      const [minOutputNumber, maxOutputNumber] = [
        Math.min(hoveredOutputNumber, draggedOutputNumber),
        Math.max(hoveredOutputNumber, draggedOutputNumber)
      ];
      const adjustment = hoveredOutputNumber < draggedOutputNumber ? 1 : -1;
      Object.keys(outputs).forEach((outputClass, index) => {
        const outputIdNumber = parseInt(outputClass.split("_")[1], 10);
        if (outputIdNumber >= minOutputNumber && outputIdNumber <= maxOutputNumber && outputIdNumber !== draggedOutputNumber) {
          const newOutputClass = `output_${outputIdNumber + adjustment}`;
          outputs[outputClass].connections?.forEach((connection) => {
            const connectionDetail = {
              outputNodeId: selectedNode.id,
              inputNodeId: connection.node,
              inputClass: "input_1"
            };
            this.dispatchEvent(
              new CustomEvent("createConnection", {
                detail: { ...connectionDetail, outputClass: newOutputClass },
                bubbles: true,
                composed: true
              })
            );
            this.dispatchEvent(
              new CustomEvent("deleteConnection", {
                detail: { ...connectionDetail, outputClass },
                bubbles: true,
                composed: true
              })
            );
          });
          staticCopyRules[index].output_id = newOutputClass;
        }
      });
      staticCopyRules[this.draggedIndex].output_id = hoveredRuleOutput;
      let [draggedRule] = staticCopyRules.splice(this.draggedIndex, 1);
      staticCopyRules.splice(this.hoveredDividerIndex, 0, draggedRule);
      this.editorStore.selectedContainer.updateRules(staticCopyRules);
    }
    this._onDragEnd();
    this.dispatchEvent(
      new CustomEvent("markOutputs", {
        bubbles: true,
        composed: true
      })
    );
    this.editorStore.setSelectedContainer(this.editorStore.selectedContainer);
    this.requestUpdate();
  }
  /*
  
  
    */
  _validateAndUpdateRuleMatch(e10, index) {
    const inputElement = e10.target;
    let value = inputElement.value;
    if (value != "") {
      value = value.replace(/[^0-9]/g, "");
      let numericValue = Number(value);
      if (numericValue < 0) numericValue = 0;
      if (numericValue > 100) numericValue = 100;
      inputElement.value = numericValue.toString();
    }
    this.editorStore.selectedContainer._updateRuleMatch(
      index,
      inputElement.value
    );
    this.editorStore.setSelectedContainer(this.editorStore.selectedContainer);
    this.requestUpdate();
  }
  /*
  
  
    */
  addEmptyRule() {
    this.dispatchEvent(
      new CustomEvent("addOutput", {
        detail: {
          nodeId: this.editorStore.selectedNode.id
        },
        bubbles: true,
        composed: true
      })
    );
    this.editorStore.selectedContainer.addEmptyRule(
      this.editorStore.selectedNode
    );
    if (this.editorStore.selectedContainer.elseRule) {
      this.editorStore.selectedContainer._moveElseRuleToLastOutput(
        this.editorStore.selectedNode
      );
    } else {
      this.dispatchEvent(
        new CustomEvent("addOutput", {
          detail: {
            nodeId: this.editorStore.selectedNode.id
          },
          bubbles: true,
          composed: true
        })
      );
      this.editorStore.selectedContainer.addEmptyElseRule(
        this.editorStore.selectedNode
      );
    }
    this.editorStore.setSelectedContainer(this.editorStore.selectedContainer);
    this.requestUpdate();
  }
  /*
  
  
    */
  updateRuleElement(index, value) {
    this.editorStore.selectedContainer._updateRuleElement(
      index,
      value,
      this.editorStore.branchIncomingContainer
    );
    this.editorStore.setSelectedContainer(this.editorStore.selectedContainer);
    this.requestUpdate();
  }
  /* 
  
  */
  updateRuleTasks(index, value) {
    this.editorStore.selectedContainer._updateRuleTasks(
      index,
      value,
      this.editorStore.branchIncomingContainer
    );
    this.editorStore.setSelectedContainer(this.editorStore.selectedContainer);
    this.requestUpdate();
  }
  /* 
  
  */
  updateRuleCondition(index, value) {
    this.editorStore.selectedContainer._updateRuleCondition(
      index,
      value,
      this.editorStore.branchIncomingContainer
    );
    this.editorStore.setSelectedContainer(this.editorStore.selectedContainer);
    this.requestUpdate();
  }
  /*
  
  */
  /*
  
  
    */
  renameNode(text) {
    const event = new CustomEvent("renameSelectedNode", {
      detail: { newTitle: text },
      bubbles: true,
      composed: true
    });
    this.dispatchEvent(event);
  }
};
_init13 = __decoratorStart(_a13);
_ruleDrag = new WeakMap();
_hoveredDividerIndex = new WeakMap();
_editorStore6 = new WeakMap();
__decorateElement(_init13, 4, "ruleDrag", _ruleDrag_dec, BranchNodeDetailView, _ruleDrag);
__decorateElement(_init13, 4, "hoveredDividerIndex", _hoveredDividerIndex_dec, BranchNodeDetailView, _hoveredDividerIndex);
__decorateElement(_init13, 4, "editorStore", _editorStore_dec6, BranchNodeDetailView, _editorStore6);
BranchNodeDetailView = __decorateElement(_init13, 0, "BranchNodeDetailView", _BranchNodeDetailView_decorators, BranchNodeDetailView);
//import CSS
__publicField(BranchNodeDetailView, "styles", [branch_node_detail_view_styles_default]);
__runInitializers(_init13, 1, BranchNodeDetailView);

// src/components/node-detail-view/node-detail-view.ts
var _tabIndex_dec4, _editorStore_dec7, _a14, _NodeDetailsView_decorators, _init14, _editorStore7, _tabIndex4;
_NodeDetailsView_decorators = [t4("node-detail-view")];
var NodeDetailsView = class extends (_a14 = LitElementWw, _editorStore_dec7 = [c4({ context: editorState, subscribe: true }), n6({ type: Object, attribute: true, reflect: false })], _tabIndex_dec4 = [n6({ type: Number, attribute: true, reflect: true })], _a14) {
  constructor() {
    super(...arguments);
    __privateAdd(this, _editorStore7, __runInitializers(_init14, 8, this, new GamebookEditorState("Default"))), __runInitializers(_init14, 11, this);
    __privateAdd(this, _tabIndex4, __runInitializers(_init14, 12, this, -1)), __runInitializers(_init14, 15, this);
  }
  static get scopedElements() {
    return {
      "page-node-detail-view": PageNodeDetailView,
      "popup-node-detail-view": PopupNodeDetailView,
      "branch-node-detail-view": BranchNodeDetailView,
      "toggle-text-input": ToggleTextInput,
      "node-connection-list": NodeConnectionList,
      "sl-icon": icon_default,
      "sl-divider": divider_default
    };
  }
  render() {
    return ke`
      ${this.editorStore.selectedNode.id !== -1 ? ke` <div class="selected-node">
            ${this.editorStore.selectedNode.class == "page" || this.editorStore.selectedNode.class == "origin" ? ke`
                  <page-node-detail-view>
                    <slot></slot>
                  </page-node-detail-view>
                ` : this.editorStore.selectedNode.class == "branch" ? ke` <branch-node-detail-view>
                  <slot></slot>
                </branch-node-detail-view>` : this.editorStore.selectedNode.class == "popup" ? ke`
                  <popup-node-detail-view>
                    <slot></slot>
                  </popup-node-detail-view>
                ` : null}
          </div>` : ke`
            <div class="no-node-selected">
              <p>Click on a node to view its content</p>
              <slot></slot>
            </div>
          `}
    `;
  }
  /*
  
  
    */
  renameNode(text) {
  }
};
_init14 = __decoratorStart(_a14);
_editorStore7 = new WeakMap();
_tabIndex4 = new WeakMap();
__decorateElement(_init14, 4, "editorStore", _editorStore_dec7, NodeDetailsView, _editorStore7);
__decorateElement(_init14, 4, "tabIndex", _tabIndex_dec4, NodeDetailsView, _tabIndex4);
NodeDetailsView = __decorateElement(_init14, 0, "NodeDetailsView", _NodeDetailsView_decorators, NodeDetailsView);
//import CSS
__publicField(NodeDetailsView, "styles", [node_detail_view_styles_default]);
__runInitializers(_init14, 1, NodeDetailsView);

// src/components/gamebook/gamebook-viewer/webwriter-gamebook-viewer.styles.ts
var webwriter_gamebook_viewer_styles_default = i`
  :host * {
    box-sizing: border-box;
  }

  :host {
    width: 100%;
    height: fit-content;
    box-sizing: border-box;
    overflow: hidden;
  }

  .gamebook {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* Center items vertically */
    gap: 0px;
    //-webkit-box-shadow: 0 2px 20px 2px #d0d0d0;
    //box-shadow: 0 2px 20px 2px #d0d0d0;

    box-sizing: border-box;
    width: 100%;
    border: 1px solid #e4e4e4;
  }

  .titlebar {
    box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1); /* Add a subtle shadow */
    width: 100%;
    background-color: white;
    color: #3f3f46;
    border-bottom: 1px solid #e4e4e4;
  }

  .gamebookTitle {
    position: relative;

    font-weight: 600;

    box-sizing: border-box;
    font-size: 22px;

    padding-top: 10px;
    padding-left: 10px;
    padding-bottom: 10px;

    height: auto;

    display: flex;
    align-items: center; /* Vertically center */
    justify-content: flex-start; /* Horizontally align at the start */

    width: 100%;
  }

  .pageTitle {
    font-size: 16px;

    height: auto;
    display: flex;
    align-items: center; /* Vertically center */
    justify-content: flex-start; /* Horizontally align at the start */
    box-sizing: border-box;

    width: 100%; /* Adjust width to account for padding */
    padding-left: 10px;
    padding-bottom: 10px;
  }

  .surrounding {
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #fbfbfb;
    padding: 20px;
    box-shadow: inset 0px 4px 8px rgba(0, 0, 0, 0.1); /* Drop-in shadow */
    min-width: 100%;
    position: relative;
  }

  .page {
    display: flex;
    position: relative;
    flex-direction: column;
    gap: 10px; /* Adjust the value to your desired spacing */
    box-sizing: border-box;
    min-width: 100%;
    height: 600px; /* Set a fixed height (adjust as needed) */
    background-color: white;
    box-shadow: 0px 8px 16px rgba(0, 0, 0, 0.2); /* Stronger shadow */
    overflow-y: auto; /* Make the content scrollable if it overflows */
    z-index: 1; /* Ensure content in page appears above the overlay */
  }

  webwriter-gamebook-popup {
    position: unset !important; /* Use !important to override any inline styles */
  }

  .overlay {
    position: absolute; /* To overlay the .page div */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8); /* Black background with opacity */
    display: flex; /* Flexbox for centering */
    justify-content: center; /* Center horizontally */
    align-items: center; /* Center vertically */
  }
`;

// src/node_modules/@tabler/icons/icons/outline/alert-octagon.svg
var alert_octagon_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-alert-octagon"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M12.802 2.165l5.575 2.389c.48 .206 .863 .589 1.07 1.07l2.388 5.574c.22 .512 .22 1.092 0 1.604l-2.389 5.575c-.206 .48 -.589 .863 -1.07 1.07l-5.574 2.388c-.512 .22 -1.092 .22 -1.604 0l-5.575 -2.389a2.036 2.036 0 0 1 -1.07 -1.07l-2.388 -5.574a2.036 2.036 0 0 1 0 -1.604l2.389 -5.575c.206 -.48 .589 -.863 1.07 -1.07l5.574 -2.388a2.036 2.036 0 0 1 1.604 0z" />%0A  <path d="M12 8v4" />%0A  <path d="M12 16h.01" />%0A</svg>';

// src/components/gamebook/gamebook-components/gamebook-containers/gamebook-branch/webwriter-gamebook-branch.ts
var _pageTitle_dec3, _elseRule_dec, _rules_dec, _incomingContainerId_dec, _drawflowNodeId_dec3, _a15, _WebWriterGamebookBranch_decorators, _init15, _drawflowNodeId3, _incomingContainerId, _rules, _elseRule, _pageTitle3;
_WebWriterGamebookBranch_decorators = [t4("webwriter-gamebook-branch")];
var WebWriterGamebookBranch = class extends (_a15 = LitElementWw, _drawflowNodeId_dec3 = [n6({ type: Number, attribute: true, reflect: true })], _incomingContainerId_dec = [n6({ type: Number, attribute: true, reflect: true })], _rules_dec = [n6({ type: Array, attribute: true, reflect: true })], _elseRule_dec = [n6({ type: Object, attribute: true, reflect: true })], _pageTitle_dec3 = [n6({ type: String, attribute: true, reflect: true })], _a15) {
  /* 
  
  
  */
  constructor() {
    super();
    __privateAdd(this, _drawflowNodeId3, __runInitializers(_init15, 8, this)), __runInitializers(_init15, 11, this);
    __privateAdd(this, _incomingContainerId, __runInitializers(_init15, 12, this, -1)), __runInitializers(_init15, 15, this);
    __privateAdd(this, _rules, __runInitializers(_init15, 16, this, [])), __runInitializers(_init15, 19, this);
    __privateAdd(this, _elseRule, __runInitializers(_init15, 20, this)), __runInitializers(_init15, 23, this);
    __privateAdd(this, _pageTitle3, __runInitializers(_init15, 24, this)), __runInitializers(_init15, 27, this);
  }
  //import CSS
  static get styles() {
    return i``;
  }
  //registering custom elements used in the widget
  static get scopedElements() {
    return {
      "sl-button": button_default,
      "webwriter-gamebook-button": WebWriterGamebookButton
    };
  }
  /*
  
  
    */
  render() {
    return ke`<slot></slot>`;
  }
  /*
  
  
    */
  hide() {
    this.style.display = "none";
  }
  /*
  
  
    */
  show() {
    this.style.display = "block";
  }
  /*
  
    Clears all rules from the rules array
    */
  clearRules() {
    this.rules.forEach((rule) => {
      this.deleteRule(rule.output_id);
    });
    this.rules = [];
  }
  /*
  
    Adds a new rule to the rules array
    */
  addRule(newRule) {
    this.rules = [...this.rules, newRule];
  }
  /*
  
  
    */
  addEmptyRule(node) {
    const outputKeys = Object.keys(node.outputs);
    const lastOutputClass = outputKeys[outputKeys.length - 1];
    const emptyRule = {
      output_id: lastOutputClass,
      elementId: "",
      quizTasks: "",
      condition: "",
      match: "",
      target: "",
      isConditionEnabled: false,
      isMatchEnabled: false,
      isTargetEnabled: false
    };
    this.addRule(emptyRule);
    this.dispatchEvent(
      new CustomEvent("markOutputs", {
        bubbles: true,
        composed: true
      })
    );
  }
  /*
  
    Deletes a rule from the rules array by its ID
    */
  deleteRule(output_id) {
    this.dispatchEvent(
      new CustomEvent("deleteOutput", {
        detail: {
          nodeId: this.drawflowNodeId,
          outputClass: output_id
        },
        bubbles: true,
        composed: true
      })
    );
    this.rules = this.rules.filter((rule) => rule.output_id !== output_id);
    this.rules = [...this.rules];
    this.updateAllRulesOutputIds(output_id);
    const noOfExistingRules = this.rules.length;
    if (noOfExistingRules == 0 && this.elseRule !== void 0) {
      this.removeElseRule();
    }
    this.dispatchEvent(
      new CustomEvent("markOutputs", {
        bubbles: true,
        composed: true
      })
    );
  }
  /*
  
  
    */
  updateAllRulesOutputIds(deleted_output_id) {
    const removedOutputClassNumber = parseInt(
      deleted_output_id.split("_")[1],
      10
    );
    this.rules.forEach((rule, index) => {
      const outputIdNumber = parseInt(rule.output_id.split("_")[1], 10);
      if (outputIdNumber > removedOutputClassNumber) {
        this.rules[index].output_id = `output_${outputIdNumber - 1}`;
        this.rules = [...this.rules];
      }
    });
    const elseRuleOutputIdNumber = parseInt(
      this.elseRule?.output_id.split("_")[1],
      10
    );
    if (elseRuleOutputIdNumber > removedOutputClassNumber) {
      this.elseRule = {
        ...this.elseRule,
        output_id: `output_${elseRuleOutputIdNumber - 1}`
      };
    }
  }
  /*
  
    
    */
  updateRuleOutputId(index, new_output_id) {
    this.rules[index] = { ...this.rules[index], output_id: new_output_id };
    this.rules = [...this.rules];
  }
  /*
  
    
    */
  updateRules(rules) {
    this.rules = [...rules];
  }
  /*
  
    
    */
  addEmptyElseRule(node) {
    const outputKeys = Object.keys(node.outputs);
    const lastOutputClass = outputKeys[outputKeys.length - 1];
    const elseRule = {
      output_id: lastOutputClass,
      // Use the last output's output_class as output_id
      elementId: "",
      // Empty element
      quizTasks: "",
      condition: "",
      // Empty condition
      match: "",
      // Empty match
      target: "",
      // Empty target
      isConditionEnabled: false,
      isMatchEnabled: false,
      isTargetEnabled: false
    };
    this.elseRule = { ...elseRule };
    this.dispatchEvent(
      new CustomEvent("markOutputs", {
        bubbles: true,
        composed: true
      })
    );
  }
  /*
  
    
    */
  removeElseRule() {
    this.dispatchEvent(
      new CustomEvent("deleteOutput", {
        detail: {
          nodeId: this.drawflowNodeId,
          outputClass: this.elseRule.output_id
        },
        bubbles: true,
        composed: true
      })
    );
    this.elseRule = void 0;
  }
  /*
  
  
    */
  _moveElseRuleToLastOutput(node) {
    const { outputs } = node;
    const highestOutputIdIndex = this.rules.reduce(
      (maxIndex, rule, currentIndex) => {
        const maxNumber = parseInt(
          this.rules[maxIndex].output_id.split("_")[1],
          10
        );
        const currentNumber = parseInt(rule.output_id.split("_")[1], 10);
        return currentNumber > maxNumber ? currentIndex : maxIndex;
      },
      0
    );
    const elseRuleOutputId = this.elseRule.output_id;
    const newRuleOutputId = this.rules[highestOutputIdIndex].output_id;
    this.rules[highestOutputIdIndex].output_id = elseRuleOutputId;
    this.rules = [...this.rules];
    this.elseRule.output_id = newRuleOutputId;
    outputs[elseRuleOutputId].connections.forEach((connection) => {
      this.dispatchEvent(
        new CustomEvent("createConnection", {
          detail: {
            outputNodeId: node.id,
            inputNodeId: connection.node,
            outputClass: newRuleOutputId,
            inputClass: "input_1"
          },
          bubbles: true,
          composed: true
        })
      );
      this.dispatchEvent(
        new CustomEvent("deleteConnection", {
          detail: {
            outputNodeId: node.id,
            inputNodeId: connection.node,
            outputClass: elseRuleOutputId,
            inputClass: "input_1"
          },
          bubbles: true,
          composed: true
        })
      );
    });
    this.elseRule = {
      ...this.elseRule,
      output_id: newRuleOutputId
    };
    this.dispatchEvent(
      new CustomEvent("markOutputs", {
        bubbles: true,
        composed: true
      })
    );
  }
  /*
  
  
    */
  _updateRuleElement(index, value, container) {
    this.rules[index].elementId = value;
    if (value == "") {
      this.rules[index].isConditionEnabled = false;
      this._updateRuleTasks(index, "", container);
      this._updateRuleCondition(index, "", container);
      this._updateRuleMatch(index, "");
      this._updateRuleTarget(this.rules[index].output_id, "");
    } else if (container?.querySelector(`#${value}`)?.tagName?.toLowerCase() == "webwriter-quiz") {
      this.rules[index].isConditionEnabled = false;
    } else {
      this.rules[index].isConditionEnabled = true;
    }
    this.rules = [...this.rules];
  }
  /*
  
  
    */
  removeElementOfRules(element_id, isQuiz) {
    const resetRule = (rule) => ({
      ...rule,
      elementId: "",
      quizTasks: "",
      condition: "",
      match: "",
      target: "",
      isConditionEnabled: false,
      isMatchEnabled: false,
      isTargetEnabled: false
    });
    let removeConnectionsFromOutputs = [];
    for (let rule of this.rules) {
      if (rule.elementId === element_id) {
        if (rule.target !== "") {
          removeConnectionsFromOutputs.push([rule.output_id, rule.target]);
        }
        rule = resetRule(rule);
        this.rules = this.rules.filter(
          (rule2) => rule2.output_id !== rule2.output_id
        );
        this.addRule(rule);
      } else if (!isQuiz && rule.quizTasks.includes(element_id)) {
        const updatedQuizTaskSelection = rule.quizTasks.replace(element_id, "");
        if (rule.target !== "") {
          removeConnectionsFromOutputs.push([rule.output_id, rule.target]);
        }
        if (!/\S/.test(updatedQuizTaskSelection)) {
          rule = {
            ...rule,
            quizTasks: "",
            condition: "",
            match: "",
            target: "",
            isConditionEnabled: false,
            isMatchEnabled: false,
            isTargetEnabled: false
          };
        } else {
          rule = {
            ...rule,
            quizTasks: updatedQuizTaskSelection,
            condition: "",
            match: "",
            target: "",
            isConditionEnabled: true,
            isMatchEnabled: false,
            isTargetEnabled: false
          };
        }
        this.rules = this.rules.filter(
          (rule2) => rule2.output_id !== rule2.output_id
        );
        this.addRule(rule);
      }
    }
    this.rules = [...this.rules];
    this.requestUpdate();
    return removeConnectionsFromOutputs;
  }
  /*
  
  
    */
  _updateRuleTasks(index, value, container) {
    this.rules[index].isConditionEnabled = value !== "";
    if (value === "") {
      this._updateRuleCondition(index, "", container);
      this._updateRuleMatch(index, "");
      this._updateRuleTarget(this.rules[index].output_id, "");
    }
    this.rules[index].quizTasks = value.replace(/,/g, " ");
    this.rules = [...this.rules];
  }
  /*
  
  
    */
  _updateRuleTarget(output_class, input_id) {
    this.rules.forEach((rule, index) => {
      if (rule.output_id === output_class) {
        if (input_id === "") {
          this.dispatchEvent(
            new CustomEvent("deleteConnection", {
              detail: {
                outputNodeId: this.drawflowNodeId,
                inputNodeId: rule.target,
                outputClass: rule.output_id,
                inputClass: "input_1"
              },
              bubbles: true,
              composed: true
            })
          );
        }
        this.rules[index] = { ...rule, target: input_id };
        this.rules = [...this.rules];
      }
    });
    if (this.elseRule && this.elseRule.output_id === output_class) {
      if (input_id == "") {
        this.dispatchEvent(
          new CustomEvent("deleteConnection", {
            detail: {
              outputNodeId: this.drawflowNodeId,
              inputNodeId: this.elseRule.target,
              outputClass: this.elseRule.output_id,
              inputClass: "input_1"
            },
            bubbles: true,
            composed: true
          })
        );
      }
      this.elseRule = {
        ...this.elseRule,
        target: input_id
      };
    }
  }
  /*
  
  
    */
  _updateRuleCondition(index, value, container) {
    this.rules[index].condition = value;
    if (value == "") {
      this._updateRuleMatch(index, "");
      this._updateRuleTarget(this.rules[index].output_id, "");
      this.rules[index].isMatchEnabled = false;
      this.rules[index].isTargetEnabled = false;
    } else if (container.querySelector(`#${this.rules[index].elementId}`)?.tagName?.toLowerCase() == "webwriter-quiz") {
      this.rules[index].isMatchEnabled = true;
    } else {
      this.rules[index].isTargetEnabled = true;
      this.dispatchEvent(
        new CustomEvent("markOutputs", {
          bubbles: true,
          composed: true
        })
      );
    }
    this.rules = [...this.rules];
  }
  /*
  
  
    */
  _updateRuleMatch(index, value) {
    this.rules[index].match = value;
    this.rules[index].isTargetEnabled = value !== "";
    if (value === "") {
      this._updateRuleTarget(this.rules[index].output_id, "");
    }
    this.rules = [...this.rules];
    this.dispatchEvent(
      new CustomEvent("markOutputs", {
        bubbles: true,
        composed: true
      })
    );
  }
};
_init15 = __decoratorStart(_a15);
_drawflowNodeId3 = new WeakMap();
_incomingContainerId = new WeakMap();
_rules = new WeakMap();
_elseRule = new WeakMap();
_pageTitle3 = new WeakMap();
__decorateElement(_init15, 4, "drawflowNodeId", _drawflowNodeId_dec3, WebWriterGamebookBranch, _drawflowNodeId3);
__decorateElement(_init15, 4, "incomingContainerId", _incomingContainerId_dec, WebWriterGamebookBranch, _incomingContainerId);
__decorateElement(_init15, 4, "rules", _rules_dec, WebWriterGamebookBranch, _rules);
__decorateElement(_init15, 4, "elseRule", _elseRule_dec, WebWriterGamebookBranch, _elseRule);
__decorateElement(_init15, 4, "pageTitle", _pageTitle_dec3, WebWriterGamebookBranch, _pageTitle3);
WebWriterGamebookBranch = __decorateElement(_init15, 0, "WebWriterGamebookBranch", _WebWriterGamebookBranch_decorators, WebWriterGamebookBranch);
__runInitializers(_init15, 1, WebWriterGamebookBranch);

// src/components/gamebook/gamebook-components/gamebook-branch-button/webwriter-gamebook-branch-button.ts
var _button_dec2, _tabIndex_dec5, _submitElements_dec, _elementSubmitted_dec, _disabled_dec2, _variant_dec2, _alignment_dec2, _width_dec2, _outline_dec2, _pill_dec2, _size_dec2, _name_dec2, _getNodeEditor_dec2, _identifier_dec2, _dataTargetId_dec2, _a16, _WebWriterGamebookBranchButton_decorators, _init16, _dataTargetId2, _identifier2, _getNodeEditor2, _name2, _size2, _pill2, _outline2, _width2, _alignment2, _variant2, _disabled2, _elementSubmitted, _submitElements, _tabIndex5, _button2;
_WebWriterGamebookBranchButton_decorators = [t4("webwriter-gamebook-branch-button")];
var WebWriterGamebookBranchButton = class extends (_a16 = LitElementWw, _dataTargetId_dec2 = [n6({ type: Number, reflect: true })], _identifier_dec2 = [n6({ type: String, attribute: true, reflect: true })], _getNodeEditor_dec2 = [n6({ attribute: true })], _name_dec2 = [n6({ type: String, reflect: true })], _size_dec2 = [n6({ type: String, reflect: true })], _pill_dec2 = [n6({ type: Boolean, reflect: true })], _outline_dec2 = [n6({ type: Boolean, reflect: true })], _width_dec2 = [n6({ type: Number, reflect: true })], _alignment_dec2 = [n6({ type: String, reflect: true })], _variant_dec2 = [n6({ type: String, reflect: true })], _disabled_dec2 = [n6({ type: Boolean, reflect: false })], _elementSubmitted_dec = [n6({ type: Object, reflect: false })], _submitElements_dec = [n6({ type: Object, reflect: false })], _tabIndex_dec5 = [n6({ type: Number, attribute: true, reflect: true })], _button_dec2 = [e7("sl-button")], _a16) {
  constructor() {
    super(...arguments);
    __privateAdd(this, _dataTargetId2, __runInitializers(_init16, 8, this)), __runInitializers(_init16, 11, this);
    __privateAdd(this, _identifier2, __runInitializers(_init16, 12, this)), __runInitializers(_init16, 15, this);
    __privateAdd(this, _getNodeEditor2, __runInitializers(_init16, 16, this, () => {
    })), __runInitializers(_init16, 19, this);
    __privateAdd(this, _name2, __runInitializers(_init16, 20, this, "Button")), __runInitializers(_init16, 23, this);
    __privateAdd(this, _size2, __runInitializers(_init16, 24, this, "small")), __runInitializers(_init16, 27, this);
    __privateAdd(this, _pill2, __runInitializers(_init16, 28, this, false)), __runInitializers(_init16, 31, this);
    __privateAdd(this, _outline2, __runInitializers(_init16, 32, this, false)), __runInitializers(_init16, 35, this);
    __privateAdd(this, _width2, __runInitializers(_init16, 36, this, 50)), __runInitializers(_init16, 39, this);
    __privateAdd(this, _alignment2, __runInitializers(_init16, 40, this, "center")), __runInitializers(_init16, 43, this);
    __privateAdd(this, _variant2, __runInitializers(_init16, 44, this, "default")), __runInitializers(_init16, 47, this);
    __privateAdd(this, _disabled2, __runInitializers(_init16, 48, this, false)), __runInitializers(_init16, 51, this);
    __privateAdd(this, _elementSubmitted, __runInitializers(_init16, 52, this, [])), __runInitializers(_init16, 55, this);
    __privateAdd(this, _submitElements, __runInitializers(_init16, 56, this, [])), __runInitializers(_init16, 59, this);
    __privateAdd(this, _tabIndex5, __runInitializers(_init16, 60, this, -1)), __runInitializers(_init16, 63, this);
    __privateAdd(this, _button2, __runInitializers(_init16, 64, this)), __runInitializers(_init16, 67, this);
  }
  static get scopedElements() {
    return {
      "sl-button": button_default,
      "sl-select": select_default,
      "sl-option": option_default,
      "sl-range": range_default,
      "sl-icon": icon_default,
      "sl-checkbox": checkbox_default,
      "sl-input": input_default,
      "sl-color-picker": color_picker_default,
      "sl-divider": divider_default,
      "sl-button-group": button_group_default
    };
  }
  static get styles() {
    return i`
      :host(.highlighted) {
        border: 1px dashed #38bdf8;
        -webkit-box-shadow: 0 4px 30px 4px #c0c0c0;
        box-shadow: 0 4px 30px 4px #c0c0c0;
      }

      :host(:not([contenteditable="true"]):not([contenteditable=""]))
        .author-only {
        display: none;
      }

      :host([contenteditable="true"]) .author-only,
      :host([contenteditable=""]) .author-only {
        display: flex;
        flex-direction: column;
        box-sizing: border-box;
        padding-left: 10px;
        padding-bottom: 10px;
        gap: 12px;
      }

      .author-only .item {
        display: flex;
        flex-direction: column;
        gap: 7px;
        padding-bottom: 10px;
      }

      .author-only p {
        margin: 0px;
        font-weight: 500;
        font-size: 15px;
        box-sizing: border-box;

        /* border-bottom: 1.5px solid #52525b; */
        color: #52525b;
      }

      .container {
        display: flex;
        width: 100%;
      }

      .controls p {
        padding: 0px;
        margin: 0px;
      }

      sl-button.active::part(base) {
        background-color: #efefef; /* example color for active state */
      }
    `;
  }
  firstUpdated() {
    this.shadowRoot.querySelector("#sizeSelect").value = this.size;
    this.shadowRoot.querySelector("#pillCheckbox").checked = this.pill;
    this.shadowRoot.querySelector("#outlineCheckbox").checked = this.outline;
    this.shadowRoot.querySelector("#widthRange").value = this.width;
    this.shadowRoot.querySelector("#variantSelect").value = this.variant;
    this.addEventListener("mouseover", () => {
      const parsed = this.parseConnectionIdentifier(this.identifier);
      const event = new CustomEvent("hoverButton", {
        detail: {
          outputNodeId: parsed.outputNodeId,
          inputNodeId: parsed.inputNodeId,
          outputClass: parsed.outputClass,
          inputClass: "input_1",
          highlightButton: false
        },
        bubbles: true,
        // Allows the event to bubble up through the DOM
        composed: true
        // Allows the event to pass through shadow DOM boundaries
      });
      this.dispatchEvent(event);
    });
    this.addEventListener("mouseleave", () => {
      const parsed = this.parseConnectionIdentifier(this.identifier);
      const event = new CustomEvent("leaveButton", {
        detail: {
          outputNodeId: parsed.outputNodeId,
          inputNodeId: parsed.inputNodeId,
          outputClass: parsed.outputClass,
          inputClass: "input_1",
          highlightButton: false
        },
        bubbles: true,
        // Allows the event to bubble up through the DOM
        composed: true
        // Allows the event to pass through shadow DOM boundaries
      });
      this.dispatchEvent(event);
    });
  }
  handleSizeChange(e10) {
    this.size = e10.target.value;
  }
  handlePillChange(e10) {
    this.pill = e10.target.checked;
  }
  handleOutlineChange(e10) {
    this.outline = e10.target.checked;
  }
  handleWidthChange(e10) {
    this.width = e10.target.value;
  }
  handleVariantChange(e10) {
    this.variant = e10.target.value;
  }
  handleAlignmentChange(alignment) {
    this.alignment = alignment;
  }
  render() {
    return ke`
      <div class="container" style="justify-content: ${this.alignment};">
        <sl-button
          size=${this.size}
          style="
            width: ${this.width}%;
            pointer-events: ${this.isContentEditable ? "none" : "auto"}
          "
          variant=${this.variant}
          ?pill=${this.pill}
          ?outline=${this.outline}
          ?disabled=${this.disabled}
        >
          <p>${this.name}</p>
        </sl-button>

        <div part="options" class="author-only">
          <div class="item">
            <p>Title</p>
            <sl-input
              size="small"
              .value=${this.name}
              @input=${(e10) => this.name = e10.target.value}
            ></sl-input>
          </div>
          <div class="item">
            <p>Size</p>
            <sl-select
              size="small"
              id="sizeSelect"
              @sl-change=${this.handleSizeChange}
            >
              <sl-option value="small">Small</sl-option>
              <sl-option value="medium">Medium</sl-option>
              <sl-option value="large">Large</sl-option>
            </sl-select>
          </div>
          <div class="item">
            <p>Variant</p>
            <sl-select
              size="small"
              id="variantSelect"
              @sl-change=${this.handleVariantChange}
            >
              <sl-option value="default">Default</sl-option>
              <sl-option value="text">Text</sl-option>
              <sl-option value="primary">Primary</sl-option>
              <sl-option value="success">Success</sl-option>
              <sl-option value="neutral">Neutral</sl-option>
              <sl-option value="warning">Warning</sl-option>
              <sl-option value="danger">Danger</sl-option>
            </sl-select>
          </div>
          <div
            style="display: flex; gap: 5px; align-items: center; justify-content: flex-start;"
          >
            <p style="margin-right: auto;">Pill</p>
            <sl-checkbox id="pillCheckbox" @sl-change=${this.handlePillChange}>
            </sl-checkbox>
          </div>
          <div
            style="display: flex; gap: 5px; align-items: center; justify-content: flex-start;"
          >
            <p style="margin-right: auto;">Outline</p>
            <sl-checkbox
              id="outlineCheckbox"
              @sl-change=${this.handleOutlineChange}
            >
            </sl-checkbox>
          </div>
          <div class="item">
            <div
              style="display: flex; gap: 5px; align-items: center; justify-content: flex-start; padding: 0px; margin: 0px;"
            >
              <p style="margin-right: auto;">Width</p>
              <p style="font-weight: 300;">${this.width}%</p>
            </div>
            <sl-range
              size="small"
              id="widthRange"
              min="10"
              max="100"
              tooltip="none"
              value=${this.width}
              @input=${this.handleWidthChange}
              style="--thumb-size: 17px;"
            ></sl-range>
          </div>
          <div
            style="display: flex; gap: 5px; align-items: center; justify-content: flex-start; padding: 0px; margin: 0px; flex-direction: column;"
          >
            <p style="margin-right: auto;">Alignment</p>
            <sl-button-group style="width: 100%">
              <sl-button
                class=${this.alignment === "flex-start" ? "active" : ""}
                @click=${() => this.handleAlignmentChange("flex-start")}
              >
                <sl-icon src=${align_left_default}></sl-icon>
              </sl-button>
              <sl-button
                class=${this.alignment === "center" ? "active" : ""}
                @click=${() => this.handleAlignmentChange("center")}
              >
                <sl-icon src=${align_center_default}></sl-icon>
              </sl-button>
              <sl-button
                class=${this.alignment === "flex-end" ? "active" : ""}
                @click=${() => this.handleAlignmentChange("flex-end")}
              >
                <sl-icon src=${align_right_default}></sl-icon>
              </sl-button>
            </sl-button-group>
          </div>
        </div>
      </div>
    `;
  }
  /*
  
    */
  parseConnectionIdentifier(identifier) {
    const parts = identifier.split("-");
    const parsed = {
      outputNodeId: parseInt(parts[0]),
      outputClass: parts[1],
      inputNodeId: parseInt(parts[2]),
      inputClass: parts[3]
    };
    return parsed;
  }
};
_init16 = __decoratorStart(_a16);
_dataTargetId2 = new WeakMap();
_identifier2 = new WeakMap();
_getNodeEditor2 = new WeakMap();
_name2 = new WeakMap();
_size2 = new WeakMap();
_pill2 = new WeakMap();
_outline2 = new WeakMap();
_width2 = new WeakMap();
_alignment2 = new WeakMap();
_variant2 = new WeakMap();
_disabled2 = new WeakMap();
_elementSubmitted = new WeakMap();
_submitElements = new WeakMap();
_tabIndex5 = new WeakMap();
_button2 = new WeakMap();
__decorateElement(_init16, 4, "dataTargetId", _dataTargetId_dec2, WebWriterGamebookBranchButton, _dataTargetId2);
__decorateElement(_init16, 4, "identifier", _identifier_dec2, WebWriterGamebookBranchButton, _identifier2);
__decorateElement(_init16, 4, "getNodeEditor", _getNodeEditor_dec2, WebWriterGamebookBranchButton, _getNodeEditor2);
__decorateElement(_init16, 4, "name", _name_dec2, WebWriterGamebookBranchButton, _name2);
__decorateElement(_init16, 4, "size", _size_dec2, WebWriterGamebookBranchButton, _size2);
__decorateElement(_init16, 4, "pill", _pill_dec2, WebWriterGamebookBranchButton, _pill2);
__decorateElement(_init16, 4, "outline", _outline_dec2, WebWriterGamebookBranchButton, _outline2);
__decorateElement(_init16, 4, "width", _width_dec2, WebWriterGamebookBranchButton, _width2);
__decorateElement(_init16, 4, "alignment", _alignment_dec2, WebWriterGamebookBranchButton, _alignment2);
__decorateElement(_init16, 4, "variant", _variant_dec2, WebWriterGamebookBranchButton, _variant2);
__decorateElement(_init16, 4, "disabled", _disabled_dec2, WebWriterGamebookBranchButton, _disabled2);
__decorateElement(_init16, 4, "elementSubmitted", _elementSubmitted_dec, WebWriterGamebookBranchButton, _elementSubmitted);
__decorateElement(_init16, 4, "submitElements", _submitElements_dec, WebWriterGamebookBranchButton, _submitElements);
__decorateElement(_init16, 4, "tabIndex", _tabIndex_dec5, WebWriterGamebookBranchButton, _tabIndex5);
__decorateElement(_init16, 4, "button", _button_dec2, WebWriterGamebookBranchButton, _button2);
WebWriterGamebookBranchButton = __decorateElement(_init16, 0, "WebWriterGamebookBranchButton", _WebWriterGamebookBranchButton_decorators, WebWriterGamebookBranchButton);
__runInitializers(_init16, 1, WebWriterGamebookBranchButton);

// src/components/gamebook/gamebook-viewer/webwriter-gamebook-viewer.ts
var _gamebookContainers_dec, _containerWithError_dec, _gamebookHasError_dec, _startPage_dec, _pageTitle_dec4, _gamebookTitle_dec, _currentContainerId_dec, _a17, _WebWriterGamebookViewer_decorators, _init17, _currentContainerId, _gamebookTitle, _pageTitle4, _startPage, _gamebookHasError, _containerWithError, _gamebookContainers;
_WebWriterGamebookViewer_decorators = [t4("webwriter-gamebook-viewer")];
var WebWriterGamebookViewer = class extends (_a17 = LitElementWw, _currentContainerId_dec = [r5()], _gamebookTitle_dec = [n6({ type: String })], _pageTitle_dec4 = [n6({ type: String })], _startPage_dec = [n6({ type: Number })], _gamebookHasError_dec = [n6({ type: Boolean })], _containerWithError_dec = [n6({ type: String })], _gamebookContainers_dec = [o5({
  flatten: true,
  selector: "webwriter-gamebook-page, webwriter-gamebook-popup, webwriter-gamebook-branch"
})], _a17) {
  constructor() {
    super(...arguments);
    __privateAdd(this, _currentContainerId, __runInitializers(_init17, 8, this)), __runInitializers(_init17, 11, this);
    __privateAdd(this, _gamebookTitle, __runInitializers(_init17, 12, this)), __runInitializers(_init17, 15, this);
    __privateAdd(this, _pageTitle4, __runInitializers(_init17, 16, this)), __runInitializers(_init17, 19, this);
    __privateAdd(this, _startPage, __runInitializers(_init17, 20, this)), __runInitializers(_init17, 23, this);
    __privateAdd(this, _gamebookHasError, __runInitializers(_init17, 24, this)), __runInitializers(_init17, 27, this);
    __privateAdd(this, _containerWithError, __runInitializers(_init17, 28, this)), __runInitializers(_init17, 31, this);
    __privateAdd(this, _gamebookContainers, __runInitializers(_init17, 32, this)), __runInitializers(_init17, 35, this);
  }
  //registering custom elements used in the widget
  static get scopedElements() {
    return {
      "sl-button": button_default,
      "sl-textarea": textarea_default,
      "sl-divider": divider_default,
      "sl-icon-button": icon_button_default,
      "sl-dropdown": dropdown_default,
      "sl-menu": menu_default,
      "sl-menu-item": menu_item_default,
      "sl-select": select_default,
      "sl-option": option_default,
      "sl-alert": alert_default,
      "sl-icon": icon_default,
      "webwriter-gamebook-button": WebWriterGamebookButton
    };
  }
  /*
  
  
    */
  firstUpdated(_changedProperties) {
    const slot = this.shadowRoot.querySelector("slot");
    if (slot) {
      slot.addEventListener("slotchange", () => this._handleSlotChange());
    }
    this.addEventListener("submit", this._handleSubmit.bind(this));
    this.gamebookHasError = this._checkForErrors();
  }
  /*
  
  
     */
  _handleSlotChange() {
    this.currentContainerId = this._resetGamebookToOrigin();
    this._initializeButtons(this.currentContainerId);
  }
  /*
  
    TODO: after Thesis - Handle Reset of Quiz and Tasks
     */
  _handleSubmit(event) {
    event.preventDefault();
    const currentContainer = this.gamebookContainers.find((container) => {
      return container.drawflowNodeId === this.currentContainerId;
    });
    const containersSlot = currentContainer.shadowRoot.querySelector("slot");
    const assignedElements = containersSlot.assignedElements();
    const smartBranchButtons = assignedElements.filter((element) => {
      return element instanceof WebWriterGamebookBranchButton;
    });
    smartBranchButtons.forEach((smartBranchButton) => {
      const branchContainer = this.gamebookContainers.find((container) => {
        return container.drawflowNodeId === smartBranchButton.dataTargetId;
      });
      let submitElements = smartBranchButton.submitElements;
      let submitterIndex = -1;
      if (event.target.parentElement.tagName.toLowerCase() == "webwriter-quiz") {
        submitterIndex = submitElements.indexOf(
          event.target.parentElement.id
        );
      } else {
        submitterIndex = submitElements.indexOf(
          event.target.id
        );
      }
      if (submitterIndex !== -1) {
        smartBranchButton.elementSubmitted[submitterIndex] = true;
      }
      if (smartBranchButton.elementSubmitted.every(
        (element) => element === true
      ) && this._getTargetFromRules(branchContainer) !== void 0) {
        smartBranchButton.disabled = false;
      }
    });
    this.requestUpdate();
  }
  /*
  
  
    */
  render() {
    return ke`
      <div class="gamebook">
        <div class="titlebar">
          <div class="gamebookTitle">${this.gamebookTitle}</div>
          <div class="pageTitle">${this.pageTitle}</div>
        </div>
        <div class="surrounding">
          <div class="page" id="pageViewer">
            <slot></slot>
          </div>
        </div>

        <div
          class="overlay"
          style="visibility: ${this.gamebookHasError ? "visible" : "hidden"}"
        >
          <sl-alert variant="danger" open>
            <sl-icon
              slot="icon"
              src=${alert_octagon_default}
              style="font-size: 28px"
            ></sl-icon>
            <strong>Gamebook Error</strong><br />
            The branching rule set in node
            <em>${this.containerWithError}</em> is incomplete.
          </sl-alert>
        </div>
      </div>
    `;
  }
  /*
  
    */
  _navigateTo(targetId) {
    let containerFound = false;
    this.gamebookContainers.forEach((container) => {
      if (container.drawflowNodeId == targetId) {
        containerFound = true;
        if (container instanceof WebWriterGamebookPage) {
          this._navigateToPage(targetId);
          this._initializeButtons(targetId);
          const pageViewer = this.shadowRoot.getElementById("pageViewer");
          if (pageViewer) {
            pageViewer.scrollTop = 0;
            pageViewer.style.overflowY = "auto";
          }
        } else if (container instanceof WebWriterGamebookPopup) {
          this._showPopupContainerDialog(targetId);
          this._initializeButtons(targetId);
          const pageViewer = this.shadowRoot.getElementById("pageViewer");
          if (pageViewer) {
            pageViewer.scrollTop = 0;
            pageViewer.style.overflowY = "hidden";
          }
        } else if (container instanceof WebWriterGamebookBranch) {
          const nextId = this._getTargetFromRules(container);
          this._navigateTo(Number(nextId));
        }
      }
    });
    if (!containerFound) {
      console.error(`No container found for targetId: ${targetId}`);
    }
  }
  /*
  
  
    */
  _navigateToPage(pageId) {
    this.gamebookContainers.forEach((container) => {
      if (container.drawflowNodeId == pageId) {
        container.show();
        this.pageTitle = container.pageTitle;
      } else {
        if (container instanceof WebWriterGamebookPopup) {
          container.hideDialog();
        } else {
          container.hide();
        }
      }
    });
    this.currentContainerId = pageId;
  }
  /*
  
  
    */
  _showPopupContainerDialog(popupId) {
    this.gamebookContainers.forEach((container) => {
      if (container.drawflowNodeId == popupId) {
        container.showDialog();
        const previousContainerId = this.currentContainerId;
        container.addEventListener("sl-request-close", (event) => {
          this._initializeButtons(previousContainerId);
          this.currentContainerId = previousContainerId;
          const pageViewer = this.shadowRoot.getElementById("pageViewer");
          if (pageViewer) {
            pageViewer.scrollTop = 0;
            pageViewer.style.overflowY = "auto";
          }
        });
      } else if (container.drawflowNodeId != popupId) {
        if (container instanceof WebWriterGamebookPopup) {
          container.hideDialog();
          container.hide();
        }
      }
    });
    this.currentContainerId = popupId;
  }
  /*
  
  
    */
  _getTargetFromRules(branchContainer) {
    const currentContainer = this.gamebookContainers.find((container) => {
      return container.drawflowNodeId === this.currentContainerId;
    });
    if (currentContainer) {
      const containersSlot = currentContainer.shadowRoot.querySelector("slot");
      const assignedElements = containersSlot.assignedElements();
      for (const rule of branchContainer.rules) {
        if (rule.target !== "") {
          const element = assignedElements.find((element2) => {
            return element2.id === rule.elementId;
          });
          const smartBranchButton = assignedElements.find((element2) => {
            return element2 instanceof WebWriterGamebookBranchButton;
          });
          let submitElements = smartBranchButton.submitElements;
          if (element) {
            if (element.tagName.toLowerCase() == "webwriter-quiz") {
              const submitterIndex = submitElements.indexOf(element.id);
              if (smartBranchButton.elementSubmitted[submitterIndex] == true) {
                const quiz = element;
                let relevantTasks = quiz.querySelectorAll("webwriter-task");
                relevantTasks = [...relevantTasks].filter((element2) => {
                  if (element2.tagName.toLowerCase() == "webwriter-task") {
                    if (rule.quizTasks.includes(element2.id)) {
                      return element2;
                    }
                  }
                });
                let amountFalseTasks = 0;
                relevantTasks.forEach((task) => {
                  if (task.answer.tagName.toLowerCase() == "webwriter-choice") {
                    const children = task.answer.children;
                    const taskHasWrongChoiceItem = [...children].some(
                      (element2) => {
                        if (element2.active != element2.valid) {
                          return true;
                        }
                      }
                    );
                    if (taskHasWrongChoiceItem) {
                      amountFalseTasks++;
                    }
                  } else if (task.answer.tagName.toLowerCase() == "webwriter-order") {
                    const children = task.answer.children;
                    const taskHasWrongOrder = [...children].some((element2) => {
                      if (element2.validOrder != element2.elementIndex) {
                        return true;
                      }
                    });
                    if (taskHasWrongOrder) {
                      amountFalseTasks++;
                    }
                  } else if (task.answer.tagName.toLowerCase() == "webwriter-text") {
                    if (task.answer.solution !== task.answer.value) {
                      amountFalseTasks++;
                    }
                  } else if (task.answer.tagName.toLowerCase() == "webwriter-mark") {
                    let userHighlightMatches = false;
                    for (const solution_highlight of task.answer.solution) {
                      userHighlightMatches = task.answer.value.some(
                        (user_highlight) => {
                          if (solution_highlight.startOffset == user_highlight.startOffset && solution_highlight.endOffset == user_highlight.endOffset) {
                            return true;
                          }
                        }
                      );
                      if (!userHighlightMatches) {
                        amountFalseTasks++;
                        break;
                      }
                    }
                  }
                });
                let percentageCorrect = (relevantTasks.length - amountFalseTasks) / relevantTasks.length;
                let match = Number(rule.match) / 100;
                if (rule.condition.toLowerCase() == "correct") {
                  if (percentageCorrect >= match) {
                    return Number(rule.target);
                  }
                } else if (rule.condition.toLowerCase() == "incorrect") {
                  if (1 - percentageCorrect >= match) {
                    return Number(rule.target);
                  }
                }
              }
            } else if (element.tagName.toLowerCase() == "webwriter-task") {
              if (element.answer.tagName.toLowerCase() == "webwriter-choice") {
                const children = element.answer.children;
                const choiceIsWrong = [...children].some((element2) => {
                  if (element2.active != element2.valid) {
                    return true;
                  }
                });
                if (rule.condition.toLowerCase() == "correct" && !choiceIsWrong) {
                  return Number(rule.target);
                } else if (rule.condition.toLowerCase() == "incorrect" && choiceIsWrong) {
                  return Number(rule.target);
                }
              } else if (element.answer.tagName.toLowerCase() == "webwriter-order") {
                const children = element.answer.children;
                const orderIsWrong = [...children].some((element2) => {
                  if (element2.validOrder != element2.elementIndex) {
                    return true;
                  }
                });
                if (rule.condition.toLowerCase() == "correct" && !orderIsWrong) {
                  return Number(rule.target);
                } else if (rule.condition.toLowerCase() == "incorrect" && orderIsWrong) {
                  return Number(rule.target);
                }
              } else if (element.answer.tagName.toLowerCase() == "webwriter-text") {
                const textIsWrong = element.answer.solution !== element.answer.value;
                if (rule.condition.toLowerCase() == "correct" && !textIsWrong) {
                  return Number(rule.target);
                } else if (rule.condition.toLowerCase() == "incorrect" && textIsWrong) {
                  return Number(rule.target);
                }
              } else if (element.answer.tagName.toLowerCase() == "webwriter-mark") {
                let userHighlightMatches = false;
                for (const solution_highlight of element.answer.solution) {
                  userHighlightMatches = element.answer.value.some(
                    (user_highlight) => {
                      if (solution_highlight.startOffset == user_highlight.startOffset && solution_highlight.endOffset == user_highlight.endOffset) {
                        return true;
                      }
                    }
                  );
                  if (rule.condition.toLowerCase() == "incorrect" && !userHighlightMatches) {
                    return Number(rule.target);
                  }
                }
                if (rule.condition.toLowerCase() == "correct" && userHighlightMatches) {
                  return Number(rule.target);
                }
              }
            }
          }
        }
      }
    }
    return Number(branchContainer.elseRule?.target);
  }
  /*
  
  
    */
  _resetGamebookToOrigin() {
    const originPageContainer = this.gamebookContainers.find(
      (container) => container.getAttribute("originPage") == 1
    );
    this.pageTitle = originPageContainer.pageTitle;
    this.gamebookContainers.forEach((container) => {
      if (container.drawflowNodeId == originPageContainer.drawflowNodeId) {
        container.show();
      } else {
        container.hide();
      }
    });
    return originPageContainer.drawflowNodeId;
  }
  /*
  
  
    */
  _initializeButtons(containerId) {
    const container = this.gamebookContainers.find(
      (container2) => container2.getAttribute("drawflowNodeId") == containerId
    );
    container.buttons.forEach((button) => {
      const targetId = parseInt(button.getAttribute("dataTargetId"), 10);
      button.addEventListener("click", () => this._navigateTo(targetId));
      button.classList.remove("highlighted");
      if (button instanceof WebWriterGamebookBranchButton) {
        if (button.submitElements.length === 0 && button.elementSubmitted.length === 0) {
          let submitElements = [];
          let elementSubmitted = [];
          const containersSlot = container.shadowRoot.querySelector("slot");
          const assignedElements = containersSlot.assignedElements();
          const branchContainer = this.gamebookContainers.find((container2) => {
            return container2.drawflowNodeId === targetId;
          });
          branchContainer.rules.forEach((rule) => {
            const element = assignedElements.find((element2) => {
              return element2.id === rule.elementId;
            });
            if (!submitElements.includes(element.id)) {
              if (element.tagName.toLowerCase() == "webwriter-quiz" || element.tagName.toLowerCase() == "webwriter-task") {
                submitElements = [...submitElements, element.id];
                elementSubmitted = [...elementSubmitted, false];
              }
            }
          });
          button.submitElements = submitElements;
          button.elementSubmitted = elementSubmitted;
          if (submitElements.length !== 0) {
            button.disabled = true;
          } else if (branchContainer.elseRule === void 0) {
            button.disabled = true;
          }
        }
      }
    });
    this.requestUpdate();
  }
  /*
  
  
    */
  _checkForErrors() {
    for (const container of this.gamebookContainers) {
      if (container instanceof WebWriterGamebookBranch) {
        if (container.elseRule !== void 0 && container.elseRule.target == "") {
          this.containerWithError = container.pageTitle;
          return true;
        }
      }
    }
    return false;
  }
};
_init17 = __decoratorStart(_a17);
_currentContainerId = new WeakMap();
_gamebookTitle = new WeakMap();
_pageTitle4 = new WeakMap();
_startPage = new WeakMap();
_gamebookHasError = new WeakMap();
_containerWithError = new WeakMap();
_gamebookContainers = new WeakMap();
__decorateElement(_init17, 4, "currentContainerId", _currentContainerId_dec, WebWriterGamebookViewer, _currentContainerId);
__decorateElement(_init17, 4, "gamebookTitle", _gamebookTitle_dec, WebWriterGamebookViewer, _gamebookTitle);
__decorateElement(_init17, 4, "pageTitle", _pageTitle_dec4, WebWriterGamebookViewer, _pageTitle4);
__decorateElement(_init17, 4, "startPage", _startPage_dec, WebWriterGamebookViewer, _startPage);
__decorateElement(_init17, 4, "gamebookHasError", _gamebookHasError_dec, WebWriterGamebookViewer, _gamebookHasError);
__decorateElement(_init17, 4, "containerWithError", _containerWithError_dec, WebWriterGamebookViewer, _containerWithError);
__decorateElement(_init17, 4, "gamebookContainers", _gamebookContainers_dec, WebWriterGamebookViewer, _gamebookContainers);
WebWriterGamebookViewer = __decorateElement(_init17, 0, "WebWriterGamebookViewer", _WebWriterGamebookViewer_decorators, WebWriterGamebookViewer);
//import CSS
__publicField(WebWriterGamebookViewer, "styles", [webwriter_gamebook_viewer_styles_default]);
__runInitializers(_init17, 1, WebWriterGamebookViewer);

// src/utils/gamebook-container-manager.ts
var _editorStore_dec8, _slot_dec, _gamebookContainers_dec2, _a18, _GamebookContainerManager_decorators, _init18, _gamebookContainers2, _slot, _editorStore8;
_GamebookContainerManager_decorators = [t4("gamebook-container-manager")];
var GamebookContainerManager = class extends (_a18 = LitElementWw, _gamebookContainers_dec2 = [o5({
  flatten: true,
  selector: "webwriter-gamebook-page, webwriter-gamebook-popup, webwriter-gamebook-branch"
})], _slot_dec = [e7("slot")], _editorStore_dec8 = [c4({ context: editorState, subscribe: true }), n6({ type: Object, attribute: true, reflect: false })], _a18) {
  /* 
  
  
  */
  constructor() {
    super();
    __privateAdd(this, _gamebookContainers2, __runInitializers(_init18, 8, this)), __runInitializers(_init18, 11, this);
    __privateAdd(this, _slot, __runInitializers(_init18, 12, this)), __runInitializers(_init18, 15, this);
    __privateAdd(this, _editorStore8, __runInitializers(_init18, 16, this, new GamebookEditorState("Default"))), __runInitializers(_init18, 19, this);
  }
  static get scopedElements() {
    return {
      "webwriter-gamebook-page": WebWriterGamebookPage,
      "webwriter-gamebook-popup": WebWriterGamebookPopup,
      "webwriter-gamebook-branch": WebWriterGamebookBranch
    };
  }
  /* 
  
  
  */
  firstUpdated(_changedProperties) {
    const event = new CustomEvent("managerInitialized", {
      bubbles: true,
      composed: true
    });
    this.dispatchEvent(event);
    if (this.editorStore.selectedContainer !== void 0) {
      const value = this.editorStore.selectedContainer.attributes.find(
        (attr) => attr.name === "drawflownodeid"
      ).value;
      if (value) {
        const event2 = new CustomEvent("containerSelectFirstUpdate", {
          detail: { id: value },
          bubbles: true,
          composed: true
        });
        this.dispatchEvent(event2);
      } else {
        const event2 = new CustomEvent("containerError", {
          detail: { id: value },
          bubbles: true,
          composed: true
        });
        this.dispatchEvent(event2);
      }
    }
  }
  /* 
  
  
  */
  render() {
    return ke` <slot></slot> `;
  }
  /* 
  
  
  */
  _deleteGamebookContainersById(drawflowNodeId) {
    this.gamebookContainers.forEach((container) => {
      if (container.drawflowNodeId == drawflowNodeId) {
        container.remove();
      }
    });
  }
  /*
  
    */
  _notifyContainerGotDeleted(drawflowNodeId) {
    const event = new CustomEvent("containerDeleted", {
      detail: { id: drawflowNodeId },
      bubbles: true,
      composed: true
    });
    this.dispatchEvent(event);
  }
  /* 
  
  
  */
  _deleteAllGamebookContainers() {
    this.gamebookContainers.forEach((container) => {
      container.remove();
    });
  }
  /*
  
  
    */
  _getContainerByDrawflowNodeId(id3) {
    const container = this.gamebookContainers.find(
      (container2) => container2.drawflowNodeId === id3
    );
    if (!container) {
      console.error(`No container found with drawflowNodeId: ${id3}`);
    }
    return container;
  }
  /*
  
    */
  _renameContainer(id3, title) {
    const container = this.gamebookContainers.find(
      (container2) => container2.getAttribute("drawflowNodeId") == id3
    );
    container.pageTitle = title;
  }
  /*
  
  
    */
  _showGamebookContainerById(nodeId) {
    let isContainerShown = false;
    this.gamebookContainers.forEach((container) => {
      if (container.drawflowNodeId == nodeId) {
        container.show();
        isContainerShown = true;
      } else {
        container.hide();
      }
    });
    if (!isContainerShown) {
      console.error(`No container found with drawflowNodeId: ${nodeId}`);
    }
  }
  /*
  
  
    */
  _hideAllGamebookContainers() {
    this.gamebookContainers.forEach((container) => {
      container.hide();
    });
  }
  /*
  
  
    */
  addConnectionButtonToContainer(outputNode, inputNode, output_class, input_class) {
    const container = this.gamebookContainers.find(
      (container2) => container2.getAttribute("drawflowNodeId") == outputNode.id
    );
    const connButton = document.createElement(
      "webwriter-gamebook-button"
    );
    connButton.setAttribute("name", inputNode.data.title);
    connButton.setAttribute("dataTargetId", inputNode.id.toString());
    connButton.setAttribute(
      "identifier",
      `${outputNode.id}-${output_class}-${inputNode.id}-${input_class}`
    );
    container.appendChild(connButton);
  }
  /*
  
  
    */
  addSmartBranchButtonToContainer(outputNode, inputNode, output_class, input_class) {
    const container = this.gamebookContainers.find(
      (container2) => container2.getAttribute("drawflowNodeId") == outputNode.id
    );
    const branchButton = document.createElement(
      "webwriter-gamebook-branch-button"
    );
    branchButton.setAttribute("name", inputNode.data.title);
    branchButton.setAttribute("dataTargetId", inputNode.id.toString());
    branchButton.setAttribute(
      "identifier",
      `${outputNode.id}-${output_class}-${inputNode.id}-${input_class}`
    );
    container.appendChild(branchButton);
    container.branchesOff = inputNode.id;
    const branchContainer = this.gamebookContainers.find(
      (container2) => container2.getAttribute("drawflowNodeId") == inputNode.id
    );
    branchContainer.incomingContainerId = outputNode.id;
  }
  /*
  
  
    */
  removeButtonFromContainer(outputId, inputId, outputClass, inputClass) {
    const container = this.gamebookContainers.find(
      (container2) => container2.getAttribute("drawflowNodeId") == outputId
    );
    const button = Array.from(
      container.buttons
    ).find((button2) => {
      return button2.identifier === `${outputId}-${outputClass}-${inputId}-${inputClass}`;
    });
    if (button) {
      button.setAttribute("identifier", "x");
      button.remove();
    }
    if (button instanceof WebWriterGamebookBranchButton) {
      container.branchesOff = -1;
      const branchContainer = this.gamebookContainers.find(
        (container2) => container2.getAttribute("drawflowNodeId") == inputId
      );
      branchContainer.incomingContainerId = -1;
      branchContainer.clearRules();
    }
  }
  /*
  
  
    */
  updateButtonIdsAfterOutputRemove(containerId, removed_output_class) {
    const container = this.gamebookContainers.find(
      (container2) => container2.getAttribute("drawflowNodeId") == containerId
    );
    const removedOutputClassNumber = parseInt(
      removed_output_class.split("_")[1],
      10
    );
    if (container.buttons) {
      container.buttons.forEach((button) => {
        const [output_id, output_class, input_id] = button.identifier.split("-");
        const buttonOutputClassNumber = parseInt(
          output_class.split("_")[1],
          10
        );
        if (buttonOutputClassNumber > removedOutputClassNumber) {
          const newIdentifier = `${output_id}-output_${buttonOutputClassNumber - 1}-${input_id}-input_1`;
          button.setAttribute("identifier", newIdentifier);
        }
      });
    }
  }
  /*
  
    */
  highlightButtonInContainer(containerId, identifier) {
    const container = this.gamebookContainers.find(
      (container2) => container2.getAttribute("drawflowNodeId") == containerId
    );
    if (container instanceof WebWriterGamebookPage || container instanceof WebWriterGamebookPopup) {
      const connButton = container.buttons.find(
        (button) => button.identifier === identifier
      );
      if (connButton) {
        if (!connButton.classList.contains("ww-selected")) {
          connButton.classList.add("highlighted");
        }
      }
    }
  }
  /*
  
    */
  unhighlightButtonInContainer(containerId, identifier) {
    const container = this.gamebookContainers.find(
      (container2) => container2.getAttribute("drawflowNodeId") == containerId
    );
    if (container instanceof WebWriterGamebookPage || container instanceof WebWriterGamebookPopup) {
      const connButton = container.buttons.find(
        (button) => button.identifier === identifier
      );
      if (connButton) {
        connButton.classList.remove("highlighted");
      }
    }
  }
  /*
  
    */
  selectButtonInContainer(containerId, identifier) {
    const container = this.gamebookContainers.find(
      (container2) => container2.getAttribute("drawflowNodeId") == containerId
    );
    const connButton = container.buttons.find(
      (button) => button.identifier === identifier
    );
    if (connButton) {
      connButton.focus();
    }
  }
  /*
  
    */
  createContainerFromNode(node) {
    switch (node.class) {
      case "page":
      case "origin":
        return this._createContainerElement(
          node,
          "webwriter-gamebook-page",
          node.class == "origin" ? "1" : "0"
        );
        break;
      case "popup":
        return this._createContainerElement(node, "webwriter-gamebook-popup");
        break;
      case "branch":
        return this._createContainerElement(node, "webwriter-gamebook-branch");
        break;
    }
  }
  /*
  
    */
  _createContainerElement(node, tagName, originPage) {
    const container = document.createElement(tagName);
    container.setAttribute("drawflowNodeId", node.id.toString());
    container.setAttribute("pageTitle", node.data.title);
    if (originPage) {
      container.setAttribute("originPage", originPage);
    }
    container.hide();
    return container;
  }
  /* 
  
  
  */
  importContainers(template) {
    let containers = template.map(
      (info) => this.createContainerFromImport(info)
    );
    return containers;
  }
  /*
  
  
    */
  createContainerFromImport(info) {
    let element = document.createElement(info.tagName);
    info.attributes.forEach((attr) => {
      element.setAttribute(attr.name, attr.value);
    });
    element.innerHTML = info.innerHTML;
    return element;
  }
  /*
  
  
    */
  searchContainers(value) {
    let matchContainerIds = [];
    const searchValue = value.toLowerCase();
    this.gamebookContainers.forEach((container) => {
      const slotElements = container.querySelectorAll("*");
      slotElements.forEach((element) => {
        if (element.tagName.toLowerCase().includes(searchValue) || element.textContent && element.textContent.toLowerCase().includes(searchValue)) {
          matchContainerIds = [...matchContainerIds, container.drawflowNodeId];
        }
      });
    });
    return matchContainerIds;
  }
  /*
  
  
  */
  updateBranchContainerRuleTarget(output_id, output_class, input_id) {
    const branchContainer = this._getContainerByDrawflowNodeId(output_id);
    branchContainer._updateRuleTarget(output_class, input_id);
  }
  /*
  
  
  */
  removeBranchContainerRuleElements(output_id, element_id, isQuiz) {
    const branchContainer = this._getContainerByDrawflowNodeId(output_id);
    const removeConnectionsFromOutputs = branchContainer.removeElementOfRules(element_id, isQuiz);
    return removeConnectionsFromOutputs;
  }
  /*
  
  
    */
  copyAndPasteContainerContents(pastedNode) {
    const pastedContainer = this.createContainerFromNode(pastedNode);
    const copiedContainer = this._getContainerByDrawflowNodeId(
      this.editorStore.copiedNode.id
    );
    if (copiedContainer.slotContent) {
      copiedContainer.slotContent.forEach((element) => {
        if (element.tagName.toLowerCase() === "webwriter-gamebook-button" || element.tagName.toLowerCase() === "webwriter-gamebook-branch-button") {
          return;
        }
        const newElement = document.createElement(element.tagName);
        [...element.attributes].forEach((attr) => {
          if (attr.name !== "id" && attr.name !== "contenteditable") {
            newElement.setAttribute(attr.name, attr.value);
          }
        });
        newElement.innerHTML = element.innerHTML;
        pastedContainer.appendChild(newElement);
      });
    }
    return pastedContainer;
  }
  /*
  
  
    */
  changeOrigin(newId) {
    const originPageContainer = this.gamebookContainers.find(
      (container) => container.getAttribute("originPage") === "1"
    );
    if (originPageContainer) {
      originPageContainer.originPage = 0;
    }
    const newOriginPageContainer = this._getContainerByDrawflowNodeId(newId);
    newOriginPageContainer.originPage = 1;
  }
};
_init18 = __decoratorStart(_a18);
_gamebookContainers2 = new WeakMap();
_slot = new WeakMap();
_editorStore8 = new WeakMap();
__decorateElement(_init18, 4, "gamebookContainers", _gamebookContainers_dec2, GamebookContainerManager, _gamebookContainers2);
__decorateElement(_init18, 4, "slot", _slot_dec, GamebookContainerManager, _slot);
__decorateElement(_init18, 4, "editorStore", _editorStore_dec8, GamebookContainerManager, _editorStore8);
GamebookContainerManager = __decorateElement(_init18, 0, "GamebookContainerManager", _GamebookContainerManager_decorators, GamebookContainerManager);
__runInitializers(_init18, 1, GamebookContainerManager);

// src/node_modules/@tabler/icons/icons/outline/dots-vertical.svg
var dots_vertical_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-dots-vertical"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M12 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" />%0A  <path d="M12 19m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" />%0A  <path d="M12 5m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/zoom-in.svg
var zoom_in_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-zoom-in"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" />%0A  <path d="M7 10l6 0" />%0A  <path d="M10 7l0 6" />%0A  <path d="M21 21l-6 -6" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/zoom-out.svg
var zoom_out_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-zoom-out"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" />%0A  <path d="M7 10l6 0" />%0A  <path d="M21 21l-6 -6" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/map-pin.svg
var map_pin_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-map-pin"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M9 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0" />%0A  <path d="M17.657 16.657l-4.243 4.243a2 2 0 0 1 -2.827 0l-4.244 -4.243a8 8 0 1 1 11.314 0z" />%0A</svg>';

// src/components/node-editor/node-editor.ts
var import_drawflow = __toESM(require_drawflow_min());

// src/node_modules/drawflow/dist/drawflow.style.js
var style = i`.drawflow,.drawflow .parent-node{position:relative}.parent-drawflow{display:flex;overflow:hidden;touch-action:none;outline:0}.drawflow{width:100%;height:100%;user-select:none;perspective:0}.drawflow .drawflow-node{display:flex;align-items:center;position:absolute;background:#0ff;width:160px;min-height:40px;border-radius:4px;border:2px solid #000;color:#000;z-index:2;padding:15px}.drawflow .drawflow-node.selected{background:red}.drawflow .drawflow-node:hover{cursor:move}.drawflow .drawflow-node .inputs,.drawflow .drawflow-node .outputs{width:0}.drawflow .drawflow-node .drawflow_content_node{width:100%;display:block}.drawflow .drawflow-node .input,.drawflow .drawflow-node .output{position:relative;width:20px;height:20px;background:#fff;border-radius:50%;border:2px solid #000;cursor:crosshair;z-index:1;margin-bottom:5px}.drawflow .drawflow-node .input{left:-27px;top:2px;background:#ff0}.drawflow .drawflow-node .output{right:-3px;top:2px}.drawflow svg{z-index:0;position:absolute;overflow:visible!important}.drawflow .connection{position:absolute;pointer-events:none;aspect-ratio:1/1}.drawflow .connection .main-path{fill:none;stroke-width:5px;stroke:#4682b4;pointer-events:all}.drawflow .connection .main-path:hover{stroke:#1266ab;cursor:pointer}.drawflow .connection .main-path.selected{stroke:#43b993}.drawflow .connection .point{cursor:move;stroke:#000;stroke-width:2;fill:#fff;pointer-events:all}.drawflow .connection .point.selected,.drawflow .connection .point:hover{fill:#1266ab}.drawflow .main-path{fill:none;stroke-width:5px;stroke:#4682b4}.drawflow-delete{position:absolute;display:block;width:30px;height:30px;background:#000;color:#fff;z-index:4;border:2px solid #fff;line-height:30px;font-weight:700;text-align:center;border-radius:50%;font-family:monospace;cursor:pointer}.drawflow>.drawflow-delete{margin-left:-15px;margin-top:15px}.parent-node .drawflow-delete{right:-15px;top:-15px}`;

// src/components/node-editor/drawflow.styles.ts
var drawflow_styles_default = i`
  /* ------- */
  /*  Base Layouting Nodes  */
  /* ------- */

  .smooth-transition {
    transition: transform 0.6s ease !important; /* Adjust duration and easing as needed */
  }

  .smooth-background-transition {
    transition: background-position 0.6s ease; /* Adjust duration and easing as needed */
  }

  .drawflow {
    overflow: visible; /* Ensure container is not clipped */
  }

  .drawflow .drawflow-node.page,
  .drawflow .drawflow-node.origin,
  .drawflow .drawflow-node.popup {
    background: #ffffff;
    border: 1.5px solid #cecece;

    padding: 0px;
    align-items: center;

    box-sizing: border-box;

    border-radius: 12px;

    min-width: 320px;
    min-height: 90px;

    -webkit-box-shadow: 0 2px 20px 2px #d0d0d0;
    box-shadow: 0 2px 20px 2px #d0d0d0;
  }

  .drawflow .drawflow-node.branch {
    background: #ffffff;
    border: 1.5px solid #cecece;

    padding: 0px;
    align-items: center;

    box-sizing: border-box;

    border-radius: 12px;

    min-width: 320px;
    min-height: 90px;

    -webkit-box-shadow: 0 2px 20px 2px #d0d0d0;
    box-shadow: 0 2px 20px 2px #d0d0d0;
  }

  .drawflow-node.page .container,
  .drawflow-node.origin .container,
  .drawflow-node.popup .container,
  .drawflow-node.branch .container {
    display: flex;
    flex-direction: row;
    gap: 20px;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
    padding: 20px;
    box-sizing: border-box;
  }

  .drawflow-node.page .container .pageIcon,
  .drawflow-node.origin .container .pageIcon,
  .drawflow-node.popup .container .pageIcon,
  .drawflow-node.branch .container .pageIcon {
    font-size: 48px;
    color: white;
  }

  .drawflow-node.page .content,
  .drawflow-node.origin .content,
  .drawflow-node.popup .content,
  .drawflow-node.branch .content {
    color: #71717a;
    display: flex;

    flex-direction: column;
    justify-content: center;
    width: 150px;

    gap: 3px;
    height: 60px;
  }

  .drawflow-node.page .content .input-label,
  .drawflow-node.origin .content .input-label,
  .drawflow-node.popup .content .input-label,
  .drawflow-node.branch .content .input-label {
    font-size: 16px;
    color: #a1a1a1; /* gray tone */
    padding: 0px;
    margin: 0px;
  }

  .drawflow-node.page .content #title,
  .drawflow-node.origin .content #title,
  .drawflow-node.popup .content #title,
  .drawflow-node.branch .content #title {
    padding: 0px;
    margin: 0px;

    font-size: 20px;
    color: #3f3f46;
    pointer-events: none;
    text-align: left;
    border: none;
    background-color: transparent;
    max-width: 150px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .drawflow-node.page .container .threeDots,
  .drawflow-node.origin .container .threeDots,
  .drawflow-node.popup .container .threeDots,
  .drawflow-node.branch .container .threeDots {
    font-size: 28px;
  }

  /* ------- */
  /* Specific Nodes icon Div  */
  /* ------- */

  .drawflow-node.branch .container .iconDiv {
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #05ae9e;
    border-radius: 8px;
    min-width: 65px;
    min-height: 65px;
  }

  .drawflow-node.page .container .iconDiv,
  .drawflow-node.origin .container .iconDiv {
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #3077ba;
    border-radius: 8px;
    min-width: 65px;
    min-height: 65px;
  }

  .drawflow-node.popup .container .iconDiv {
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #9762b4;
    border-radius: 8px;
    min-width: 65px;
    min-height: 65px;
  }

  /* ------- */
  /* :hover nodes  */
  /* ------- */

  .drawflow .drawflow-node:hover.branch {
    border: 2px solid #05ae9e;
    -webkit-box-shadow: 0 4px 30px 4px #c0c0c0;
    box-shadow: 0 4px 30px 4px #c0c0c0;
  }

  .drawflow .drawflow-node:hover.page,
  .drawflow .drawflow-node:hover.origin {
    border: 2px solid #3077ba;
    -webkit-box-shadow: 0 4px 30px 4px #c0c0c0;
    box-shadow: 0 4px 30px 4px #c0c0c0;
  }

  .drawflow .drawflow-node:hover.popup {
    border: 2px solid #9762b4;
    -webkit-box-shadow: 0 4px 30px 4px #c0c0c0;
    box-shadow: 0 4px 30px 4px #c0c0c0;
  }

  /* ------- */
  /* highlighted nodes  */
  /* ------- */

  .drawflow-node.branch[highlighted="true"] {
    border: 3px solid #05ae9e;
    -webkit-box-shadow: 0 4px 60px 6px #b0b0b0;
    box-shadow: 0 4px 60px 6px #b0b0b0;
  }

  .drawflow-node.page[highlighted="true"],
  .drawflow-node.origin[highlighted="true"] {
    border: 3px solid #3077ba;
    -webkit-box-shadow: 0 4px 60px 6px #b0b0b0;
    box-shadow: 0 4px 60px 6px #b0b0b0;
  }

  .drawflow-node.popup[highlighted="true"] {
    border: 3px solid #9762b4;
    -webkit-box-shadow: 0 4px 60px 6px #b0b0b0;
    box-shadow: 0 4px 60px 6px #b0b0b0;
  }

  /* ------- */
  /* searched nodes  */
  /* ------- */

  .drawflow-node.branch[searched="true"],
  .drawflow-node.page[searched="true"],
  .drawflow-node.origin[searched="true"],
  .drawflow-node.popup[searched="true"] {
    outline: 3px solid yellow;
    background-color: #ffffe6;
  }

  .drawflow-node.selected.branch[searched="true"],
  .drawflow-node.selected.page[searched="true"],
  .drawflow-node.selected.origin[searched="true"],
  .drawflow-node.selected.popup[searched="true"] {
    outline: 3px solid yellow !important;
  }

  .drawflow-node:hover.branch[searched="true"],
  .drawflow-node:hover.page[searched="true"],
  .drawflow-node:hover.origin[searched="true"],
  .drawflow-node:hover.popup[searched="true"] {
    outline: 3px solid yellow !important;
  }

  /* ------- */
  /* selected nodes  */
  /* ------- */

  .drawflow .drawflow-node.selected.branch {
    background: #f4fffe;
    border: 4px solid #05ae9e;
    color: #058b7f;
    box-sizing: content-box;
    background-color: #f4fffe;
    -webkit-box-shadow: 0 4px 60px 7px #b0b0b0;
    box-shadow: 0 4px 60px 7px #b0b0b0;
  }

  .drawflow .drawflow-node.selected.page,
  .drawflow .drawflow-node.selected.origin {
    background: #f4faff;
    border: 4px solid #3077ba;
    color: #215f98;
    box-sizing: content-box;
    -webkit-box-shadow: 0 4px 60px 7px #b0b0b0;
    box-shadow: 0 4px 60px 7px #b0b0b0;
  }

  .drawflow .drawflow-node.selected.popup {
    background: #fbf4fe;
    border: 4px solid #9762b4;
    color: #9762b4;
    box-sizing: content-box;
    -webkit-box-shadow: 0 4px 60px 7px #b0b0b0;
    box-shadow: 0 4px 60px 7px #b0b0b0;
  }

  /* ------- */
  /* Origin Class Specifics  */
  /* ------- */

  .drawflow-node.origin .badge {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: left;
    gap: 5px;

    color: #50b478;

    box-sizing: border-box;
    padding: 3px 3px;

    height: 25px;
    width: auto;

    padding: 0px;
  }

  .drawflow-node.origin .badge p {
    margin: 0px;
    padding: 0px;
    font-size: 16px;
  }

  .drawflow-node.origin .drawflow-delete {
    display: none;
  }

  /* ---- */
  /*  INPUT AND OUTPUTS */

  .drawflow .drawflow-node .input {
    position: relative; /* Allows positioning of the pseudo-element */
    left: -10px;
    background: white;
    height: 20px;
    width: 20px;
    border: 1px solid #cdcdcd;
    border-radius: 50%; /* Makes it a circle */
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .drawflow .drawflow-node .input::before {
    content: "";
    position: absolute;
    height: 10px; /* Smaller than the outer circle */
    width: 10px;
    border-radius: 50%; /* Make it circular */
    border: 2px solid #cdcdcd;
  }

  /* ---- */

  .drawflow .drawflow-node .output {
    height: 20px;
    width: 20px;
    border: 1px solid #cdcdcd;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .drawflow .drawflow-node .output::before {
    content: "";
    position: absolute;
    background: #dddddd;
    border-color: #d7d7d7;
    height: 10px; /* Smaller than the outer circle */
    width: 10px;
    border-radius: 50%; /* Make it circular */
  }

  .drawflow .drawflow-node .output:hover::before {
    content: "";
    background: #4ea9ff;
  }

  .drawflow .drawflow-node .output:active::before {
    content: "";
    background: #4ea9ff;
  }

  .drawflow .drawflow-node .output {
    right: 10px;
  }

  .drawflow .drawflow-node .output[in-use="true"] {
    pointer-events: none;
  }

  .drawflow .drawflow-node .output[in-use="true"]::before {
    content: "";
    background: #a3a3a3;
    border-color: #d7d7d7;
    pointer-events: none;
  }

  .drawflow .drawflow-node .output[has-error="true"] {
    pointer-events: none;
  }

  .drawflow .drawflow-node .output[has-error="true"]::before {
    border: 1px solid #ff2323 !important;
    background-color: #ff7474 !important;
  }

  .drawflow .drawflow-node .output[target-disabled="true"] {
    pointer-events: none;
  }

  .drawflow .drawflow-node .output[target-disabled="true"]::before {
    pointer-events: none;
    background-image: repeating-linear-gradient(
      45deg,
      #f1f1f1,
      /* Lighter Gray */ #f1f1f1 2px,
      #c9c9c9 2px,
      /* Darker Gray for contrast */ #c9c9c9 4px
    ) !important;
  }

  /* ---- */
  /* INPUT OUTPUT HIGHLIGHTED */
  /* ---- */

  .drawflow .drawflow-node .output[highlighted="true"]::before {
    background: #4ea9ff;
    border: 1px solid #4ea9ff;
  }

  .drawflow .drawflow-node .input[highlighted="true"]::before {
    border: 2px solid #4ea9ff;
    content: ""; /* Always required for pseudo-elements like ::before and ::after */
  }

  /* ---- */
  /* CONNECTIONS */
  /* ---- */

  .drawflow .connection .main-path {
    stroke: #d7d7d7;
    stroke-width: 2px;
  }

  .drawflow .connection .main-path:hover {
    stroke: #4ea9ff;
    stroke-width: 2px;
  }

  .drawflow .connection .main-path.selected {
    stroke: #2d99ff;
    stroke-width: 2px;
    -webkit-box-shadow: 0 4px 60px 7px #b0b0b0;
    box-shadow: 0 4px 60px 7px #b0b0b0;
  }

  .drawflow .connection .point {
    stroke: #000000;
    stroke-width: 2;
    fill: white;
  }

  .drawflow .connection .point.selected,
  .drawflow .connection .point:hover {
    fill: #000000;
  }

  /* ---- */
  /* CONNECTIONS HIGHLIGHTED */
  /* ---- */

  /* .drawflow .connection .main-path.popup-highlighted {
    stroke: #9762b4;
    stroke-width: 3px;
  }

  .drawflow .connection .main-path.page-highlighted,
  .drawflow .connection .main-path.origin-highlighted {
    stroke: #3077ba;
    stroke-width: 3px;
  }

  .drawflow .connection .main-path.branch-highlighted,
  .drawflow .connection .main-path.branch-highlighted {
    stroke: #05ae9e;
    stroke-width: 3px;
  } */

  .drawflow .connection .main-path[highlighted="true"] {
    stroke: #4ea9ff;
    stroke-width: 3px;
  }

  /* ---- */
  /* OTHERS */
  /* ---- */

  /* .drawflow-delete {
  border: 2px solid #b94543;
  background: #ffe9e8;
  color: #b94543;
} 

  /* ------- */
  /* MODAL */
  /* ------- */

  .modal {
    display: none;
    position: fixed;
    z-index: 7;
    left: 0;
    top: 0;
    width: 100vw;
    height: 100vh;
    overflow: auto;
    background-color: rgb(0, 0, 0);
    background-color: rgba(0, 0, 0, 0.7);
  }

  .modal-content {
    position: relative;
    background-color: #fefefe;
    margin: 15% auto; /* 15% from the top and centered */
    padding: 20px;
    border: 1px solid #888;
    width: 400px; /* Could be more or less, depending on screen size */
  }

  /* The Close Button */
  .modal .close {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
  }
`;

// src/components/node-editor/node-editor.styles.ts
var node_editor_styles_default = i`
  :host {
    height: 100%;
    width: 100%;
  }

  :host * {
    box-sizing: border-box;
  }

  #nodeEditor {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    position: relative; /* Ensure position relative for child positioning */
  }

  node-editor-toolbar {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    z-index: 1;
  }

  drawflow-background {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: -1; //Place background behind #drawflowEditorDiv
  }

  #drawflowEditorDiv {
    flex-shrink: 0;
    position: relative;
    width: 100%;
    height: 350px;
  }

  #drawflowEditorDiv ::selection {
    background: transparent;
    color: inherit;
  }

  .zoomControls {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-items: center;

    position: absolute;
    bottom: 10px;
    right: 10px;
    z-index: 0;

    padding: 0px;

    background-color: rgba(255, 255, 255, 0.9);

    box-sizing: border-box;

    border-radius: 8px;
    border: 1px solid #e4e4e7;
  }

  .zoomControls.sl-icon-button::part(base) {
    padding: 0px;
  }

  .exportButton {
    float: right;
    position: absolute;
    bottom: 10px;
    left: 10px;
  }

  .zoomValue {
    box-sizing: border-box;

    opacity: 0;

    float: right;
    position: absolute;
    bottom: 45px;
    right: 20px;
    z-index: 0;

    /* 
    padding-inline: 5px;
    padding-block: 0px;

    border-radius: 4px; */

    /* color: white;
    background: #555555; */

    font-size: 8px;
  }

  .zoomValue.fade-in-out {
    animation: opacityOn 2s normal forwards;
    animation-iteration-count: 1;
    animation-direction: alternate;
  }

  @keyframes opacityOn {
    0% {
      opacity: 0;
    }
    50% {
      opacity: 1;
    }

    100% {
      opacity: 0;
    }
  }

  .dialog {
  }

  sl-dialog::part(base) {
    position: absolute;
  }

  sl-dialog::part(overlay) {
    position: absolute;
  }
`;

// src/components/node-editor/toolbar/node-editor-toolbar.styles.ts
var node_editor_toolbar_styles_default = i`
  .controls {
    display: flex;
    flex-direction: row;
    justify-content: flex-end;
    align-items: center; /* Center items vertically */

    width: 100%;

    box-sizing: border-box;
    border-bottom: 1px solid #e4e4e4;

    padding-left: 15px;
    padding-right: 15px;
    padding-top: 10px;
    padding-bottom: 10px;

    font-size: 20px;
    font-weight: bold;
    user-select: none;

    background-color: rgba(255, 255, 255, 0.95);
  }

  .controls .first-item {
    display: flex;
    flex-direction: row;
    justify-content: start;
    align-items: center; /* Center items vertically */
    margin-right: auto; // Push this item to the start
  }

  .iconButton {
    border: 1px solid #cecece;
    border-radius: 4px;
    font-size: auto;
  }
`;

// src/node_modules/@tabler/icons/icons/outline/message-forward.svg
var message_forward_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-message-forward"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M18 4a3 3 0 0 1 3 3v8a3 3 0 0 1 -3 3h-5l-5 3v-3h-2a3 3 0 0 1 -3 -3v-8a3 3 0 0 1 3 -3h12z" />%0A  <path d="M13 8l3 3l-3 3" />%0A  <path d="M16 11h-8" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/file-arrow-right.svg
var file_arrow_right_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-file-arrow-right"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M14 3v4a1 1 0 0 0 1 1h4" />%0A  <path d="M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z" />%0A  <path d="M9 15h6" />%0A  <path d="M12.5 17.5l2.5 -2.5l-2.5 -2.5" />%0A</svg>';

// src/components/node-editor/node-container-templates/template-popup-to-popup.ts
var templatePopupToPopup = {
  drawflow: {
    Home: {
      data: {
        "2": {
          id: 2,
          name: "Untitled Popup",
          data: {
            title: "Decision Popup"
          },
          class: "popup",
          typenode: false,
          inputs: { input_1: { connections: [] } },
          outputs: {
            output_1: { connections: [{ node: "3", output: "input_1" }] },
            output_2: { connections: [{ node: "4", output: "input_1" }] }
          },
          pos_x: 320,
          pos_y: 104
        },
        "3": {
          id: 3,
          name: "Untitled Popup",
          data: {
            title: "Correct Popup"
          },
          class: "popup",
          typenode: false,
          inputs: {
            input_1: { connections: [{ node: "2", input: "output_1" }] }
          },
          outputs: {},
          pos_x: 872,
          pos_y: -28
        },
        "4": {
          id: 4,
          name: "Untitled Popup",
          data: {
            title: "Wrong Popup"
          },
          class: "popup",
          typenode: false,
          inputs: {
            input_1: { connections: [{ node: "2", input: "output_2" }] }
          },
          outputs: {},
          pos_x: 861,
          pos_y: 232
        }
      }
    }
  },
  containers: [
    {
      tagName: "webwriter-gamebook-popup",
      attributes: [
        { name: "class", value: "ww-widget ww-v0.0.1" },
        { name: "style", value: "display: none;" },
        { name: "drawflownodeid", value: "2" },
        { name: "pagetitle", value: "Untitled Popup" },
        { name: "contenteditable", value: "" }
      ],
      innerHTML: '<p><b>How will the reader answer this question?</b></p><webwriter-gamebook-button class="ww-widget ww-v0.0.1" name="Option A" datatargetid="3" identifier="2-output_1-3-input_1" contenteditable="" size="small" width="100" alignment="center" variant="default"></webwriter-gamebook-button><webwriter-gamebook-button class="ww-widget ww-v0.0.1" name="Option B" datatargetid="4" identifier="2-output_2-4-input_1" contenteditable="" size="small" width="100" alignment="center" variant="default"></webwriter-gamebook-button>'
    },
    {
      tagName: "webwriter-gamebook-popup",
      attributes: [
        { name: "class", value: "ww-widget ww-v0.0.1" },
        { name: "style", value: "display: none;" },
        { name: "drawflownodeid", value: "3" },
        { name: "pagetitle", value: "Untitled Popup" },
        { name: "contenteditable", value: "" }
      ],
      innerHTML: "<p><b>This is correct!</b></p><p>The answer you gave is correct. Please proceed with the gamebook.</p>"
    },
    {
      tagName: "webwriter-gamebook-popup",
      attributes: [
        { name: "class", value: "ww-widget ww-v0.0.1" },
        { name: "style", value: "display: none;" },
        { name: "drawflownodeid", value: "4" },
        { name: "pagetitle", value: "Untitled Popup" },
        { name: "contenteditable", value: "" }
      ],
      innerHTML: "<p><b>This is wrong!</b></p><p>Unfortunately, the answer you gave is wrong. Try again!</p>"
    }
  ]
};

// src/components/node-editor/node-container-templates/template-popup-to-pages.ts
var templatePopUpToPages = {
  drawflow: {
    Home: {
      data: {
        "6": {
          id: 6,
          name: "Untitled Popup",
          data: {
            title: "Decision Popup"
          },
          class: "popup",
          typenode: false,
          inputs: { input_1: { connections: [] } },
          outputs: {
            output_1: { connections: [{ node: "9", output: "input_1" }] },
            output_2: { connections: [{ node: "10", output: "input_1" }] }
          },
          pos_x: 155.5,
          pos_y: 109
        },
        "9": {
          id: 9,
          name: "Untitled Page",
          data: {
            title: "Option A"
          },
          class: "page",
          typenode: false,
          inputs: {
            input_1: { connections: [{ node: "6", input: "output_1" }] }
          },
          outputs: { output_1: { connections: [] } },
          pos_x: 672.5,
          pos_y: -2
        },
        "10": {
          id: 10,
          name: "Untitled Page",
          data: {
            title: "Option B"
          },
          class: "page",
          typenode: false,
          inputs: {
            input_1: { connections: [{ node: "6", input: "output_2" }] }
          },
          outputs: { output_1: { connections: [] } },
          pos_x: 688.5,
          pos_y: 237
        }
      }
    }
  },
  containers: [
    {
      tagName: "webwriter-gamebook-popup",
      attributes: [
        { name: "class", value: "ww-v0.0.1 ww-widget ww-v0.0.4" },
        { name: "contenteditable", value: "" },
        { name: "style", value: "display: none;" },
        { name: "tabindex", value: "-1" },
        { name: "drawflownodeid", value: "6" },
        { name: "pagetitle", value: "Untitled Popup" },
        { name: "titlelabel", value: "Dialog" },
        { name: "branchesoff", value: "-1" }
      ],
      innerHTML: '<p><b>How will the reader answer this question?</b></p><webwriter-gamebook-popup id="ww-ee5825b5-3918-4db1-b7bb-3ca3cd7eecdb" class="ww-v0.0.1 ww-widget ww-v0.0.4" contenteditable="" style="display: none;" tabindex="-1" drawflownodeid="6" pagetitle="Untitled Popup" titlelabel="Dialog" branchesoff="-1"><webwriter-gamebook-button class="ww-v0.0.1 ww-widget ww-v0.0.4" contenteditable="" tabindex="-1" name="Option B" datatargetid="9" identifier="6-output_1-9-input_1" size="small" width="100" alignment="center" variant="default"></webwriter-gamebook-button></webwriter-gamebook-popup><webwriter-gamebook-button id="ww-7d81dc03-6b3f-461b-a8b1-ea322ccf4583" class="ww-widget ww-v0.0.4" tabindex="-1" name="Option A" datatargetid="9" identifier="6-output_1-9-input_1" size="small" width="50" alignment="center" variant="default" contenteditable=""></webwriter-gamebook-button><webwriter-gamebook-button class="ww-widget ww-v0.0.4" tabindex="-1" name="Option B" datatargetid="10" identifier="6-output_2-10-input_1" size="small" width="50" alignment="center" variant="default" contenteditable=""></webwriter-gamebook-button>'
    },
    {
      tagName: "webwriter-gamebook-page",
      attributes: [
        { name: "class", value: "ww-widget ww-v0.0.4" },
        { name: "style", value: "display: none;" },
        { name: "tabindex", value: "-1" },
        { name: "drawflownodeid", value: "9" },
        { name: "pagetitle", value: "Option A" },
        { name: "originpage", value: "0" },
        { name: "branchesoff", value: "-1" },
        { name: "contenteditable", value: "" }
      ],
      innerHTML: '<p><br class="ProseMirror-trailingBreak"></p>'
    },
    {
      tagName: "webwriter-gamebook-page",
      attributes: [
        { name: "class", value: "ww-widget ww-v0.0.4" },
        { name: "style", value: "display: none;" },
        { name: "tabindex", value: "-1" },
        { name: "drawflownodeid", value: "10" },
        { name: "pagetitle", value: "Option B" },
        { name: "originpage", value: "0" },
        { name: "branchesoff", value: "-1" },
        { name: "contenteditable", value: "" }
      ],
      innerHTML: '<p><br class="ProseMirror-trailingBreak"></p>'
    }
  ]
};

// src/components/node-editor/node-container-templates/template-quiz-branch-to-pages.ts
var templateQuizBranchToPages = {
  drawflow: {
    Home: {
      data: {
        "2": {
          id: 2,
          name: "Untitled Page",
          data: {
            title: "Untitled Page"
          },
          class: "page",
          typenode: false,
          inputs: {
            input_1: { connections: [{ node: "6", input: "output_1" }] }
          },
          outputs: {
            output_1: { connections: [{ node: "3", output: "input_1" }] }
          },
          pos_x: 28,
          pos_y: 155
        },
        "3": {
          id: 3,
          name: "Untitled Branch",
          data: {
            title: "Untitled Branch"
          },
          class: "branch",
          typenode: false,
          inputs: {
            input_1: { connections: [{ node: "2", input: "output_1" }] }
          },
          outputs: {
            output_1: { connections: [{ node: "5", output: "input_1" }] },
            output_2: { connections: [{ node: "6", output: "input_1" }] }
          },
          pos_x: 436.6666666666667,
          pos_y: 152
        },
        "5": {
          id: 5,
          name: "Untitled Popup",
          data: {
            title: "Right Answer Popup"
          },
          class: "popup",
          typenode: false,
          inputs: {
            input_1: { connections: [{ node: "3", input: "output_1" }] }
          },
          outputs: {
            output_1: { connections: [{ node: "7", output: "input_1" }] }
          },
          pos_x: 1016,
          pos_y: 41
        },
        "6": {
          id: 6,
          name: "Untitled Popup",
          data: {
            title: "Wrong Answer Popup"
          },
          class: "popup",
          typenode: false,
          inputs: {
            input_1: { connections: [{ node: "3", input: "output_2" }] }
          },
          outputs: {
            output_1: { connections: [{ node: "2", output: "input_1" }] }
          },
          pos_x: 1018.6666666666666,
          pos_y: 271.6666666666667
        },
        "7": {
          id: 7,
          name: "Untitled Page",
          data: {
            title: "Untitled Page"
          },
          class: "page",
          typenode: false,
          inputs: {
            input_1: { connections: [{ node: "5", input: "output_1" }] }
          },
          outputs: { output_1: { connections: [] } },
          pos_x: 1491,
          pos_y: 12
        }
      }
    }
  },
  containers: [
    {
      tagName: "webwriter-gamebook-page",
      attributes: [
        { name: "id", value: "ww-4a2e906e-7974-4ba0-aae6-1afc2337aef6" },
        { name: "class", value: "ww-widget ww-v0.0.4" },
        { name: "style", value: "display: none;" },
        { name: "tabindex", value: "-1" },
        { name: "drawflownodeid", value: "2" },
        { name: "pagetitle", value: "Untitled Page" },
        { name: "originpage", value: "0" },
        { name: "branchesoff", value: "3" },
        { name: "contenteditable", value: "" }
      ],
      innerHTML: `<webwriter-quiz id="ww-c246dffc-d87a-4f36-a314-d49fe0adfbf0" class="ww-widget ww-v1.0.2" contenteditable=""><webwriter-task id="ww-2959750b-0180-4eaf-af4c-43afd35766ab" class="ww-widget ww-v1.0.2" counter="undefined" solution="data:application/octet-stream;base64,irEXJoX0ryNlx/n0LjeM7He4q2OvnzXcj/f9vK2mXPdm9A6ZD9y7rCP9dqXFt9uCBkFHrsM/4+QY5+k=" iv="data:application/octet-stream;base64,qAoVejoNq3VfbOdE" salt="data:application/octet-stream;base64,Rl1lTsy1GAdujo4P3ugNFg==" contenteditable=""><webwriter-task-prompt id="ww-dcefc851-f8dc-46f7-b1c7-630dbb20daed" class="ww-widget ww-v1.0.2" slot="prompt" contenteditable=""><p>What is Pythagoras' theorem?</p></webwriter-task-prompt><webwriter-choice id="ww-3dba2833-9078-4448-9c54-7946e2f7aad9" class="ww-widget ww-v1.0.2" mode="single" contenteditable=""><webwriter-choice-item id="ww-1242a67d-2cef-4238-899e-468f9e5d7970" class="ww-widget ww-v1.0.2" layout="list" contenteditable=""><p>The sum of the angles in a triangle is 180 degrees.</p></webwriter-choice-item><webwriter-choice-item id="ww-d3e3b0e4-5251-44ba-8290-cb7d5ce03d4e" class="ww-widget ww-v1.0.2" layout="list" contenteditable=""><p>The area of a circle is \u03C0r\xB2.</p></webwriter-choice-item><webwriter-choice-item id="ww-59d867c6-8ad2-4eec-96cd-3bfa06cddc38" class="ww-widget ww-v1.0.2" layout="list" contenteditable=""><p>In a right-angled triangle, the square of the hypotenuse is equal to the sum of the squares of the other two sides.</p></webwriter-choice-item><webwriter-choice-item id="ww-d0e6982f-1f1e-45db-92c2-8001a7f1127d" class="ww-widget ww-v1.0.2" layout="list" contenteditable=""><p>The circumference of a circle is 2\u03C0r.</p></webwriter-choice-item></webwriter-choice></webwriter-task></webwriter-quiz><webwriter-gamebook-branch-button id="ww-8d12d60e-0423-4a3b-a330-911c7d06dd03" class="ww-widget ww-v0.0.4" tabindex="-1" name="Continue" datatargetid="3" identifier="2-output_1-3-input_1" size="small" width="25" alignment="flex-end" variant="primary" contenteditable=""></webwriter-gamebook-branch-button>`
    },
    {
      tagName: "webwriter-gamebook-branch",
      attributes: [
        { name: "id", value: "ww-5e12e116-b01c-45c0-84ce-96e9cd539174" },
        { name: "class", value: "ww-widget ww-v0.0.4" },
        { name: "style", value: "display: none;" },
        { name: "drawflownodeid", value: "3" },
        { name: "pagetitle", value: "Untitled Branch" },
        { name: "incomingcontainerid", value: "2" },
        {
          name: "rules",
          value: '[{"output_id":"output_1","elementId":"ww-c246dffc-d87a-4f36-a314-d49fe0adfbf0","quizTasks":"ww-2959750b-0180-4eaf-af4c-43afd35766ab","condition":"correct","match":"100","target":5,"isConditionEnabled":true,"isMatchEnabled":true,"isTargetEnabled":true}]'
        },
        { name: "contenteditable", value: "" },
        {
          name: "elserule",
          value: '{"output_id":"output_2","elementId":"","quizTasks":"","condition":"","match":"","target":6,"isConditionEnabled":false,"isMatchEnabled":false,"isTargetEnabled":false}'
        }
      ],
      innerHTML: ""
    },
    {
      tagName: "webwriter-gamebook-popup",
      attributes: [
        { name: "id", value: "ww-9c656066-e29e-47ec-8ccb-66268e30173e" },
        { name: "class", value: "ww-widget ww-v0.0.4" },
        { name: "style", value: "display: none;" },
        { name: "drawflownodeid", value: "5" },
        { name: "pagetitle", value: "Right Answer Popup" },
        { name: "contenteditable", value: "" },
        { name: "tabindex", value: "-1" },
        { name: "titlelabel", value: "Your answer is correct!" },
        { name: "branchesoff", value: "-1" },
        { name: "preventclosing", value: "" }
      ],
      innerHTML: '<p>Amazing! Good job.</p><webwriter-gamebook-button id="ww-45504c71-eb03-496a-b38c-78f54ef64206" class="ww-widget ww-v0.0.4" name="Continue" datatargetid="7" identifier="5-output_1-7-input_1" contenteditable="" size="small" width="27" alignment="flex-end" variant="success" tabindex="-1"></webwriter-gamebook-button>'
    },
    {
      tagName: "webwriter-gamebook-popup",
      attributes: [
        { name: "id", value: "ww-4c21478c-2510-477e-b811-2d20a9f9230a" },
        { name: "class", value: "ww-widget ww-v0.0.4" },
        { name: "style", value: "display: none;" },
        { name: "drawflownodeid", value: "6" },
        { name: "pagetitle", value: "Wrong Answer Popup" },
        { name: "contenteditable", value: "" },
        { name: "tabindex", value: "-1" },
        { name: "titlelabel", value: "Incorrect!" },
        { name: "branchesoff", value: "-1" },
        { name: "preventclosing", value: "" }
      ],
      innerHTML: '<p>Sorry, your answer is wrong. Better luck next time.</p><webwriter-gamebook-button id="ww-009ab5ff-1499-4143-b7cf-7de52d1111b4" class="ww-widget ww-v0.0.4" name="Try again!" datatargetid="2" identifier="6-output_1-2-input_1" contenteditable="" size="small" width="32" alignment="flex-end" variant="danger" tabindex="-1" pill=""></webwriter-gamebook-button>'
    },
    {
      tagName: "webwriter-gamebook-page",
      attributes: [
        { name: "id", value: "ww-a7f50ec7-a713-474f-9fb7-94c074f78477" },
        { name: "class", value: "ww-widget ww-v0.0.4" },
        { name: "style", value: "display: none;" },
        { name: "drawflownodeid", value: "7" },
        { name: "pagetitle", value: "Untitled Page" },
        { name: "originpage", value: "0" },
        { name: "contenteditable", value: "" },
        { name: "tabindex", value: "-1" },
        { name: "branchesoff", value: "-1" }
      ],
      innerHTML: "<p>Ask more questions here!</p>"
    }
  ]
};

// src/components/node-editor/toolbar/node-editor-toolbar.ts
var _editorStore_dec9, _a19, _NodeEditorToolbar_decorators, _init19, _editorStore9;
_NodeEditorToolbar_decorators = [t4("node-editor-toolbar")];
var NodeEditorToolbar = class extends (_a19 = LitElementWw, _editorStore_dec9 = [c4({ context: editorState, subscribe: true }), n6({ type: Object, attribute: true, reflect: false })], _a19) {
  constructor() {
    super(...arguments);
    __privateAdd(this, _editorStore9, __runInitializers(_init19, 8, this, new GamebookEditorState("Default"))), __runInitializers(_init19, 11, this);
  }
  //registering custom elements used in the widget
  static get scopedElements() {
    return {
      "sl-button": button_default,
      "sl-button-group": button_group_default,
      "sl-textarea": textarea_default,
      "sl-divider": divider_default,
      "sl-dialog": dialog_default,
      "sl-icon": icon_default,
      "sl-icon-button": icon_button_default,
      "sl-menu": menu_default,
      "sl-menu-item": menu_item_default,
      "sl-dropdown": dropdown_default,
      "sl-menu-label": menu_label_default,
      "sl-input": input_default,
      "sl-badge": badge_default
    };
  }
  render() {
    return ke`
      <div class="controls">
        <div class="first-item">
          <sl-input
            id="gamebookTitle"
            rows="1"
            resize="none"
            placeholder="Gamebook Title"
            @input="${this.textAreaInputChanged}"
            .value="${this.editorStore.title}"
          >
            <sl-icon slot="prefix" src=${book_default}></sl-icon>
          </sl-input>
        </div>

        <sl-dropdown placement="bottom-end" hoist>
          <sl-button slot="trigger">
            Add
            <sl-icon src=${plus_default} slot="prefix"></sl-icon>
          </sl-button>
          <sl-menu style="width: 200px;" hoist>
            <sl-menu-label>Nodes</sl-menu-label>
            <sl-menu-item
              @click=${() => {
      this.dispatchEvent(
        new CustomEvent("addPageNode", {
          detail: { title: "Untitled Page", isOrigin: false },
          bubbles: true,
          composed: true
        })
      );
    }}
            >
              <sl-icon slot="prefix" src=${file_default2}></sl-icon>
              Page
            </sl-menu-item>
            <sl-menu-item
              @click=${() => {
      this.dispatchEvent(
        new CustomEvent("addPopUpNode", {
          detail: { title: "Untitled Popup" },
          bubbles: true,
          composed: true
        })
      );
    }}
            >
              <sl-icon slot="prefix" src=${squares_default}></sl-icon>
              Popup
            </sl-menu-item>
            <sl-menu-item
              @click=${() => {
      this.dispatchEvent(
        new CustomEvent("addBranchNode", {
          detail: { title: "Untitled Branch" },
          bubbles: true,
          composed: true
        })
      );
    }}
            >
              <sl-icon slot="prefix" src=${arrows_split_2_default}></sl-icon>
              Branch
            </sl-menu-item>
            <sl-divider></sl-divider>
            <sl-menu-label>Node Blocks</sl-menu-label>
            <sl-menu-item
              @click=${() => {
      this.dispatchEvent(
        new CustomEvent("addTemplate", {
          detail: { template: templatePopUpToPages },
          bubbles: true,
          composed: true
        })
      );
    }}
            >
              <sl-icon slot="prefix" src=${file_arrow_right_default}></sl-icon>
              Popup to Pages
            </sl-menu-item>

            <sl-menu-item
              @click=${() => {
      this.dispatchEvent(
        new CustomEvent("addTemplate", {
          detail: { template: templatePopupToPopup },
          bubbles: true,
          composed: true
        })
      );
    }}
            >
              <sl-icon slot="prefix" src=${message_forward_default}></sl-icon>
              Popup to Popups
            </sl-menu-item>

            <sl-menu-item
              @click=${() => {
      this.dispatchEvent(
        new CustomEvent("addTemplate", {
          detail: { template: templateQuizBranchToPages },
          bubbles: true,
          composed: true
        })
      );
    }}
            >
              <sl-icon slot="prefix" src=${help_octagon_default}></sl-icon>
              Quiz to Branch to Pages
              <sl-badge variant="primary" pill slot="suffix">
                <sl-icon src=${packages_default}></sl-icon
              ></sl-badge>
            </sl-menu-item>
          </sl-menu>
        </sl-dropdown>
        <sl-divider vertical style="height: 30px"> </sl-divider>
        <sl-button
          @click=${() => {
      this.dispatchEvent(new CustomEvent("clearDialog"));
    }}
        >
          Clear
        </sl-button>
      </div>
    `;
  }
  /*
  
  
    */
  textAreaInputChanged(event) {
    this.editorStore.setTitle(event.target.value);
  }
};
_init19 = __decoratorStart(_a19);
_editorStore9 = new WeakMap();
__decorateElement(_init19, 4, "editorStore", _editorStore_dec9, NodeEditorToolbar, _editorStore9);
NodeEditorToolbar = __decorateElement(_init19, 0, "NodeEditorToolbar", _NodeEditorToolbar_decorators, NodeEditorToolbar);
//import CSS
__publicField(NodeEditorToolbar, "styles", [node_editor_toolbar_styles_default]);
__runInitializers(_init19, 1, NodeEditorToolbar);

// src/node_modules/@tabler/icons/icons/outline/arrows-move.svg
var arrows_move_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-arrows-move"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M18 9l3 3l-3 3" />%0A  <path d="M15 12h6" />%0A  <path d="M6 9l-3 3l3 3" />%0A  <path d="M3 12h6" />%0A  <path d="M9 18l3 3l3 -3" />%0A  <path d="M12 15v6" />%0A  <path d="M15 6l-3 -3l-3 3" />%0A  <path d="M12 3v6" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/question-mark.svg
var question_mark_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-question-mark"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M8 8a3.5 3 0 0 1 3.5 -3h1a3.5 3 0 0 1 3.5 3a3 3 0 0 1 -2 3a3 4 0 0 0 -2 4" />%0A  <path d="M12 19l0 .01" />%0A</svg>';

// src/components/node-editor/help-menu/node-editor-help-menu.styles.ts
var node_editor_help_menu_styles_default = i`
  .help {
    float: right;
    position: absolute;
    bottom: 10px;
    left: 10px;

    width: auto;
    height: auto;
    background-color: rgba(255, 255, 255, 0.95);

    box-sizing: border-box;
    padding: 10px;

    display: flex;
    flex-direction: row;
    align-items: left;
    justify-content: left;
    border-radius: 4px;

    gap: 20px;

    box-sizing: border-box;

    border-radius: 8px;
    border: 1px solid #e4e4e7;
  }

  .helpIconButton {
    float: right;
    position: absolute;
    bottom: 10px;
    left: 10px;
    background-color: rgba(255, 255, 255, 0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;

    box-sizing: border-box;

    border-radius: 8px;
    border: 1px solid #e4e4e7;
  }

  .close-icon {
    position: absolute;
    top: 1px;
    right: 5px;
    font-size: 10px;
    aspect-ratio: 1;
    cursor: pointer;
  }

  .column {
    display: flex;
    flex-direction: column;
    align-items: left;
    justify-content: left;
    gap: 10px;
  }

  .help-item {
    height: 25px;
    display: flex;
    align-items: center;
    color: #3f3f46;
  }

  .icon-plus {
    display: flex;
    align-items: center;
    gap: 5px; /* Add some space between the elements */
    color: #3f3f46;
  }

  .icon-plus p {
    margin: 1px;
    font-size: 10px;
    color: #3f3f46;
  }

  .label {
    font-size: 10px;
    color: #3f3f46;
  }
`;

// src/components/node-editor/help-menu/node-editor-help-menu.ts
var _showWindow_dec, _a20, _NodeEditorHelpMenu_decorators, _init20, _showWindow;
_NodeEditorHelpMenu_decorators = [t4("node-editor-help-menu")];
var NodeEditorHelpMenu = class extends (_a20 = LitElementWw, _showWindow_dec = [r5()], _a20) {
  constructor() {
    super(...arguments);
    __privateAdd(this, _showWindow, __runInitializers(_init20, 8, this, false)), __runInitializers(_init20, 11, this);
  }
  //registering custom elements used in the widget
  static get scopedElements() {
    return {
      "sl-icon": icon_default,
      "sl-icon-button": icon_button_default
    };
  }
  render() {
    return ke` ${this.showWindow ? ke`
    <div class="help">
      <div class="close-icon" @click="${this.toggleWindow}">x</div>
      <div class="column">
        <div class="help-item">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="1em"
            height="1em"
            viewBox="0 0 256 256"
          >
            <path
              fill="currentColor"
              d="M144 16h-32a64.07 64.07 0 0 0-64 64v96a64.07 64.07 0 0 0 64 64h32a64.07 64.07 0 0 0 64-64V80a64.07 64.07 0 0 0-64-64m48 64v24h-64V32h16a48.05 48.05 0 0 1 48 48m-48 144h-32a48.05 48.05 0 0 1-48-48v-56h128v56a48.05 48.05 0 0 1-48 48"
            />
          </svg>
        </div>  

        <div class="help-item">
          <div class="icon-plus">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="1em"
              height="1em"
              viewBox="0 0 256 256"
            >
              <path
                fill="currentColor"
                d="M144 16h-32a64.07 64.07 0 0 0-64 64v96a64.07 64.07 0 0 0 64 64h32a64.07 64.07 0 0 0 64-64V80a64.07 64.07 0 0 0-64-64m48 64v24h-64V32h16a48.05 48.05 0 0 1 48 48m-48 144h-32a48.05 48.05 0 0 1-48-48v-56h128v56a48.05 48.05 0 0 1-48 48"
              />
            </svg>
            <p>+</p>
            <sl-icon src=${arrows_move_default}></sl-icon>
          </div>
        </div>

        <div class="help-item">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="1em"
            height="1em"
            viewBox="0 0 256 256"
          >
            <path
              fill="currentColor"
              d="M144 16h-32a64.07 64.07 0 0 0-64 64v96a64.07 64.07 0 0 0 64 64h32a64.07 64.07 0 0 0 64-64V80a64.07 64.07 0 0 0-64-64m-32 16h16v72H64V80a48.05 48.05 0 0 1 48-48m32 192h-32a48.05 48.05 0 0 1-48-48v-56h128v56a48.05 48.05 0 0 1-48 48"
            />
          </svg>
        </div>

        <div class="help-item">
          <div class="icon-plus">
            <p class="key-icon">CTRL</p>
            <p>+</p>
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="1em"
              height="1em"
              viewBox="0 0 256 256"
            >
              <path
                fill="currentColor"
                d="M144 16h-32a64.07 64.07 0 0 0-64 64v96a64.07 64.07 0 0 0 64 64h32a64.07 64.07 0 0 0 64-64V80a64.07 64.07 0 0 0-64-64m48 160a48.05 48.05 0 0 1-48 48h-32a48.05 48.05 0 0 1-48-48V80a48.05 48.05 0 0 1 48-48h32a48.05 48.05 0 0 1 48 48Zm-56-92.69v89.38l10.34-10.35a8 8 0 0 1 11.32 11.32l-24 24a8 8 0 0 1-11.32 0l-24-24a8 8 0 0 1 11.32-11.32L120 172.69V83.31l-10.34 10.35a8 8 0 0 1-11.32-11.32l24-24a8 8 0 0 1 11.32 0l24 24a8 8 0 0 1-11.32 11.32Z"
              />
            </svg>
          </div>
        </div>
        </div>

        <div class="column">
            <div class="help-item"><p class="label">Select</p></div>

            <div class="help-item"><p class="label">Drag Connection</p></div>
            <div class="help-item"><p class="label">Delete</p></div>
            <div class="help-item"><p class="label">Zoom In/Out</p></div>
        </div>
      </div>
    </div>` : ke` <div class="helpIconButton">
          <sl-icon-button
            class="helpIcon"
            src=${question_mark_default}
            @click="${this.toggleWindow}"
          ></sl-icon-button>
        </div>`}`;
  }
  toggleWindow() {
    this.showWindow = !this.showWindow;
  }
};
_init20 = __decoratorStart(_a20);
_showWindow = new WeakMap();
__decorateElement(_init20, 4, "showWindow", _showWindow_dec, NodeEditorHelpMenu, _showWindow);
NodeEditorHelpMenu = __decorateElement(_init20, 0, "NodeEditorHelpMenu", _NodeEditorHelpMenu_decorators, NodeEditorHelpMenu);
//import CSS
__publicField(NodeEditorHelpMenu, "styles", [node_editor_help_menu_styles_default]);
__runInitializers(_init20, 1, NodeEditorHelpMenu);

// src/components/node-editor/node-editor.ts
var NO_CONNECTION_SELECTED = "output_id-input_id-output_class-input_class";
var GRID_SIZE = 40;
var _editorStore_dec10, _nodeDivs_dec, _drawflowEditorDiv_dec, _nodePasted_dec, _backgroundScaleFactor_dec, _backgroundMaxScale_dec, _backgroundMinScale_dec, _backgroundScale_dec, _backgroundTranslateY_dec, _backgroundTranslateX_dec, _backgroundLastY_dec, _backgroundLastX_dec, _backgroundIsDragging_dec, _connectionStarted_dec, _selectedConnection_dec, _editorZoomString_dec, _editor_dec, _a21, _NodeEditor_decorators, _init21, _editor, _editorZoomString, _selectedConnection, _connectionStarted, _backgroundIsDragging, _backgroundLastX, _backgroundLastY, _backgroundTranslateX, _backgroundTranslateY, _backgroundScale, _backgroundMinScale, _backgroundMaxScale, _backgroundScaleFactor, _nodePasted, _drawflowEditorDiv, _nodeDivs, _editorStore10;
_NodeEditor_decorators = [t4("node-editor")];
var NodeEditor = class extends (_a21 = LitElementWw, _editor_dec = [n6({ type: Object, attribute: true, reflect: false })], _editorZoomString_dec = [n6({ type: String })], _selectedConnection_dec = [n6({ type: String })], _connectionStarted_dec = [n6({ type: Boolean, attribute: true })], _backgroundIsDragging_dec = [n6({ type: Boolean })], _backgroundLastX_dec = [n6({ type: Number })], _backgroundLastY_dec = [n6({ type: Number })], _backgroundTranslateX_dec = [n6({ type: Number })], _backgroundTranslateY_dec = [n6({ type: Number })], _backgroundScale_dec = [n6({ type: Number })], _backgroundMinScale_dec = [n6({ type: Number })], _backgroundMaxScale_dec = [n6({ type: Number })], _backgroundScaleFactor_dec = [n6({ type: Number })], _nodePasted_dec = [n6({ type: Boolean })], _drawflowEditorDiv_dec = [e7("#drawflowEditorDiv")], _nodeDivs_dec = [r6('div[id*="node-"]')], _editorStore_dec10 = [c4({ context: editorState, subscribe: true }), n6({ type: Object, attribute: true, reflect: false })], _a21) {
  constructor() {
    super(...arguments);
    __privateAdd(this, _editor, __runInitializers(_init21, 8, this)), __runInitializers(_init21, 11, this);
    __privateAdd(this, _editorZoomString, __runInitializers(_init21, 12, this, "")), __runInitializers(_init21, 15, this);
    __privateAdd(this, _selectedConnection, __runInitializers(_init21, 16, this, NO_CONNECTION_SELECTED)), __runInitializers(_init21, 19, this);
    __privateAdd(this, _connectionStarted, __runInitializers(_init21, 20, this, false)), __runInitializers(_init21, 23, this);
    __privateAdd(this, _backgroundIsDragging, __runInitializers(_init21, 24, this, false)), __runInitializers(_init21, 27, this);
    __privateAdd(this, _backgroundLastX, __runInitializers(_init21, 28, this, 0)), __runInitializers(_init21, 31, this);
    __privateAdd(this, _backgroundLastY, __runInitializers(_init21, 32, this, 0)), __runInitializers(_init21, 35, this);
    __privateAdd(this, _backgroundTranslateX, __runInitializers(_init21, 36, this, 0)), __runInitializers(_init21, 39, this);
    __privateAdd(this, _backgroundTranslateY, __runInitializers(_init21, 40, this, 0)), __runInitializers(_init21, 43, this);
    __privateAdd(this, _backgroundScale, __runInitializers(_init21, 44, this, 0.45)), __runInitializers(_init21, 47, this);
    __privateAdd(this, _backgroundMinScale, __runInitializers(_init21, 48, this, 0.5)), __runInitializers(_init21, 51, this);
    __privateAdd(this, _backgroundMaxScale, __runInitializers(_init21, 52, this, 2)), __runInitializers(_init21, 55, this);
    __privateAdd(this, _backgroundScaleFactor, __runInitializers(_init21, 56, this, 1.05)), __runInitializers(_init21, 59, this);
    __privateAdd(this, _nodePasted, __runInitializers(_init21, 60, this, false)), __runInitializers(_init21, 63, this);
    __privateAdd(this, _drawflowEditorDiv, __runInitializers(_init21, 64, this)), __runInitializers(_init21, 67, this);
    __privateAdd(this, _nodeDivs, __runInitializers(_init21, 68, this)), __runInitializers(_init21, 71, this);
    __privateAdd(this, _editorStore10, __runInitializers(_init21, 72, this, new GamebookEditorState("Default"))), __runInitializers(_init21, 75, this);
  }
  //registering custom elements used in the Web component
  static get scopedElements() {
    return {
      "sl-button": button_default,
      "sl-textarea": textarea_default,
      "sl-divider": divider_default,
      "sl-dialog": dialog_default,
      "sl-icon": icon_default,
      "sl-icon-button": icon_button_default,
      "sl-menu": menu_default,
      "sl-menu-item": menu_item_default,
      "sl-dropdown": dropdown_default,
      "sl-menu-label": menu_label_default,
      "node-editor-toolbar": NodeEditorToolbar,
      "node-editor-help-menu": NodeEditorHelpMenu
    };
  }
  /*
  
    */
  firstUpdated(_changedProperties) {
    this.editor = new import_drawflow.default(this.drawflowEditorDiv);
    this.editor.reroute = false;
    this.editor.reroute_fix_curvature = false;
    this.editor.zoom_max = 0.8;
    this.editor.zoom_min = 0.25;
    this.editor.zoom_value = 0.05;
    if (this.editorStore.editorZoom == -1) {
      this.editor.zoom = this.backgroundScale;
    } else {
      this.editor.zoom = this.editorStore.editorZoom;
      this.onZoom(this.editorStore.editorZoom, 0.2, this.editor.zoom_max);
    }
    this.editor.start();
    this.editor.zoom_refresh();
    if (this.editorStore.editorPosition.x != void 0 && this.editorStore.editorPosition.y != void 0) {
      this.editor.canvas_x = this.editorStore.editorPosition.x;
      this.editor.canvas_y = this.editorStore.editorPosition.y;
      const drawflowContainer = this.drawflowEditorDiv.querySelector(".drawflow");
      if (drawflowContainer) {
        drawflowContainer.style.transform = `translate(${this.editor.canvas_x}px, ${this.editor.canvas_y}px) scale(${this.editor.zoom})`;
      }
    }
    this._registerEditorEventHandlers();
    if (this.editorStore.editorContent == null) {
      this.addPageNode("First Page", true);
    } else {
      let editorContent = this.addHTMLToNodes(this.editorStore.editorContent);
      this.editor.import(editorContent);
      if (this.editorStore.selectedNode.id !== -1) {
        this.programaticallySelectNode(
          this.editorStore.selectedNode.id.toString()
        );
      }
      this.dispatchEvent(
        new CustomEvent("editorInitialized", {
          bubbles: true,
          composed: true
        })
      );
    }
  }
  updated(_changedProperties) {
    if (_changedProperties.has("editorStore")) {
    }
  }
  /*
  
    */
  connectedCallback() {
    super.connectedCallback();
    this.shadowRoot?.addEventListener("mousemove", this.onMouseMove.bind(this));
    this.shadowRoot?.addEventListener("mousedown", this.onMouseDown.bind(this));
    this.shadowRoot?.addEventListener("mouseup", this.onMouseUp.bind(this));
    this.shadowRoot?.addEventListener(
      "mouseleave",
      this.onMouseLeave.bind(this)
    );
  }
  /*
  
    */
  disconnectedCallback() {
    this.shadowRoot?.removeEventListener(
      "mousemove",
      this.onMouseMove.bind(this)
    );
    this.shadowRoot?.removeEventListener(
      "mousedown",
      this.onMouseDown.bind(this)
    );
    this.shadowRoot?.removeEventListener("mouseup", this.onMouseUp.bind(this));
    this.shadowRoot?.removeEventListener(
      "mouseleave",
      this.onMouseLeave.bind(this)
    );
    super.disconnectedCallback();
  }
  /*
  
    */
  render() {
    const gridStyles = {
      backgroundPosition: `${this.backgroundTranslateX}px ${this.backgroundTranslateY}px`,
      backgroundSize: `${GRID_SIZE * this.backgroundScale}px ${GRID_SIZE * this.backgroundScale}px`
    };
    return ke`
      <div id="nodeEditor">
        <node-editor-toolbar
          @addPageNode=${(e10) => {
      this.addPageNode(e10.detail.title, e10.detail.isOrigin);
    }}
          @addPopUpNode=${(e10) => {
      this.addPopUpNode(e10.detail.title);
    }}
          @addBranchNode=${(e10) => {
      this.addBranchNode(e10.detail.title);
    }}
          @addTemplate=${(e10) => this.addTemplate(e10.detail.template)}
          @clearDialog=${() => this.shadowRoot.getElementById("dialog").show()}
        >
        </node-editor-toolbar>

        <div id="drawflowEditorDiv" style=${se(gridStyles)}></div>

        <div class="zoomControls">
          <sl-icon-button
            id="jumpToOriginBtn"
            src=${map_pin_default}
            style="font-size: 18px;"
            @click=${() => {
      const nodes = this.editorStore.editorContent.drawflow.Home.data;
      const originNode = Object.values(nodes).find(
        (node) => node.class === "origin"
      );
      this.moveToNode(originNode);
    }}
          >
          </sl-icon-button>
          <sl-divider vertical style="height: 20px; margin: 2px;"></sl-divider>
          <sl-icon-button
            id="zoomInBtn"
            src=${zoom_in_default}
            style="font-size: 18px;"
            @click=${() => this.editor.zoom_in()}
          >
          </sl-icon-button>
          <sl-icon-button
            id="zoomOutBtn"
            src=${zoom_out_default}
            style="font-size: 18px;"
            @click=${() => this.editor.zoom_out()}
          >
          </sl-icon-button>
        </div>

        <div class="zoomValue">
          <p>${this.editorZoomString}</p>
        </div>

        <node-editor-help-menu></node-editor-help-menu>
      </div>
      <!-- Dialog for clearing editor-->
      <sl-dialog label="Clear graph" class="dialog" id="dialog">
        Do you want to clear the graph? All your progress will be lost.
        <sl-button
          slot="footer"
          variant="primary"
          outline
          @click=${() => this.shadowRoot.getElementById("dialog").hide()}
          >Cancel</sl-button
        >
        <sl-button
          slot="footer"
          variant="danger"
          outline
          @click=${() => this._clearEditor()}
          >Clear</sl-button
        >
      </sl-dialog>
      <sl-dialog label="Delete node" class="dialog" id="delete_node_dialog">
        You are about to delete the node
        "${this.editorStore.selectedNode.data.title}". Do you want to proceed?
        <sl-button
          slot="footer"
          variant="primary"
          outline
          @click=${() => this.shadowRoot.getElementById("delete_node_dialog").hide()}
          >Abort</sl-button
        >
        <sl-button
          slot="footer"
          variant="danger"
          outline
          @click=${() => this.deleteSelectedNode()}
          >Delete</sl-button
        >
      </sl-dialog>
    `;
  }
  /*
  
    */
  onMouseDown(event) {
    if (event.target.classList.contains("drawflow") || event.target.id === "drawflowEditorDiv") {
      this.backgroundIsDragging = true;
      this.backgroundLastX = event.clientX;
      this.backgroundLastY = event.clientY;
    }
  }
  /*
  
    */
  onMouseMove(event) {
    if (this.backgroundIsDragging && this.editor.node_selected === null && !this.connectionStarted) {
      const dx = event.clientX - this.backgroundLastX;
      const dy = event.clientY - this.backgroundLastY;
      this.backgroundTranslateX += dx;
      this.backgroundTranslateY += dy;
      this.backgroundLastX = event.clientX;
      this.backgroundLastY = event.clientY;
      this.requestUpdate();
    }
  }
  /*
  
    */
  onMouseUp() {
    if (this.backgroundIsDragging) {
      this.backgroundIsDragging = false;
      this.editorStore.setEditorPosition(
        this.editor.canvas_x,
        this.editor.canvas_y
      );
    }
  }
  /*
  
    */
  onMouseLeave() {
    if (this.backgroundIsDragging) {
      this.backgroundIsDragging = false;
      this.editor.drag_point = false;
      this.editor.drag = false;
      const editorElement = this.drawflowEditorDiv.querySelector(".drawflow");
      if (editorElement) {
        const fakeMouseUpEvent = new MouseEvent("mouseup", {
          bubbles: true,
          cancelable: true,
          view: window
        });
        editorElement.dispatchEvent(fakeMouseUpEvent);
        const computedStyle = window.getComputedStyle(editorElement);
        const transform = computedStyle.transform;
        if (transform && transform !== "none") {
          const matrixValues = transform.match(/matrix\((.+)\)/);
          if (matrixValues && matrixValues[1]) {
            const values = matrixValues[1].split(", ").map(parseFloat);
            const translateX = values[4];
            const translateY = values[5];
            this.editor.canvas_x = translateX;
            this.editor.canvas_y = translateY;
            editorElement.style.transform = `translate(${this.editor.canvas_x}px, ${this.editor.canvas_y}px) scale(${this.editor.zoom})`;
          }
        }
      }
    }
  }
  /*
  
    */
  onZoom(zoom_value, min_zoom, max_zoom) {
    const rect = this.shadowRoot.querySelector(
      "#drawflowEditorDiv"
    ).getBoundingClientRect();
    const centerX = rect.width / 2;
    const centerY = rect.height / 2;
    const prevScale = this.backgroundScale;
    this.backgroundScale = zoom_value;
    this.backgroundScale = Math.min(
      Math.max(min_zoom, this.backgroundScale),
      max_zoom
    );
    const scaleRatio = this.backgroundScale / prevScale;
    this.backgroundTranslateX = centerX - (centerX - this.backgroundTranslateX) * scaleRatio;
    this.backgroundTranslateY = centerY - (centerY - this.backgroundTranslateY) * scaleRatio;
    this.requestUpdate();
  }
  /*
  
  
    */
  addHTMLToNodes(editorContent) {
    let copy = editorContent;
    if (copy) {
      Object.values(copy.drawflow.Home.data).forEach((node) => {
        if (node.class === "page") {
          node.html = this.createPageNodeHTML(false);
        } else if (node.class === "origin") {
          node.html = this.createPageNodeHTML(true);
        } else if (node.class === "popup") {
          node.html = this.createPopupNodeHTML();
        } else if (node.class === "branch") {
          node.html = this.createBranchNodeHTML();
        }
      });
    }
    return copy;
  }
  /*
  
  
    */
  _clearEditor() {
    const dialog = this.shadowRoot.getElementById("dialog");
    dialog.hide();
    this.editor.clear();
    this.editorStore.setEditorContent(this.editor.drawflow);
    this.dispatchEvent(
      new CustomEvent("editorCleared", {
        bubbles: true,
        composed: true
      })
    );
    this.addPageNode("First Page", true);
  }
  /*
  
  */
  moveToNode(node) {
    const { zoom, canvas_x, canvas_y } = this.editor;
    const { id: id3, pos_x, pos_y } = node;
    const nodeDiv = Array.from(this.nodeDivs).find(
      (div) => parseInt(div.id.split("-")[1], 10).toString() === id3.toString()
    );
    const nodeWidth = nodeDiv.offsetWidth;
    const nodeHeight = nodeDiv.offsetHeight;
    const drawflowContainer = this.drawflowEditorDiv.querySelector(".drawflow");
    const rect = this.drawflowEditorDiv.getBoundingClientRect();
    if (drawflowContainer) {
      drawflowContainer.classList.add("smooth-transition");
      this.drawflowEditorDiv.classList.add("smooth-background-transition");
      const nodeCenterX = pos_x + nodeWidth / 2;
      const nodeCenterY = pos_y + nodeHeight / 2;
      const nodePosX = nodeCenterX * zoom + canvas_x + (rect.width - rect.width * zoom) / 2;
      const nodePosY = nodeCenterY * zoom + canvas_y + (rect.height - rect.height * zoom) / 2;
      this.editor.canvas_x -= nodePosX - rect.width / 2;
      this.editor.canvas_y -= nodePosY - rect.height / 2;
      drawflowContainer.style.transform = `translate(${this.editor.canvas_x}px, ${this.editor.canvas_y}px) scale(${zoom})`;
      this.backgroundLastX = this.backgroundTranslateX;
      this.backgroundLastY = this.backgroundTranslateY;
      this.backgroundTranslateX -= nodePosX - rect.width / 2;
      this.backgroundTranslateY -= nodePosY - rect.height / 2;
      this.requestUpdate();
      setTimeout(() => {
        drawflowContainer.classList.remove("smooth-transition");
        this.drawflowEditorDiv.classList.remove("smooth-background-transition");
      }, 350);
      this.editorStore.setEditorPosition(
        this.editor.canvas_x,
        this.editor.canvas_y
      );
    }
  }
  /*
  
  
    */
  pasteNode() {
    const copiedNode = this.editorStore.copiedNode;
    if (copiedNode.id !== -1) {
      this.nodePasted = true;
      const titleCopy = `${copiedNode.data.title} copy`;
      switch (copiedNode.class) {
        case "page":
        case "origin":
          this.addPageNode(titleCopy, false);
          break;
        case "popup":
          this.addPopUpNode(titleCopy);
          break;
        case "branch":
          this.addBranchNode(titleCopy);
          break;
      }
    }
  }
  /*
  
  
    */
  _registerEditorEventHandlers() {
    this.editor.on("nodeSelected", (id3) => {
      this.dispatchEvent(
        new CustomEvent("nodeSelected", {
          detail: { nodeId: id3 },
          bubbles: true,
          composed: true
        })
      );
    });
    this.editor.on("nodeUnselected", (boolean) => {
      this.dispatchEvent(
        new CustomEvent("nodeUnselected", {
          bubbles: true,
          composed: true
        })
      );
    });
    this.editor.on("nodeCreated", (id3) => {
      this.editorStore.setEditorContent(this.editor.drawflow);
      let createdNode = this.editor.getNodeFromId(id3);
      if (this.nodePasted == false) {
        this.dispatchEvent(
          new CustomEvent("nodeCreated", {
            detail: { node: createdNode },
            bubbles: true,
            composed: true
          })
        );
      } else {
        this.nodePasted = false;
        this.dispatchEvent(
          new CustomEvent("nodePasted", {
            detail: { node: createdNode },
            bubbles: true,
            composed: true
          })
        );
      }
    });
    this.editor.on("nodeRemoved", (id3) => {
      this.dispatchEvent(
        new CustomEvent("nodeRemoved", {
          detail: { id: id3 },
          bubbles: true,
          composed: true
        })
      );
      this.editorStore.setEditorContent(this.editor.drawflow);
    });
    this.editor.on("nodeMoved", (id3) => {
      this.editorStore.setEditorContent(this.editor.drawflow);
    });
    this.editor.on("connectionStart", ({ output_id, output_class }) => {
      this.programaticallySelectNode(output_id);
      this.dispatchEvent(
        new CustomEvent("nodeSelected", {
          detail: { nodeId: output_id },
          bubbles: true,
          composed: true
        })
      );
      this.connectionStarted = true;
      this.shadowRoot.querySelector('svg[class="connection"]')?.querySelector("path")?.setAttribute("highlighted", "true");
    });
    this.editor.on("connectionCancel", () => {
      this.connectionStarted = false;
    });
    this.editor.on(
      "connectionSelected",
      ({ output_id, input_id, output_class, input_class }) => {
        const outputNode = this.editor.getNodeFromId(output_id);
        const inputNode = this.editor.getNodeFromId(input_id);
        this.selectedConnection = `${output_id}-${input_id}-${output_class}-${input_class}`;
        this.dispatchEvent(
          new CustomEvent("nodeSelected", {
            detail: { nodeId: output_id },
            bubbles: true,
            composed: true
          })
        );
        this._highlightConnection(
          output_id,
          input_id,
          output_class,
          input_class
        );
        this.dispatchEvent(
          new CustomEvent("connectionSelected", {
            detail: {
              outputNode,
              inputNode,
              outputClass: output_class,
              inputClass: input_class
            },
            bubbles: true,
            composed: true
          })
        );
      }
    );
    this.editor.on("connectionUnselected", (boolean) => {
      const parsedConnection = this.parseConnectionIdentifier(
        this.selectedConnection
      );
      this._unhighlightConnection(
        parsedConnection.outputNodeId,
        parsedConnection.inputNodeId,
        parsedConnection.outputClass,
        parsedConnection.inputClass
      );
      const outputNode = this.editor.getNodeFromId(
        parsedConnection.outputNodeId
      );
      const inputNode = this.editor.getNodeFromId(parsedConnection.inputNodeId);
      this.selectedConnection = NO_CONNECTION_SELECTED;
      this.dispatchEvent(
        new CustomEvent("connectionUnselected", {
          detail: {
            outputNode,
            inputNode,
            outputClass: parsedConnection.outputClass,
            inputClass: parsedConnection.inputClass
          },
          bubbles: true,
          composed: true
        })
      );
      this.dispatchEvent(
        new CustomEvent("nodeUnselected", {
          bubbles: true,
          composed: true
        })
      );
    });
    this.editor.on(
      "connectionCreated",
      ({ output_id, input_id, output_class, input_class }) => {
        this.connectionStarted = false;
        const outputNode = this.editor.getNodeFromId(output_id);
        const inputNode = this.editor.getNodeFromId(input_id);
        this.editorStore.setEditorContent(this.editor.drawflow);
        this.editorStore.setSelectedNode(this.editor.getNodeFromId(output_id));
        this.shadowRoot.querySelector(
          `svg.connection.node_in_node-${input_id}.node_out_node-${output_id}.${output_class}.${input_class}`
        )?.querySelector("path")?.removeAttribute("highlighted");
        const removeConnection = () => this.editor.removeSingleConnection(
          outputNode.id,
          inputNode.id,
          output_class,
          input_class
        );
        const triggerEvent = (eventName) => this.dispatchEvent(
          new CustomEvent(eventName, {
            detail: {
              outputNode,
              inputNode,
              outputClass: output_class,
              inputClass: input_class
            },
            bubbles: true,
            composed: true
          })
        );
        if (inputNode.class === "branch") {
          if (inputNode.inputs["input_1"]?.connections?.length > 1) {
            console.error("The branch node is already connected");
            removeConnection();
          } else if (outputNode.class === "branch") {
            console.error("Connecting branch nodes is not allowed.");
            removeConnection();
          } else {
            triggerEvent("nodeConnectedToBranchNode");
          }
        } else if (outputNode.class === "branch") {
          if (inputNode.id === Number(outputNode.inputs["input_1"]?.connections[0]?.node)) {
            console.error("Self loops are not allowed.");
            removeConnection();
          } else {
            triggerEvent("branchNodeConnected");
          }
        } else {
          triggerEvent("nodesConnected");
        }
      }
    );
    this.editor.on(
      "connectionRemoved",
      ({ output_id, input_id, output_class, input_class }) => {
        const outputNode = this.editor.getNodeFromId(output_id);
        const inputNode = this.editor.getNodeFromId(input_id);
        const isBranchInput = inputNode.class === "branch";
        const isBranchOutput = outputNode.class === "branch";
        this.editorStore.setEditorContent(this.editor.drawflow);
        if (this.selectedConnection !== NO_CONNECTION_SELECTED) {
          const { outputNodeId, inputNodeId, outputClass, inputClass } = this.parseConnectionIdentifier(this.selectedConnection);
          this._unhighlightConnection(
            outputNodeId,
            inputNodeId,
            outputClass,
            inputClass
          );
          this.selectedConnection = NO_CONNECTION_SELECTED;
        }
        if (isBranchOutput) {
          this.dispatchEvent(
            new CustomEvent("branchNodeConnectionRemoved", {
              detail: { outputNode, outputClass: output_class },
              bubbles: true,
              composed: true
            })
          );
        } else {
          const eventDetail = {
            outputNode,
            outputClass: output_class,
            inputNode,
            inputClass: input_class
          };
          this.dispatchEvent(
            new CustomEvent("connectionRemoved", {
              detail: eventDetail,
              bubbles: true,
              composed: true
            })
          );
        }
        this.editorStore.setSelectedNode(this.editor.getNodeFromId(output_id));
      }
    );
    this.editor.on("zoom", (zoom_level) => {
      this.onZoom(zoom_level, 0.2, this.editor.zoom_max);
      const range = this.editor.zoom_max - 0.2;
      const percentage = ((zoom_level - 0.2) / range * 100).toFixed(0);
      this.editorZoomString = percentage + "%";
      const zoomValue = this.shadowRoot.querySelector(
        ".zoomValue"
      );
      if (zoomValue) {
        zoomValue.classList.remove("fade-in-out");
        void zoomValue.offsetWidth;
        zoomValue.classList.add("fade-in-out");
      }
      this.editorStore.setEditorZoom(zoom_level);
      this.editorStore.setEditorPosition(
        this.editor.canvas_x,
        this.editor.canvas_y
      );
    });
  }
  /*
  
  
    */
  addPageNode(title, isOrigin) {
    const nodeData = {
      title
    };
    const nodeHTML = this.createPageNodeHTML(isOrigin);
    const editorDivCenterPos = this.getCenterOfEditorDiv();
    this.editor.addNode(
      title,
      1,
      1,
      editorDivCenterPos.centerX - 320 / 2,
      editorDivCenterPos.centerY - 109 / 2,
      isOrigin ? "origin" : "page",
      nodeData,
      nodeHTML,
      false
    );
  }
  /*
  
  
    */
  addPopUpNode(title) {
    const nodeData = {
      title
    };
    const nodeHTML = this.createPopupNodeHTML();
    const editorDivCenterPos = this.getCenterOfEditorDiv();
    this.editor.addNode(
      title,
      1,
      1,
      editorDivCenterPos.centerX - 320 / 2,
      editorDivCenterPos.centerY - 109 / 2,
      "popup",
      nodeData,
      nodeHTML,
      false
    );
  }
  /*
  
  
    */
  addBranchNode(title) {
    const nodeData = {
      title
    };
    const nodeHTML = this.createBranchNodeHTML();
    const editorDivCenterPos = this.getCenterOfEditorDiv();
    this.editor.addNode(
      title,
      1,
      0,
      editorDivCenterPos.centerX - 320 / 2,
      editorDivCenterPos.centerY - 109 / 2,
      "branch",
      nodeData,
      nodeHTML,
      false
    );
  }
  /*
  
  
    */
  getCenterOfEditorDiv() {
    const rect = this.drawflowEditorDiv.getBoundingClientRect();
    const zoom = this.editor.zoom;
    const centerX = rect.width / 2 - this.editor.canvas_x / zoom;
    const centerY = rect.height / 2 - this.editor.canvas_y / zoom;
    return { centerX, centerY };
  }
  /*
  
  
    */
  createPageNodeHTML(isOrigin) {
    const containerDiv = document.createElement("div");
    containerDiv.classList.add("container");
    const iconDiv = document.createElement("div");
    iconDiv.classList.add("iconDiv");
    const icon = document.createElement("sl-icon");
    icon.setAttribute("src", file_default);
    icon.classList.add("pageIcon");
    iconDiv.appendChild(icon);
    containerDiv.appendChild(iconDiv);
    const contentDiv = document.createElement("div");
    contentDiv.classList.add("content");
    const input = document.createElement("input");
    input.id = "title";
    input.setAttribute("df-title", "");
    contentDiv.appendChild(input);
    const nameLabel = document.createElement("p");
    if (isOrigin) {
      const badge = document.createElement("div");
      badge.classList.add("badge");
      const arrowIcon = document.createElement("sl-icon");
      arrowIcon.setAttribute("src", circle_arrow_right_default);
      badge.appendChild(arrowIcon);
      nameLabel.textContent = "Start Page";
      badge.appendChild(nameLabel);
      contentDiv.appendChild(badge);
    } else {
      nameLabel.classList.add("input-label");
      nameLabel.textContent = "Page";
      contentDiv.appendChild(nameLabel);
    }
    containerDiv.appendChild(contentDiv);
    const threeDotsIcon = document.createElement("sl-icon");
    threeDotsIcon.setAttribute("src", dots_vertical_default);
    threeDotsIcon.classList.add("threeDots");
    containerDiv.appendChild(threeDotsIcon);
    const containerHtml = containerDiv.outerHTML;
    return containerHtml;
  }
  /*
  
  
    */
  createPopupNodeHTML() {
    const containerDiv = document.createElement("div");
    containerDiv.classList.add("container");
    const iconDiv = document.createElement("div");
    iconDiv.classList.add("iconDiv");
    const icon = document.createElement("sl-icon");
    icon.setAttribute("src", squares_default2);
    icon.classList.add("pageIcon");
    iconDiv.appendChild(icon);
    containerDiv.appendChild(iconDiv);
    const contentDiv = document.createElement("div");
    contentDiv.classList.add("content");
    const input = document.createElement("input");
    input.id = "title";
    input.setAttribute("df-title", "");
    contentDiv.appendChild(input);
    const nameLabel = document.createElement("p");
    nameLabel.classList.add("input-label");
    nameLabel.textContent = "Popup";
    contentDiv.appendChild(nameLabel);
    containerDiv.appendChild(contentDiv);
    const threeDotsIcon = document.createElement("sl-icon");
    threeDotsIcon.setAttribute("src", dots_vertical_default);
    threeDotsIcon.classList.add("threeDots");
    containerDiv.appendChild(threeDotsIcon);
    const containerHtml = containerDiv.outerHTML;
    return containerHtml;
  }
  /*
  
  
    */
  createBranchNodeHTML() {
    const containerDiv = document.createElement("div");
    containerDiv.classList.add("container");
    const iconDiv = document.createElement("div");
    iconDiv.classList.add("iconDiv");
    const icon = document.createElement("sl-icon");
    icon.setAttribute("src", arrows_split_2_default);
    icon.classList.add("pageIcon");
    iconDiv.appendChild(icon);
    containerDiv.appendChild(iconDiv);
    const contentDiv = document.createElement("div");
    contentDiv.classList.add("content");
    const input = document.createElement("input");
    input.id = "title";
    input.setAttribute("df-title", "");
    contentDiv.appendChild(input);
    const nameLabel = document.createElement("p");
    nameLabel.classList.add("input-label");
    nameLabel.textContent = "Branch";
    contentDiv.appendChild(nameLabel);
    containerDiv.appendChild(contentDiv);
    const threeDotsIcon = document.createElement("sl-icon");
    threeDotsIcon.setAttribute("src", dots_vertical_default);
    threeDotsIcon.classList.add("threeDots");
    containerDiv.appendChild(threeDotsIcon);
    const containerHtml = containerDiv.outerHTML;
    return containerHtml;
  }
  /*
  
    */
  _highlightConnection(outputNodeId, inputNodeId, outputClass, inputClass) {
    const inputNodeClass = this.editor.getNodeFromId(inputNodeId).class;
    [
      ["output", outputNodeId, outputClass],
      ["input", inputNodeId, inputClass]
    ].forEach(([type, nodeId, cls]) => {
      const nodeDiv = this.shadowRoot?.getElementById(`node-${nodeId}`);
      if (nodeDiv) {
        nodeDiv.querySelector(`.${type}.${cls}`).setAttribute(`highlighted`, "true");
      }
    });
    this.shadowRoot.querySelector(
      `svg[class="connection node_in_node-${inputNodeId} node_out_node-${outputNodeId} ${outputClass} ${inputClass}"]`
    )?.querySelector("path")?.setAttribute(`highlighted`, "true");
  }
  /*
  
    */
  _unhighlightConnection(outputNodeId, inputNodeId, outputClass, inputClass) {
    const inputNodeClass = this.editor.getNodeFromId(inputNodeId).class;
    [
      ["output", outputNodeId, outputClass],
      ["input", inputNodeId, inputClass]
    ].forEach(([type, nodeId, cls]) => {
      const nodeDiv = this.shadowRoot?.getElementById(`node-${nodeId}`);
      if (nodeDiv) {
        nodeDiv.querySelector(`.${type}.${cls}`)?.removeAttribute("highlighted");
      }
    });
    this.shadowRoot.querySelector(
      `svg[class="connection node_in_node-${inputNodeId} node_out_node-${outputNodeId} ${outputClass} ${inputClass}"]`
    )?.querySelector("path")?.removeAttribute("highlighted");
  }
  /*
  
    */
  _highlightNode(nodeId) {
    const selector = `div#node-${nodeId}.drawflow-node`;
    this.shadowRoot.querySelector(selector)?.setAttribute("highlighted", "true");
  }
  /*
  
    */
  _unhighlightNode(nodeId) {
    const selector = `div#node-${nodeId}.drawflow-node`;
    this.shadowRoot.querySelector(selector)?.removeAttribute("highlighted");
  }
  /*
  
    */
  _highlightOutput(outputNodeId, outputClass) {
    [["output", outputNodeId, outputClass]].forEach(([type, nodeId, cls]) => {
      this.shadowRoot?.getElementById(`node-${nodeId}`)?.querySelector(`.${type}.${cls}`)?.setAttribute("highlighted", "true");
    });
  }
  /*
  
    */
  _unhighlightOutput(outputNodeId, outputClass) {
    [["output", outputNodeId, outputClass]].forEach(([type, nodeId, cls]) => {
      this.shadowRoot?.getElementById(`node-${nodeId}`)?.querySelector(`.${type}.${cls}`)?.removeAttribute("highlighted");
    });
  }
  unhighlightAllOutputs() {
    Array.from(this.nodeDivs).forEach((nodeDiv) => {
      const outputs = nodeDiv.querySelectorAll(".output");
      outputs.forEach((output) => {
        output.removeAttribute("highlighted");
      });
    });
  }
  /*
  
  
    */
  addTemplate(template) {
    var currentNodes = this.editor.export();
    let currentNodesWithHTML = this.addHTMLToNodes(currentNodes);
    let nodeTemplatesCopy = JSON.parse(JSON.stringify(template));
    const rect = this.drawflowEditorDiv.getBoundingClientRect();
    const zoom = this.editor.zoom;
    const centerX = rect.width / 2 - this.editor.canvas_x / zoom - 317 / 2;
    const centerY = rect.height / 2 - this.editor.canvas_y / zoom - 105 / 2;
    this.moveNodesToCenter(nodeTemplatesCopy, centerX, centerY);
    nodeTemplatesCopy = this.addHTMLToNodes(nodeTemplatesCopy);
    const mergedData = this.mergeTemplate(
      currentNodesWithHTML,
      nodeTemplatesCopy
    );
    this.editor.import(mergedData.currentNodes);
    this.editorStore.setEditorContent(this.editor.drawflow);
    this.dispatchEvent(
      new CustomEvent("nodeGroupImported", {
        detail: { templateContainers: mergedData.templateContainers },
        bubbles: true,
        composed: true
      })
    );
  }
  /*
  
  
    */
  moveNodesToCenter(nodeTemplate, targetCenterX, targetCenterY) {
    const data = nodeTemplate.drawflow.Home.data;
    const { centerX: currentCenterX, centerY: currentCenterY } = this.getCenterOfBoundingBox(nodeTemplate.drawflow.Home.data);
    const deltaX = targetCenterX - currentCenterX;
    const deltaY = targetCenterY - currentCenterY;
    Object.values(data).forEach((node) => {
      node.pos_x += deltaX;
      node.pos_y += deltaY;
    });
  }
  /*
  
  
    */
  getCenterOfBoundingBox(data) {
    const nodes = Object.values(data);
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    nodes.forEach((node) => {
      const { pos_x, pos_y } = node;
      if (pos_x < minX) minX = pos_x;
      if (pos_x > maxX) maxX = pos_x;
      if (pos_y < minY) minY = pos_y;
      if (pos_y > maxY) maxY = pos_y;
    });
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    return { centerX, centerY };
  }
  /*
  
  
    */
  mergeTemplate(currentNodes, nodeTemplates) {
    const currentData = currentNodes.drawflow.Home.data;
    const templateData = nodeTemplates.drawflow.Home.data;
    const currentMaxIndex = Math.max(...Object.keys(currentData).map(Number));
    let newIndex = currentMaxIndex + 1;
    const indexMap = Object.fromEntries(
      Object.keys(templateData).map((key) => [Number(key), newIndex++])
    );
    for (const [key, node] of Object.entries(templateData)) {
      const newId = indexMap[Number(key)];
      node.id = newId;
      for (const connections of Object.values(
        node.inputs
      ).concat(Object.values(node.outputs))) {
        for (const connection of connections.connections) {
          connection.node = indexMap[connection.node]?.toString() || connection.node;
        }
      }
      currentData[newId] = { ...node };
    }
    const templateContainers = nodeTemplates.containers;
    for (const container of templateContainers) {
      const drawflowNodeIdAttr = container.attributes.find(
        (attr) => attr.name === "drawflownodeid"
      );
      if (drawflowNodeIdAttr) {
        const oldId = Number(drawflowNodeIdAttr.value);
        drawflowNodeIdAttr.value = indexMap[oldId].toString();
      }
      const incomingContainerIdAttr = container.attributes.find(
        (attr) => attr.name === "incomingcontainerid"
      );
      if (incomingContainerIdAttr) {
        const oldId = Number(incomingContainerIdAttr.value);
        incomingContainerIdAttr.value = indexMap[oldId].toString();
      }
      const rulesAttr = container.attributes.find(
        (attr) => attr.name === "rules"
      );
      if (rulesAttr) {
        const rules = JSON.parse(rulesAttr.value);
        rules.forEach((rule) => {
          const oldId = Number(rule.target);
          rule.target = indexMap[oldId].toString();
        });
        rulesAttr.value = JSON.stringify(rules);
      }
      const elseRuleAttr = container.attributes.find(
        (attr) => attr.name === "elserule"
      );
      if (elseRuleAttr) {
        const elseRule = JSON.parse(elseRuleAttr.value);
        const oldId = Number(elseRule.target);
        elseRule.target = indexMap[oldId].toString();
        elseRuleAttr.value = JSON.stringify(elseRule);
      }
      const parser2 = new DOMParser();
      const doc = parser2.parseFromString(container.innerHTML, "text/html");
      const buttons = doc.querySelectorAll(
        "webwriter-gamebook-button, webwriter-gamebook-branch-button"
      );
      buttons.forEach((button) => {
        const dataTargetId = button.getAttribute("datatargetid");
        if (dataTargetId) {
          const oldTargetId = Number(dataTargetId);
          button.setAttribute("datatargetid", indexMap[oldTargetId].toString());
        }
        const identifier = button.getAttribute("identifier");
        if (identifier) {
          const identifierParts = identifier.split("-");
          if (identifierParts.length === 4) {
            const x4 = Number(identifierParts[0]);
            const y3 = Number(identifierParts[2]);
            const newX = indexMap[x4];
            const newY = indexMap[y3];
            const newIdentifier = `${newX}-output_1-${newY}-input_1`;
            button.setAttribute("identifier", newIdentifier);
          }
        }
      });
      container.innerHTML = doc.body.innerHTML;
    }
    return { currentNodes, templateContainers };
  }
  /*
  
    */
  parseConnectionIdentifier(identifier) {
    const parts = identifier.split("-");
    const parsed = {
      outputNodeId: parseInt(parts[0]),
      inputNodeId: parseInt(parts[1]),
      outputClass: parts[2],
      inputClass: parts[3]
    };
    return parsed;
  }
  /*
  
    */
  searchNodes(value) {
    let matchNodeIds = [];
    const nodes = this.editor.drawflow.drawflow.Home.data;
    Object.values(nodes).forEach((node) => {
      if (node.data.title.toLowerCase().includes(value.toLowerCase()) || node.class.toLowerCase().includes(value.toLowerCase())) {
        matchNodeIds = [...matchNodeIds, node.id];
      }
    });
    return matchNodeIds;
  }
  /*
  
    */
  highlightSearchedNodes(nodeIds) {
    const nodes = this.editor.drawflow.drawflow.Home.data;
    Object.values(nodes).forEach((node) => {
      if (nodeIds.includes(node.id)) {
        this.shadowRoot?.getElementById(`node-${node.id}`).setAttribute("searched", "true");
      } else {
        this.shadowRoot?.getElementById(`node-${node.id}`).removeAttribute("searched");
      }
    });
  }
  /*
  
  
  */
  removeSearchHighlightFromAllNodes() {
    const nodes = this.editor.drawflow.drawflow.Home.data;
    Object.values(nodes).forEach((node) => {
      this.shadowRoot?.getElementById(`node-${node.id}`).removeAttribute("searched");
    });
  }
  /*
  
  
  */
  makeNodeOrigin(nodeId) {
    let originNodeId = -1;
    Object.values(this.editor.drawflow.drawflow.Home.data).forEach((node) => {
      if (node.class == "origin") {
        const originNodeDiv = this.shadowRoot?.getElementById(
          `node-${node.id}`
        );
        originNodeId = node.id;
        const badgeElement = originNodeDiv.querySelector(".badge");
        badgeElement.remove();
        const originNodeContentDiv = originNodeDiv.querySelector(".content");
        const nameLabel = document.createElement("p");
        nameLabel.classList.add("input-label");
        nameLabel.textContent = "Page";
        originNodeContentDiv.appendChild(nameLabel);
        originNodeDiv.classList.remove("origin");
        originNodeDiv.classList.add("page");
        node.html = originNodeDiv.querySelector(".container").outerHTML;
        node.class = "page";
      }
      if (node.id == nodeId) {
        const nodeDiv = this.shadowRoot?.getElementById(`node-${nodeId}`);
        if (nodeDiv) {
          const inputLabelElement = nodeDiv.querySelector(".input-label");
          if (inputLabelElement) {
            inputLabelElement.remove();
            const contentDiv = nodeDiv.querySelector(".content");
            const badge = document.createElement("div");
            badge.classList.add("badge");
            const arrowIcon = document.createElement("sl-icon");
            arrowIcon.setAttribute("src", circle_arrow_right_default);
            badge.appendChild(arrowIcon);
            const nameLabel = document.createElement("p");
            nameLabel.textContent = "Start Page";
            badge.appendChild(nameLabel);
            contentDiv.appendChild(badge);
            nodeDiv.classList.remove("page");
            nodeDiv.classList.add("origin");
          }
        }
        node.html = nodeDiv.querySelector(".container").outerHTML;
        node.class = "origin";
      }
    });
    this.requestUpdate();
  }
  /*
  
  
    */
  deleteSelectedNode() {
    this.editor.removeNodeId(`node-${this.editorStore.selectedNode.id}`);
    this.shadowRoot.getElementById("delete_node_dialog").hide();
  }
  /*
  
  
    */
  programaticallySelectNode(id3) {
    this.nodeDivs.forEach((nodeDiv2) => {
      nodeDiv2.classList.remove("selected");
    });
    let nodeDiv = Array.from(this.nodeDivs).find(
      (nodeDiv2) => {
        return parseInt(nodeDiv2.id.split("-")[1], 10).toString() === id3.toString();
      }
    );
    nodeDiv.classList.add("selected");
    this.editor.node_selected = nodeDiv;
  }
  /*
  
  
    */
  programaticallyUnselectConnection() {
    if (this.selectedConnection !== NO_CONNECTION_SELECTED) {
      const parsedConnection = this.parseConnectionIdentifier(
        this.selectedConnection
      );
      const deleteButton = this.shadowRoot.querySelector(".drawflow-delete");
      deleteButton.remove();
      this.editor.connection_selected = null;
      this.editor.ele_selected = null;
    }
  }
};
_init21 = __decoratorStart(_a21);
_editor = new WeakMap();
_editorZoomString = new WeakMap();
_selectedConnection = new WeakMap();
_connectionStarted = new WeakMap();
_backgroundIsDragging = new WeakMap();
_backgroundLastX = new WeakMap();
_backgroundLastY = new WeakMap();
_backgroundTranslateX = new WeakMap();
_backgroundTranslateY = new WeakMap();
_backgroundScale = new WeakMap();
_backgroundMinScale = new WeakMap();
_backgroundMaxScale = new WeakMap();
_backgroundScaleFactor = new WeakMap();
_nodePasted = new WeakMap();
_drawflowEditorDiv = new WeakMap();
_nodeDivs = new WeakMap();
_editorStore10 = new WeakMap();
__decorateElement(_init21, 4, "editor", _editor_dec, NodeEditor, _editor);
__decorateElement(_init21, 4, "editorZoomString", _editorZoomString_dec, NodeEditor, _editorZoomString);
__decorateElement(_init21, 4, "selectedConnection", _selectedConnection_dec, NodeEditor, _selectedConnection);
__decorateElement(_init21, 4, "connectionStarted", _connectionStarted_dec, NodeEditor, _connectionStarted);
__decorateElement(_init21, 4, "backgroundIsDragging", _backgroundIsDragging_dec, NodeEditor, _backgroundIsDragging);
__decorateElement(_init21, 4, "backgroundLastX", _backgroundLastX_dec, NodeEditor, _backgroundLastX);
__decorateElement(_init21, 4, "backgroundLastY", _backgroundLastY_dec, NodeEditor, _backgroundLastY);
__decorateElement(_init21, 4, "backgroundTranslateX", _backgroundTranslateX_dec, NodeEditor, _backgroundTranslateX);
__decorateElement(_init21, 4, "backgroundTranslateY", _backgroundTranslateY_dec, NodeEditor, _backgroundTranslateY);
__decorateElement(_init21, 4, "backgroundScale", _backgroundScale_dec, NodeEditor, _backgroundScale);
__decorateElement(_init21, 4, "backgroundMinScale", _backgroundMinScale_dec, NodeEditor, _backgroundMinScale);
__decorateElement(_init21, 4, "backgroundMaxScale", _backgroundMaxScale_dec, NodeEditor, _backgroundMaxScale);
__decorateElement(_init21, 4, "backgroundScaleFactor", _backgroundScaleFactor_dec, NodeEditor, _backgroundScaleFactor);
__decorateElement(_init21, 4, "nodePasted", _nodePasted_dec, NodeEditor, _nodePasted);
__decorateElement(_init21, 4, "drawflowEditorDiv", _drawflowEditorDiv_dec, NodeEditor, _drawflowEditorDiv);
__decorateElement(_init21, 4, "nodeDivs", _nodeDivs_dec, NodeEditor, _nodeDivs);
__decorateElement(_init21, 4, "editorStore", _editorStore_dec10, NodeEditor, _editorStore10);
NodeEditor = __decorateElement(_init21, 0, "NodeEditor", _NodeEditor_decorators, NodeEditor);
// Import CSS
__publicField(NodeEditor, "styles", [
  style,
  node_editor_styles_default,
  drawflow_styles_default,
  i`
      #drawflowEditorDiv {
        background-image: radial-gradient(
          circle,
          #dedede,
          1px,
          transparent 1px
        );
        background-size: ${GRID_SIZE}px ${GRID_SIZE}px;
        background-color: #fbfbfb;
        overflow: hidden;
        cursor: grab;
      }
      #drawflowEditorDiv:active {
        cursor: grabbing;
      }
    `
]);
__runInitializers(_init21, 1, NodeEditor);

// src/node_modules/@tabler/icons/icons/outline/arrow-bar-to-up.svg
var arrow_bar_to_up_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-arrow-bar-to-up"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M12 10l0 10" />%0A  <path d="M12 10l4 4" />%0A  <path d="M12 10l-4 4" />%0A  <path d="M4 4l16 0" />%0A</svg>';

// src/node_modules/@tabler/icons/icons/outline/arrow-bar-to-down.svg
var arrow_bar_to_down_default = 'data:image/svg+xml,<svg%0A  xmlns="http://www.w3.org/2000/svg"%0A  width="24"%0A  height="24"%0A  viewBox="0 0 24 24"%0A  fill="none"%0A  stroke="currentColor"%0A  stroke-width="2"%0A  stroke-linecap="round"%0A  stroke-linejoin="round"%0A  class="icon icon-tabler icons-tabler-outline icon-tabler-arrow-bar-to-down"%0A>%0A  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>%0A  <path d="M4 20l16 0" />%0A  <path d="M12 14l0 -10" />%0A  <path d="M12 14l4 -4" />%0A  <path d="M12 14l-4 -4" />%0A</svg>';

// src/components/split-view/split-view.ts
var DIVIDER_HEIGHT = 30;
var _editorStore_dec11, _previousHeight_dec, _startHeight_dec, _initialY_dec, _isDragging_dec, _maxStart_dec, _minStart_dec, _a22, _SplitView_decorators, _init22, _minStart, _maxStart, _isDragging, _initialY, _startHeight, _previousHeight, _editorStore11;
_SplitView_decorators = [t4("split-view")];
var SplitView = class extends (_a22 = LitElementWw, _minStart_dec = [n6({ type: Number, attribute: true, reflect: true })], _maxStart_dec = [n6({ type: Number, attribute: true, reflect: true })], _isDragging_dec = [r5()], _initialY_dec = [r5()], _startHeight_dec = [r5()], _previousHeight_dec = [r5()], _editorStore_dec11 = [c4({ context: editorState, subscribe: true }), n6({ type: Object, attribute: true, reflect: false })], _a22) {
  constructor() {
    super(...arguments);
    __privateAdd(this, _minStart, __runInitializers(_init22, 8, this, 230)), __runInitializers(_init22, 11, this);
    __privateAdd(this, _maxStart, __runInitializers(_init22, 12, this, 350)), __runInitializers(_init22, 15, this);
    __privateAdd(this, _isDragging, __runInitializers(_init22, 16, this, false)), __runInitializers(_init22, 19, this);
    __privateAdd(this, _initialY, __runInitializers(_init22, 20, this, 0)), __runInitializers(_init22, 23, this);
    __privateAdd(this, _startHeight, __runInitializers(_init22, 24, this, 0)), __runInitializers(_init22, 27, this);
    __privateAdd(this, _previousHeight, __runInitializers(_init22, 28, this, 350)), __runInitializers(_init22, 31, this);
    __privateAdd(this, _editorStore11, __runInitializers(_init22, 32, this, new GamebookEditorState("Default"))), __runInitializers(_init22, 35, this);
  }
  // Registering custom elements used in the widget
  static get scopedElements() {
    return {
      "sl-input": input_default,
      "sl-icon": icon_default,
      "sl-icon-button": icon_button_default
    };
  }
  static get styles() {
    return i`
      :host {
        box-sizing: border-box;

        width: 100%;
      }

      :host * {
        box-sizing: border-box;
      }

      .splitPanel {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
      }

      .itemStart {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
      }

      .itemStart.collapsed,
      .itemStart.expanded {
        transition: height 0.3s ease; /* Smooth animation for collapse/expand */
      }

      .itemEnd {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: fit-content;
        flex-shrink: 0;
        box-sizing: border-box;
      }

      .divider {
        position: relative;
        cursor: row-resize;
        display: flex;
        align-items: center;
        justify-content: center; /* Center the grip icon */
        height: ${DIVIDER_HEIGHT}px;
        flex-shrink: 0;
        box-sizing: border-box;
        border-top: 1px solid #e4e4e7;
        border-bottom: 1px solid #e4e4e7;
      }

      .collapse-button {
        position: absolute;
        right: 10px; /* Position the button on the right side */
      }

      .icon {
        color: #52525b;
      }
      .dragging {
        color: #0084c7;
      }
    `;
  }
  /*
  
  */
  firstUpdated(_changedProperties) {
    this.updateComplete.then(() => {
      const splitPanel = this.shadowRoot.querySelector(
        ".splitPanel"
      );
      const itemStart = this.shadowRoot.querySelector(
        ".itemStart"
      );
      itemStart.style.height = `${this.editorStore.dividerPosition}px`;
      const initialSplitPanelHeight = this.editorStore.dividerPosition + this.itemEndHeight() + DIVIDER_HEIGHT;
      splitPanel.style.height = `${initialSplitPanelHeight}px`;
      const itemEnd = this.shadowRoot.querySelector(".itemEnd");
      const resizeObserver = new ResizeObserver(() => {
        this.adjustSplitPanelHeight();
      });
      resizeObserver.observe(itemEnd);
    });
  }
  /*
  
  */
  onMouseDown(event) {
    if (this.editorStore.editorIsCollapsed) return;
    this.isDragging = true;
    this.initialY = event.clientY;
    const itemStart = this.shadowRoot.querySelector(
      ".itemStart"
    );
    this.startHeight = itemStart.getBoundingClientRect().height;
    itemStart.classList.remove("collapsed", "expanded");
    this.addEventListener("mousemove", this.onMouseMove);
    this.addEventListener("mouseup", this.onMouseUp);
  }
  onMouseUp(_event) {
    this.isDragging = false;
    this.removeEventListener("mousemove", this.onMouseMove);
    this.removeEventListener("mouseup", this.onMouseUp);
  }
  /*
  
  */
  onMouseMove(event) {
    if (!this.isDragging) return;
    const deltaY = event.clientY - this.initialY;
    let newHeight = this.startHeight + deltaY;
    newHeight = Math.max(this.minStart, Math.min(newHeight, this.maxStart));
    const itemStart = this.shadowRoot.querySelector(
      ".itemStart"
    );
    const splitPanel = this.shadowRoot.querySelector(
      ".splitPanel"
    );
    itemStart.style.height = `${newHeight}px`;
    const totalHeight = newHeight + this.itemEndHeight() + DIVIDER_HEIGHT;
    splitPanel.style.height = `${totalHeight}px`;
    this.editorStore.setDividerPosition(newHeight);
  }
  /*
  
  */
  itemEndHeight() {
    const itemEnd = this.shadowRoot.querySelector(".itemEnd");
    return itemEnd ? itemEnd.getBoundingClientRect().height : 0;
  }
  /*
  
  */
  adjustSplitPanelHeight() {
    const splitPanel = this.shadowRoot.querySelector(
      ".splitPanel"
    );
    const newTotalHeight = this.editorStore.dividerPosition + this.itemEndHeight() + DIVIDER_HEIGHT;
    splitPanel.style.height = `${newTotalHeight}px`;
  }
  /*
  
  */
  toggleCollapse() {
    const itemStart = this.shadowRoot.querySelector(
      ".itemStart"
    );
    if (this.editorStore.editorIsCollapsed) {
      itemStart.classList.remove("collapsed");
      itemStart.classList.add("expanded");
      itemStart.style.height = `${this.previousHeight}px`;
      this.editorStore.setDividerPosition(this.previousHeight);
    } else {
      this.previousHeight = this.editorStore.dividerPosition;
      itemStart.classList.remove("expanded");
      itemStart.classList.add("collapsed");
      itemStart.style.height = `0px`;
      this.editorStore.setDividerPosition(0);
    }
    this.editorStore.setEditorIsCollapsed(!this.editorStore.editorIsCollapsed);
    this.adjustSplitPanelHeight();
  }
  /*
  
  */
  render() {
    return ke`
      <div class="splitPanel">
        <div class="itemStart"><slot name="start"></slot></div>
        <div class="divider" @mousedown=${this.onMouseDown}>
          <sl-icon
            src=${grip_horizontal_default}
            class="${this.isDragging ? "dragging" : "icon"}"
          ></sl-icon>
          <sl-icon-button
            class="collapse-button"
            @click=${this.toggleCollapse}
            src=${this.editorStore.editorIsCollapsed ? arrow_bar_to_down_default : arrow_bar_to_up_default}
          >
          </sl-icon-button>
        </div>
        <div class="itemEnd"><slot name="end"></slot></div>
      </div>
    `;
  }
};
_init22 = __decoratorStart(_a22);
_minStart = new WeakMap();
_maxStart = new WeakMap();
_isDragging = new WeakMap();
_initialY = new WeakMap();
_startHeight = new WeakMap();
_previousHeight = new WeakMap();
_editorStore11 = new WeakMap();
__decorateElement(_init22, 4, "minStart", _minStart_dec, SplitView, _minStart);
__decorateElement(_init22, 4, "maxStart", _maxStart_dec, SplitView, _maxStart);
__decorateElement(_init22, 4, "isDragging", _isDragging_dec, SplitView, _isDragging);
__decorateElement(_init22, 4, "initialY", _initialY_dec, SplitView, _initialY);
__decorateElement(_init22, 4, "startHeight", _startHeight_dec, SplitView, _startHeight);
__decorateElement(_init22, 4, "previousHeight", _previousHeight_dec, SplitView, _previousHeight);
__decorateElement(_init22, 4, "editorStore", _editorStore_dec11, SplitView, _editorStore11);
SplitView = __decorateElement(_init22, 0, "SplitView", _SplitView_decorators, SplitView);
__runInitializers(_init22, 1, SplitView);

// src/widgets/webwriter-branching-scenario.styles.ts
var webwriter_branching_scenario_styles_default = i`
  :host {
    width: 100%;
    height: fit-content;
    box-sizing: border-box;

    overflow: hidden;
    display: flex;
  }

  :host([contenteditable="true"]),
  :host([contenteditable=""]) {
    border: 1px solid #e4e4e4;
  }

  :host * {
    box-sizing: border-box;
  }

  sl-split-panel {
    height: auto; /* Allow height to be determined by content */
  }

  sl-split-panel sl-icon {
    color: darkgray;
  }

  sl-split-panel::part(divider) {
    z-index: 0;
    border-top: 1px solid #e4e4e4;
    box-sizing: border-box;
    background: white;
  }

  sl-dialog::part(base) {
    position: absolute;
  }

  sl-dialog::part(overlay) {
    position: absolute;
  }
`;

// src/utils/gamebook-editor-controller.ts
var GamebookEditorController = class {
  host;
  nodeEditor;
  gamebookContainerManager;
  mutationObserver;
  /*
  
    */
  constructor(host) {
    this.host = host;
    host.addController(this);
  }
  // Initialize child references
  initReferences(nodeEditor, gamebookContainerManager) {
    this.nodeEditor = nodeEditor;
    this.gamebookContainerManager = gamebookContainerManager;
  }
  /*
  
    */
  hostConnected() {
    this.mutationObserver = new MutationObserver(
      this.monitorHostUserContainerDeletion
    );
    const config = {
      attributes: true,
      childList: true,
      subtree: false,
      characterData: false
    };
    this.mutationObserver.observe(this.host, config);
  }
  /*
  
    */
  hostDisconnected() {
  }
  /*
  
    */
  _selectContainer = (id3) => {
    const node = this.nodeEditor.editor.getNodeFromId(id3);
    const container = this.gamebookContainerManager._getContainerByDrawflowNodeId(Number(id3));
    if (container) {
      this.gamebookContainerManager._showGamebookContainerById(
        container.drawflowNodeId
      );
      this.host.editorState.setSelectedContainer(container);
      if (node.class === "branch" && container instanceof WebWriterGamebookBranch) {
        if (container.incomingContainerId !== -1) {
          const incomingContainer = this.gamebookContainerManager._getContainerByDrawflowNodeId(
            container.incomingContainerId
          );
          if (incomingContainer) {
            this.host.editorState.setBranchIncomingContainer(
              incomingContainer
            );
            this.host.editorState.setSelectedNode(node);
          }
        } else {
          this.host.editorState.setSelectedNode(node);
        }
      } else {
        this.host.editorState.setSelectedNode(node);
      }
    } else {
      this._unselectContainer();
    }
    this.nodeEditor.unhighlightAllOutputs();
    this.host.focus();
    this.host.requestUpdate();
  };
  /*
  
    */
  _unselectContainer = () => {
    this.host.editorState.setSelectedNode();
    this.gamebookContainerManager._hideAllGamebookContainers();
    this.host.editorState.setSelectedContainer();
    this.host.editorState.setBranchIncomingContainer();
    this.nodeEditor.unhighlightAllOutputs();
    this.host.requestUpdate();
  };
  /*
  
    */
  _renameSelectedNode = (title) => {
    const selectedNode = this.host.editorState.selectedNode;
    this.nodeEditor.editor.updateNodeDataFromId(selectedNode.id, {
      ...selectedNode.data,
      title
    });
    this.gamebookContainerManager._renameContainer(selectedNode.id, title);
    this.host.editorState.setEditorContent(
      this.nodeEditor.editor.drawflow
    );
    this.host.editorState.setSelectedNode(
      this.nodeEditor.editor.getNodeFromId(selectedNode.id)
    );
    this.host.requestUpdate();
  };
  /*
  
    */
  _createConnection = (event) => {
    event.stopPropagation();
    const selectedNodeId = this.host.editorState.selectedNode.id;
    this.nodeEditor.editor.addConnection(
      event.detail.outputNodeId,
      event.detail.inputNodeId,
      event.detail.outputClass,
      event.detail.inputClass
    );
    this.host.editorState.setSelectedNode(
      this.nodeEditor.editor.getNodeFromId(selectedNodeId)
    );
    this._markUsedOutputs();
    this.host.requestUpdate();
  };
  /*
  
    */
  _deleteConnection = (event) => {
    event.stopPropagation();
    this.nodeEditor.programaticallyUnselectConnection();
    const selectedNodeId = this.host.editorState.selectedNode.id;
    this.nodeEditor.editor.removeSingleConnection(
      event.detail.outputNodeId,
      event.detail.inputNodeId,
      event.detail.outputClass,
      "input_1"
    );
    this.host.editorState.setSelectedNode(
      this.nodeEditor.editor.getNodeFromId(selectedNodeId)
    );
    this._markUsedOutputs();
    this.host.requestUpdate();
  };
  /*
  
    */
  _createContainerForNode = (node) => {
    this.host.focus();
    const container = this.gamebookContainerManager.createContainerFromNode(node);
    this.host.appendChild(container);
    this._markUsedOutputs();
    this.host.requestUpdate();
    this.host.focus();
  };
  /* 
  
  
  */
  _deleteSelectedNode = () => {
    this.nodeEditor.shadowRoot.getElementById("delete_node_dialog").show();
  };
  /*
  
    */
  _copyAndPasteContainer = (pastedNode) => {
    this.host.focus();
    const pastedContainer = this.gamebookContainerManager.copyAndPasteContainerContents(pastedNode);
    this.host.appendChild(pastedContainer);
    this._markUsedOutputs();
    this.host.requestUpdate();
  };
  /*
  
    */
  _pasteNode = () => {
    this.nodeEditor.pasteNode();
    this.host.requestUpdate();
  };
  /*
  
    */
  _removeContainer = (id3) => {
    this.host.focus();
    this._markUsedOutputs();
    this.gamebookContainerManager._deleteGamebookContainersById(id3);
    this.host.requestUpdate();
  };
  /*
  
    */
  _removeNode = (id3) => {
    this.host.focus();
    this.nodeEditor.editor.removeNodeId(`node-${id3}`);
    this._unselectContainer();
    this.host.requestUpdate();
  };
  /*
  
    */
  _addSmartBranchButton = (event) => {
    this.gamebookContainerManager.addSmartBranchButtonToContainer(
      event.detail.outputNode,
      event.detail.inputNode,
      event.detail.outputClass,
      event.detail.inputClass
    );
    this._markUsedOutputs();
    this.host.requestUpdate();
  };
  /*
  
    */
  _addConnectionButton = (event) => {
    this.gamebookContainerManager.addConnectionButtonToContainer(
      event.detail.outputNode,
      event.detail.inputNode,
      event.detail.outputClass,
      event.detail.inputClass
    );
    this._markUsedOutputs();
    this.host.requestUpdate();
  };
  /*
  
    */
  _branchNodeConnected = (event) => {
    this.gamebookContainerManager.updateBranchContainerRuleTarget(
      event.detail.outputNode.id,
      event.detail.outputClass,
      event.detail.inputNode.id
    );
    this._markUsedOutputs();
    this.host.requestUpdate();
  };
  /*
  
    */
  _outputBranchNodeConnectionRemove = (event) => {
    const selectedNodeId = this.host.editorState.selectedNode.id;
    this.gamebookContainerManager.updateBranchContainerRuleTarget(
      event.detail.outputNode.id,
      event.detail.outputClass,
      ""
    );
    this._markUsedOutputs();
    this.host.editorState.setSelectedNode(
      this.nodeEditor.editor.getNodeFromId(selectedNodeId)
    );
    this.host.requestUpdate();
  };
  /*
  
    */
  _deleteBranchRuleElementAndConnection = (event) => {
    const removeConnectionsFromOutputs = this.gamebookContainerManager.removeBranchContainerRuleElements(
      event.detail.containerId,
      event.detail.id,
      event.detail.isQuiz
    );
    for (let outputTargetTuple of removeConnectionsFromOutputs) {
      this.nodeEditor.editor.removeSingleConnection(
        event.detail.containerId,
        outputTargetTuple[1],
        outputTargetTuple[0],
        "input_1"
      );
    }
    this.host.requestUpdate();
  };
  /*
  
    */
  _removeButton = (event) => {
    this.gamebookContainerManager.removeButtonFromContainer(
      event.detail.outputNode.id,
      event.detail.inputNode.id,
      event.detail.outputClass,
      event.detail.inputClass
    );
    if (this.host.editorState.selectedNode.id === event.detail.inputNode.id) {
      this._selectContainer(event.detail.inputNode.id);
    } else if (this.host.editorState.selectedNode.id === event.detail.outputNode.id) {
      this._selectContainer(event.detail.outputNode.id);
    }
    this._markUsedOutputs();
    this.host.requestUpdate();
  };
  /*
  
    */
  _removeConnection = (event) => {
    const selectedNodeId = this.host.editorState.selectedNode.id;
    const identifier = event.detail.identifier;
    const parsed = this.parseConnectionIdentifier(identifier);
    this.nodeEditor.programaticallyUnselectConnection();
    this.nodeEditor.editor.removeSingleConnection(
      parsed.outputNodeId,
      parsed.inputNodeId,
      parsed.outputClass,
      parsed.inputClass
    );
    const inputNode = this.nodeEditor.editor.getNodeFromId(parsed.inputNodeId);
    if (inputNode.class === "branch") {
      const branchContainer = this.gamebookContainerManager._getContainerByDrawflowNodeId(
        parsed.inputNodeId
      );
      const incomingContainer = this.gamebookContainerManager._getContainerByDrawflowNodeId(
        branchContainer.incomingContainerId
      );
      incomingContainer.branchesOff = -1;
      branchContainer.incomingContainerId = -1;
      branchContainer.clearRules();
    }
    this.host.editorState.setSelectedNode(
      this.nodeEditor.editor.getNodeFromId(selectedNodeId)
    );
    this.host.requestUpdate();
  };
  /*
  
    */
  _editorCleared = () => {
    this.gamebookContainerManager._deleteAllGamebookContainers();
    this._unselectContainer();
    this._markUsedOutputs();
    this.host.requestUpdate();
  };
  /*
  
    */
  _selectConnectionButton = (event) => {
    const identifier = `${event.detail.outputNode.id}-${event.detail.outputClass}-${event.detail.inputNode.id}-${event.detail.inputClass}`;
    this.gamebookContainerManager.selectButtonInContainer(
      this.host.editorState.selectedNode.id,
      identifier
    );
    this.host.requestUpdate();
  };
  /*
  
    */
  _unselectConnectionButton = (event) => {
    this.host.requestUpdate();
  };
  /* 
  
  */
  _importTemplateContainers = (event) => {
    const containers = this.gamebookContainerManager.importContainers(
      event.detail.templateContainers
    );
    containers.forEach((container) => {
      this.host.appendChild(container);
    });
    this._markUsedOutputs();
    this.host.requestUpdate();
  };
  /* 
  
  */
  _changeOrigin = (event) => {
    this.nodeEditor.makeNodeOrigin(event.detail.newId);
    this.gamebookContainerManager.changeOrigin(event.detail.newId);
    this.host.editorState.setEditorContent(
      this.nodeEditor.editor.drawflow
    );
    this.host.editorState.setSelectedNode(
      this.nodeEditor.editor.getNodeFromId(
        this.host.editorState.selectedNode.id
      )
    );
    this.host.requestUpdate();
  };
  /* 
  
  */
  _deleteOutput = (event) => {
    event.stopPropagation();
    this.nodeEditor.programaticallyUnselectConnection();
    this.nodeEditor.editor.removeNodeOutput(
      event.detail.nodeId,
      event.detail.outputClass
    );
    const selectedNodeId = this.host.editorState.selectedNode.id;
    this.host.editorState.setSelectedNode(
      this.nodeEditor.editor.getNodeFromId(selectedNodeId)
    );
    this.gamebookContainerManager.updateButtonIdsAfterOutputRemove(
      event.detail.nodeId,
      event.detail.outputClass
    );
    this.host.editorState.setEditorContent(
      this.nodeEditor.editor.drawflow
    );
    this._markUsedOutputs();
    this.host.requestUpdate();
  };
  /* 
  
  */
  _addOutput = (event) => {
    event.stopPropagation();
    this.nodeEditor.editor.addNodeOutput(event.detail.nodeId);
    this.host.editorState.setEditorContent(
      this.nodeEditor.editor.drawflow
    );
    const selectedNodeId = this.host.editorState.selectedNode.id;
    this.host.editorState.setSelectedNode(
      this.nodeEditor.editor.getNodeFromId(selectedNodeId)
    );
    this._markUsedOutputs();
    this.host.requestUpdate();
  };
  /* 
  
  */
  _highlightConnection = (event) => {
    const {
      outputNodeId,
      inputNodeId,
      outputClass,
      inputClass,
      highlightButton
    } = event.detail;
    if (outputNodeId !== void 0 && inputNodeId !== void 0 && outputClass !== void 0 && inputClass !== void 0) {
      this.nodeEditor._highlightConnection(
        outputNodeId,
        inputNodeId,
        outputClass,
        inputClass
      );
      const identifier = `${outputNodeId}-${outputClass}-${inputNodeId}-${inputClass}`;
      if (highlightButton) {
        this.gamebookContainerManager.highlightButtonInContainer(
          outputNodeId,
          identifier
        );
      }
    }
  };
  /* 
  
  */
  _unhighlightConnection = (event) => {
    const {
      outputNodeId,
      inputNodeId,
      outputClass,
      inputClass,
      highlightButton
    } = event.detail;
    if (outputNodeId !== void 0 && inputNodeId !== void 0 && outputClass !== void 0 && inputClass !== void 0) {
      this.nodeEditor._unhighlightConnection(
        outputNodeId,
        inputNodeId,
        outputClass,
        inputClass
      );
      const identifier = `${outputNodeId}-${outputClass}-${inputNodeId}-${inputClass}`;
      if (highlightButton) {
        this.gamebookContainerManager.unhighlightButtonInContainer(
          outputNodeId,
          identifier
        );
      }
    }
  };
  /* 
  
  */
  _highlightOutput = (event) => {
    const { outputNodeId, outputClass } = event.detail;
    if (outputNodeId !== void 0 && outputClass !== void 0) {
      this.nodeEditor._highlightOutput(outputNodeId, outputClass);
    }
  };
  /* 
  
  */
  _unhighlightOutput = (event) => {
    const { outputNodeId, outputClass } = event.detail;
    if (outputNodeId !== void 0 && outputClass !== void 0) {
      this.nodeEditor._unhighlightOutput(outputNodeId, outputClass);
    }
  };
  /* 
  
  */
  _highlightNode = (event) => {
    const { nodeId } = event.detail;
    if (nodeId !== void 0) {
      this.nodeEditor._highlightNode(nodeId);
    }
  };
  /* 
  
  */
  _unhighlightNode = (event) => {
    const { nodeId } = event.detail;
    if (nodeId !== void 0) {
      this.nodeEditor._unhighlightNode(nodeId);
    }
  };
  /*
  
    */
  monitorHostUserContainerDeletion = (mutationList) => {
    mutationList.forEach((mutation) => {
      if (mutation.type === "childList") {
        mutation.removedNodes.forEach((node) => {
          const nodeName = node.nodeName.toLowerCase();
          const isWidget = node.classList.contains(
            "ww-widget"
          );
          const isSelectedNode = node.classList.contains(
            "ProseMirror-selectednode"
          );
          if (isWidget && isSelectedNode) {
            const containerDeletedEvent = (container) => {
              this.gamebookContainerManager._notifyContainerGotDeleted(
                Number(container.drawflowNodeId)
              );
            };
            if (nodeName === "webwriter-gamebook-page") {
              const container = node;
              containerDeletedEvent(container);
              if (container.originPage === 1) {
                this.nodeEditor.addPageNode("First Page", true);
              }
              if (container.branchesOff !== -1) {
                const branchContainer = this.gamebookContainerManager._getContainerByDrawflowNodeId(
                  container.branchesOff
                );
                branchContainer.incomingContainerId = -1;
                branchContainer.clearRules();
              }
            } else if (nodeName === "webwriter-gamebook-popup") {
              const container = node;
              containerDeletedEvent(container);
              if (container.branchesOff !== -1) {
                const branchContainer = this.gamebookContainerManager._getContainerByDrawflowNodeId(
                  container.branchesOff
                );
                branchContainer.incomingContainerId = -1;
                branchContainer.clearRules();
              }
            } else if (nodeName === "webwriter-gamebook-branch") {
              const container = node;
              containerDeletedEvent(container);
            }
          }
        });
      }
    });
  };
  /*
  
    */
  parseConnectionIdentifier(identifier) {
    const parts = identifier.split("-");
    const parsed = {
      outputNodeId: parseInt(parts[0]),
      outputClass: parts[1],
      inputNodeId: parseInt(parts[2]),
      inputClass: parts[3]
    };
    return parsed;
  }
  /*
  
  
    */
  _markUsedOutputs() {
    const nodes = this.host.editorState.editorContent.drawflow.Home.data;
    Object.values(nodes).forEach((node) => {
      if (node.class == "branch") {
        if (this.gamebookContainerManager.gamebookContainers.length !== 0) {
          const branchContainer = this.gamebookContainerManager._getContainerByDrawflowNodeId(
            node.id
          );
          if (branchContainer) {
            branchContainer.rules.forEach((rule) => {
              const outputElement = this.nodeEditor.shadowRoot?.getElementById(`node-${node.id}`)?.querySelector(`.output.${rule.output_id}`);
              if (outputElement) {
                if (!rule.isTargetEnabled) {
                  outputElement?.setAttribute("target-disabled", "true");
                  outputElement?.removeAttribute("has-error");
                } else {
                  if (node.outputs[rule.output_id].connections.length > 0) {
                    outputElement.setAttribute("in-use", "true");
                    outputElement?.removeAttribute("target-disabled");
                  } else {
                    outputElement.removeAttribute("in-use");
                    outputElement?.removeAttribute("target-disabled");
                  }
                }
              }
            });
            if (branchContainer.elseRule) {
              const elseRuleOutputElement = this.nodeEditor.shadowRoot?.getElementById(`node-${node.id}`)?.querySelector(
                `.output.${branchContainer.elseRule?.output_id}`
              );
              if (elseRuleOutputElement) {
                if (node.outputs[branchContainer.elseRule?.output_id]?.connections.length > 0) {
                  elseRuleOutputElement?.setAttribute("in-use", "true");
                  elseRuleOutputElement?.removeAttribute("target-disabled");
                  elseRuleOutputElement?.removeAttribute("has-error");
                } else {
                  elseRuleOutputElement?.removeAttribute("in-use");
                  elseRuleOutputElement?.removeAttribute("target-disabled");
                  elseRuleOutputElement?.setAttribute("has-error", "true");
                }
              }
            }
          }
        }
      } else {
        Object.entries(node.outputs).forEach(
          ([outputClass, output]) => {
            const outputElement = this.nodeEditor.shadowRoot?.getElementById(`node-${node.id}`)?.querySelector(`.output.${outputClass}`);
            if (outputElement) {
              if (output.connections.length > 0) {
                outputElement.setAttribute("in-use", "true");
              } else {
                outputElement.removeAttribute("in-use");
              }
            }
          }
        );
      }
    });
  }
  /*
  
  
    */
  nodeSearch() {
    let inputText = this.host.editorState.searchTerm;
    if (inputText != "") {
      let nodeIncludes = [
        .../* @__PURE__ */ new Set([
          ...this.nodeEditor.searchNodes(inputText),
          ...this.gamebookContainerManager.searchContainers(inputText)
        ])
      ];
      this.host.editorState.setSearchResults(nodeIncludes);
      this.nodeEditor.highlightSearchedNodes(nodeIncludes);
    } else {
      this.host.editorState.setSearchResults();
      this.nodeEditor.removeSearchHighlightFromAllNodes();
    }
    this.host.requestUpdate();
  }
  /*
  
  
    */
  moveTo(node) {
    this.nodeEditor.moveToNode(node);
    this._selectContainer(node.id);
    this.nodeEditor.programaticallySelectNode(node.id);
  }
};

// src/widgets/webwriter-branching-scenario.ts
var _editorState_dec, _tabIndex_dec6, _splitPanel_dec, _gamebookOptions_dec, _nodeEditor_dec2, _gamebookContainerManager_dec, _a23, _WebWriterBranchingScenario_decorators, _init23, _gamebookContainerManager, _nodeEditor2, _gamebookOptions, _splitPanel, _tabIndex6, _editorState;
_WebWriterBranchingScenario_decorators = [t4("webwriter-branching-scenario")];
var WebWriterBranchingScenario = class extends (_a23 = LitElementWw, _gamebookContainerManager_dec = [e7("gamebook-container-manager")], _nodeEditor_dec2 = [e7("node-editor")], _gamebookOptions_dec = [e7("webwriter-gamebook-options")], _splitPanel_dec = [e7("sl-split-panel")], _tabIndex_dec6 = [n6({ type: Number, attribute: true, reflect: true })], _editorState_dec = [e4({ context: editorState }), n6({
  type: Object,
  attribute: true,
  reflect: true,
  converter: {
    fromAttribute: (value) => GamebookEditorState.fromString(value),
    // Deserialize
    toAttribute: (value) => value.toString()
    // Serialize
  }
})], _a23) {
  /* 
  
  
  */
  constructor() {
    super();
    __privateAdd(this, _gamebookContainerManager, __runInitializers(_init23, 8, this)), __runInitializers(_init23, 11, this);
    __privateAdd(this, _nodeEditor2, __runInitializers(_init23, 12, this)), __runInitializers(_init23, 15, this);
    __privateAdd(this, _gamebookOptions, __runInitializers(_init23, 16, this)), __runInitializers(_init23, 19, this);
    __privateAdd(this, _splitPanel, __runInitializers(_init23, 20, this)), __runInitializers(_init23, 23, this);
    __privateAdd(this, _tabIndex6, __runInitializers(_init23, 24, this, -1)), __runInitializers(_init23, 27, this);
    __publicField(this, "controller", new GamebookEditorController(this));
    __privateAdd(this, _editorState, __runInitializers(_init23, 28, this, new GamebookEditorState("Untitled Gamebook"))), __runInitializers(_init23, 31, this);
    /*
    
    */
    __publicField(this, "_handleKeydown", (event) => {
      if ((event.metaKey || event.ctrlKey) && event.key === "f") {
        event.preventDefault();
        this.gamebookOptions.searchInput.focus();
      } else if ((event.metaKey || event.ctrlKey) && event.key === "c") {
        event.preventDefault();
        this.editorState.setCopiedNode(this.editorState.selectedNode);
      } else if ((event.metaKey || event.ctrlKey) && event.key === "v") {
        event.preventDefault();
        this.controller._pasteNode();
      }
    });
    this.reflectStoreChangesinDOM();
  }
  //registering custom elements used in the widget
  static get scopedElements() {
    return {
      "webwriter-gamebook-viewer": WebWriterGamebookViewer,
      "gamebook-container-manager": GamebookContainerManager,
      "node-detail-view": NodeDetailsView,
      "node-editor": NodeEditor,
      "webwriter-gamebook-options": WebWriterGamebookOptions,
      "split-view": SplitView,
      "sl-dialog": dialog_default
    };
  }
  /*
  
  */
  firstUpdated(_changedProperties) {
    this.controller.initReferences(
      this.nodeEditor,
      this.gamebookContainerManager
    );
    this.editorState.addObserver(() => {
      this.reflectStoreChangesinDOM();
      this.requestUpdate();
    });
  }
  /*
  
  */
  reflectStoreChangesinDOM() {
    this.editorState = new GamebookEditorState(
      this.editorState.title,
      this.editorState.observer,
      this.editorState.selectedNode,
      this.editorState.editorZoom,
      this.editorState.editorPosition,
      this.editorState.dividerPosition,
      this.editorState.editorIsCollapsed,
      this.editorState.editorContent,
      this.editorState.copiedNode,
      this.editorState.selectedContainer,
      this.editorState.branchIncomingContainer,
      this.editorState.searchTerm,
      this.editorState.searchResults
    );
  }
  /*
  
  */
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("keydown", this._handleKeydown);
  }
  /*
  
  */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener("keydown", this._handleKeydown);
  }
  /*
  
  */
  render() {
    return ke`
      <!-- <button @click=${() => this.exportContainersAsString()}></button> -->
      ${this.isContentEditable ? ke`
            <split-view>
              <node-editor
                slot="start"
                @editorInitialized=${() => this.controller._markUsedOutputs()}
                @nodeSelected=${(e10) => this.controller._selectContainer(e10.detail.nodeId)}
                @nodeUnselected=${(e10) => this.controller._unselectContainer()}
                @nodeCreated=${(e10) => this.controller._createContainerForNode(e10.detail.node)}
                @nodePasted=${(e10) => this.controller._copyAndPasteContainer(e10.detail.node)}
                @nodeRemoved=${(e10) => this.controller._removeContainer(e10.detail.id)}
                @nodeConnectedToBranchNode=${(e10) => this.controller._addSmartBranchButton(e10)}
                @nodesConnected=${(e10) => this.controller._addConnectionButton(e10)}
                @branchNodeConnected=${(e10) => this.controller._branchNodeConnected(e10)}
                @branchNodeConnectionRemoved=${(e10) => this.controller._outputBranchNodeConnectionRemove(e10)}
                @connectionRemoved=${(e10) => this.controller._removeButton(e10)}
                @editorCleared=${(e10) => this.controller._editorCleared()}
                @connectionSelected=${(e10) => this.controller._selectConnectionButton(e10)}
                @connectionUnselected=${(e10) => this.controller._unselectConnectionButton(e10)}
                @nodeGroupImported=${(e10) => this.controller._importTemplateContainers(e10)}
              >
              </node-editor>
              <node-detail-view
                slot="end"
                @renameSelectedNode="${(e10) => this.controller._renameSelectedNode(e10.detail.newTitle)}"
                @addOutput=${(e10) => this.controller._addOutput(e10)}
                @deleteOutput=${(e10) => this.controller._deleteOutput(e10)}
                @createConnection=${(e10) => this.controller._createConnection(e10)}
                @deleteConnection=${(e10) => this.controller._deleteConnection(e10)}
                @highlightConnection=${(e10) => this.controller._highlightConnection(e10)}
                @unhighlightConnection=${(e10) => this.controller._unhighlightConnection(e10)}
                @highlightOutput=${(e10) => this.controller._highlightOutput(e10)}
                @unhighlightOutput=${(e10) => this.controller._unhighlightOutput(e10)}
                @highlightNode=${(e10) => this.controller._highlightNode(e10)}
                @unhighlightNode=${(e10) => this.controller._unhighlightNode(e10)}
                @markOutputs=${() => this.controller._markUsedOutputs()}
              >
                <gamebook-container-manager
                  @managerInitialized=${() => this.controller._markUsedOutputs()}
                  @containerDeleted=${(e10) => this.controller._removeNode(e10.detail.id)}
                  @containerSelectFirstUpdate=${(e10) => this.controller._selectContainer(e10.detail.id)}
                  @containerError=${(e10) => this.controller._unselectContainer()}
                  @buttonDeleted=${(e10) => this.controller._removeConnection(e10)}
                  @quizElementDeleted=${(e10) => this.controller._deleteBranchRuleElementAndConnection(e10)}
                  @addOutput=${(e10) => this.controller._addOutput(e10)}
                  @deleteOutput=${(e10) => this.controller._deleteOutput(e10)}
                  @createConnection=${(e10) => this.controller._createConnection(e10)}
                  @deleteConnection=${(e10) => this.controller._deleteConnection(e10)}
                  @markOutputs=${() => this.controller._markUsedOutputs()}
                  @makeSelectedNodeOrigin=${(e10) => this.controller._changeOrigin(e10)}
                  @pasteNode=${() => this.controller._pasteNode()}
                  @deleteSelectedNode=${() => this.controller._deleteSelectedNode()}
                  @nodeSearch=${() => this.controller.nodeSearch()}
                  @moveTo=${(e10) => this.controller.moveTo(e10.detail.node)}
                  @hoverButton=${(e10) => this.controller._highlightConnection(e10)}
                  @leaveButton=${(e10) => this.controller._unhighlightConnection(e10)}
                >
                  <slot></slot>
                </gamebook-container-manager>
              </node-detail-view>
            </split-view>

            <!-- Options Menu -->
            <webwriter-gamebook-options
              part="options"
              @makeSelectedNodeOrigin=${(e10) => this.controller._changeOrigin(e10)}
              @pasteNode=${() => this.controller._pasteNode()}
              @deleteSelectedNode=${() => this.controller._deleteSelectedNode()}
              @nodeSearch=${() => this.controller.nodeSearch()}
              @moveTo=${(e10) => this.controller.moveTo(e10.detail.node)}
            ></webwriter-gamebook-options>
          ` : ke` <webwriter-gamebook-viewer
            gamebookTitle=${this.editorState.title != "" ? this.editorState.title : "Untitled Gamebook"}
            ><slot></slot
          ></webwriter-gamebook-viewer>`}
    `;
  }
  /*
  
  
    */
  exportContainersAsString() {
    console.log(JSON.stringify(this.nodeEditor.editor.drawflow));
    console.log(
      JSON.stringify(
        this.gamebookContainerManager.gamebookContainers,
        this.domElementReplacer
      )
    );
  }
  /*
  
    */
  domElementReplacer(key, value) {
    if (value instanceof HTMLElement) {
      return {
        tagName: value.tagName,
        attributes: [...value.attributes].map((attr) => ({
          name: attr.name,
          value: attr.value
        })),
        innerHTML: value.innerHTML
      };
    }
    return value;
  }
};
_init23 = __decoratorStart(_a23);
_gamebookContainerManager = new WeakMap();
_nodeEditor2 = new WeakMap();
_gamebookOptions = new WeakMap();
_splitPanel = new WeakMap();
_tabIndex6 = new WeakMap();
_editorState = new WeakMap();
__decorateElement(_init23, 4, "gamebookContainerManager", _gamebookContainerManager_dec, WebWriterBranchingScenario, _gamebookContainerManager);
__decorateElement(_init23, 4, "nodeEditor", _nodeEditor_dec2, WebWriterBranchingScenario, _nodeEditor2);
__decorateElement(_init23, 4, "gamebookOptions", _gamebookOptions_dec, WebWriterBranchingScenario, _gamebookOptions);
__decorateElement(_init23, 4, "splitPanel", _splitPanel_dec, WebWriterBranchingScenario, _splitPanel);
__decorateElement(_init23, 4, "tabIndex", _tabIndex_dec6, WebWriterBranchingScenario, _tabIndex6);
__decorateElement(_init23, 4, "editorState", _editorState_dec, WebWriterBranchingScenario, _editorState);
WebWriterBranchingScenario = __decorateElement(_init23, 0, "WebWriterBranchingScenario", _WebWriterBranchingScenario_decorators, WebWriterBranchingScenario);
//import CSS
__publicField(WebWriterBranchingScenario, "styles", [webwriter_branching_scenario_styles_default]);
__runInitializers(_init23, 1, WebWriterBranchingScenario);
export {
  WebWriterBranchingScenario
};
/*! Bundled license information:

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/lib/context-request-event.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/lib/create-context.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/lib/controllers/context-consumer.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/lib/value-notifier.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/lib/controllers/context-provider.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/lib/context-root.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/lib/decorators/provide.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/lib/decorators/consume.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@webwriter/lit/index.js:
  (*! Bundled license information:
  
  @lit/reactive-element/css-tag.js:
    (**
     * @license
     * Copyright 2019 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/reactive-element.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  lit-html/lit-html.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  lit-element/lit-element.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  lit-html/is-server.js:
    (**
     * @license
     * Copyright 2022 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/custom-element.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/property.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/state.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/event-options.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/base.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/query.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/query-all.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/query-async.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/query-assigned-elements.js:
    (**
     * @license
     * Copyright 2021 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/query-assigned-nodes.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/if-defined.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/live.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/when.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/static.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/unsafe-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/style-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/async-directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/ref.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/map.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/range.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/repeat.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
